{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Aerial project","text":"<p>Developing an air-to-ground measurement system to sense the wireless channel impulse response.</p> <p>This project has been developed by:</p> <ul> <li>Julian David Villegas Gutierrez - julian.villegas@vtt.fi</li> <li>Vasilii Semkin - vasilii.semkin@vtt.fi</li> </ul>"},{"location":"AnritsuSA/","title":"Anritsu Spectrum Analyzer module","text":"<p>             Bases: <code>object</code></p> <p>Python class to interact with the MS2760A Anritsu spectrum analyzer.</p> <p>Functionality implemented retrieves the peak (power and frequency) of the spectrum of the system under test.</p> <p>The spectrum analyzer also outputs xml files. Developer has to implement a method/s to parse the output of such files if they are used. In the commit history of the github of this project a parser was partially implemented (if the developer wants to check that).</p> Source code in <code>a2gmeasurements.py</code> <pre><code>class myAnritsuSpectrumAnalyzer(object):\n    \"\"\"\n    Python class to interact with the MS2760A Anritsu spectrum analyzer.\n\n    Functionality implemented retrieves the peak (power and frequency) of the spectrum of the system under test.\n\n    The spectrum analyzer also outputs xml files. Developer has to implement a method/s to parse the output of such files if they are used. In the commit history of the github of this project a parser was partially implemented (if the developer wants to check that).     \n    \"\"\"\n    def __init__(self, is_debug=True, is_config=True):\n        \"\"\"\n        Initializes attributes of this class.\n\n        Args:\n            is_debug (bool, optional): print debug messages. Defaults to True.\n            is_config (bool, optional): true if you want to configure the Spectrum Analyzer. Defaults to True.\n        \"\"\"\n\n        self.model = 'MS2760A'\n        self.is_debug = is_debug \n        self.is_config = is_config\n\n    def spectrum_analyzer_connect(self, HOST='127.0.0.1', PORT=9001):\n        \"\"\"\n        Creates a socket to connect to the spectrum analyzer.\n\n        Args:\n            HOST (str, optional): ip address of the spectrum analyzer. Defaults to ``127.0.0.1``.\n            PORT (int, optional): TCP/IP port. Defaults to 9001.\n        \"\"\"\n\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.anritsu_con_socket = s\n        self.anritsu_con_socket.connect((HOST, PORT))\n\n    def retrieve_max_pow(self, method=2):\n        \"\"\"\n        Retrieves the maximum power and its correspondent frequency of the spectrum of the system under test.\n\n        Args:\n            method (int, optional): how to get the maximum peak and corresponding frequency. This is for developer. It is indisctintive for user. Defaults to 2.\n\n        Raises:\n            Exception: when method is outside of available methods to compute the peak and corresponding frequency.\n\n        Returns:\n            Dictionary (dict): dictionary with self-explanatory keys 'MAG', 'MAG_UNITS', 'FREQ', 'FREQ_UNITS'.\n        \"\"\"\n\n        # Read the ID of the Spectrum Analyzer.\n        if self.is_debug:\n            self.anritsu_con_socket.send(b\"*IDN?\\n\")\n            self.anritsu_con_socket.settimeout(20)\n            rsp = self.anritsu_con_socket.recv(1024)\n            self.model = rsp.decode()\n\n        # Configure the Spectrum Analyzer\n        if self.is_config:\n            self.anritsu_con_socket.send(b\"SENS:FREQ:START 59.95 GHz\\n\")\n            self.anritsu_con_socket.send(b\"SENS:FREQ:STOP 60.05 GHz\\n\")\n            self.anritsu_con_socket.send(b\"BAND:RES 200 KHz\\n\")\n            self.anritsu_con_socket.send(b\":DISPLAY:POINTCOUNT 101\\n\")\n            self.anritsu_con_socket.send(b\":CALCulate:MARKer1:STATe 1\\n\")\n\n        # Find the maximum power\n        # 1. Pause the measurement collection\n        self.anritsu_con_socket.send(b\"INIT:CONT OFF\\n\")\n        if method == 1:\n            # 2.1 Place Marker 1 at maximum peak\n            self.anritsu_con_socket.send(b\":CALCulate:MARKer1:MAXimum\\n\")\n\n            # 2.2 Find the frequency in Hz\n            self.anritsu_con_socket.send(b\":CALCulate:MARKer1:X?\\n\")\n            freq = self.anritsu_con_socket.recv(1024)\n\n            # 2.3 Find the maximum power in dBm\n            self.anritsu_con_socket.send(b\":CALCulate:MARKer1:Y?\\n\")\n            pwr = self.anritsu_con_socket.recv(1024)\n        elif method == 2:\n            # 3.1 Find the maximum peak\n            self.anritsu_con_socket.send(b\":CALCulate:PEAK:COUNt 1\\n\")\n\n            # 3.2 Read the frequency and power\n            self.anritsu_con_socket.send(b\":FETCh:PEAK?\\n\")\n            rsp = self.anritsu_con_socket.recv(4096)\n            freq, pwr = rsp.decode().split(',')\n        else:\n            raise Exception(\"Error: Method not supported.\")\n        # 4. Resume the measurement collection\n        self.anritsu_con_socket.send(b\"INIT:CONT ON\\n\")\n\n        #print(f\"Max power {float(pwr):.2f} dBm at {float(freq)*1e-9:.3f} GHz\")\n\n        return {'MAG': float(pwr), 'MAG_UNITS': 'dBm', 'FREQ': float(freq), 'FREQ_UNITS': 'Hz'}\n\n    def spectrum_analyzer_close(self):\n        \"\"\"\n        Closes the socket.\n        \"\"\"\n\n        self.anritsu_con_socket.close()\n</code></pre>"},{"location":"AnritsuSA/#a2gmeasurements.myAnritsuSpectrumAnalyzer.__init__","title":"<code>__init__(is_debug=True, is_config=True)</code>","text":"<p>Initializes attributes of this class.</p> <p>Parameters:</p> Name Type Description Default <code>is_debug</code> <code>bool</code> <p>print debug messages. Defaults to True.</p> <code>True</code> <code>is_config</code> <code>bool</code> <p>true if you want to configure the Spectrum Analyzer. Defaults to True.</p> <code>True</code> Source code in <code>a2gmeasurements.py</code> <pre><code>def __init__(self, is_debug=True, is_config=True):\n    \"\"\"\n    Initializes attributes of this class.\n\n    Args:\n        is_debug (bool, optional): print debug messages. Defaults to True.\n        is_config (bool, optional): true if you want to configure the Spectrum Analyzer. Defaults to True.\n    \"\"\"\n\n    self.model = 'MS2760A'\n    self.is_debug = is_debug \n    self.is_config = is_config\n</code></pre>"},{"location":"AnritsuSA/#a2gmeasurements.myAnritsuSpectrumAnalyzer.retrieve_max_pow","title":"<code>retrieve_max_pow(method=2)</code>","text":"<p>Retrieves the maximum power and its correspondent frequency of the spectrum of the system under test.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>int</code> <p>how to get the maximum peak and corresponding frequency. This is for developer. It is indisctintive for user. Defaults to 2.</p> <code>2</code> <p>Raises:</p> Type Description <code>Exception</code> <p>when method is outside of available methods to compute the peak and corresponding frequency.</p> <p>Returns:</p> Name Type Description <code>Dictionary</code> <code>dict</code> <p>dictionary with self-explanatory keys 'MAG', 'MAG_UNITS', 'FREQ', 'FREQ_UNITS'.</p> Source code in <code>a2gmeasurements.py</code> <pre><code>def retrieve_max_pow(self, method=2):\n    \"\"\"\n    Retrieves the maximum power and its correspondent frequency of the spectrum of the system under test.\n\n    Args:\n        method (int, optional): how to get the maximum peak and corresponding frequency. This is for developer. It is indisctintive for user. Defaults to 2.\n\n    Raises:\n        Exception: when method is outside of available methods to compute the peak and corresponding frequency.\n\n    Returns:\n        Dictionary (dict): dictionary with self-explanatory keys 'MAG', 'MAG_UNITS', 'FREQ', 'FREQ_UNITS'.\n    \"\"\"\n\n    # Read the ID of the Spectrum Analyzer.\n    if self.is_debug:\n        self.anritsu_con_socket.send(b\"*IDN?\\n\")\n        self.anritsu_con_socket.settimeout(20)\n        rsp = self.anritsu_con_socket.recv(1024)\n        self.model = rsp.decode()\n\n    # Configure the Spectrum Analyzer\n    if self.is_config:\n        self.anritsu_con_socket.send(b\"SENS:FREQ:START 59.95 GHz\\n\")\n        self.anritsu_con_socket.send(b\"SENS:FREQ:STOP 60.05 GHz\\n\")\n        self.anritsu_con_socket.send(b\"BAND:RES 200 KHz\\n\")\n        self.anritsu_con_socket.send(b\":DISPLAY:POINTCOUNT 101\\n\")\n        self.anritsu_con_socket.send(b\":CALCulate:MARKer1:STATe 1\\n\")\n\n    # Find the maximum power\n    # 1. Pause the measurement collection\n    self.anritsu_con_socket.send(b\"INIT:CONT OFF\\n\")\n    if method == 1:\n        # 2.1 Place Marker 1 at maximum peak\n        self.anritsu_con_socket.send(b\":CALCulate:MARKer1:MAXimum\\n\")\n\n        # 2.2 Find the frequency in Hz\n        self.anritsu_con_socket.send(b\":CALCulate:MARKer1:X?\\n\")\n        freq = self.anritsu_con_socket.recv(1024)\n\n        # 2.3 Find the maximum power in dBm\n        self.anritsu_con_socket.send(b\":CALCulate:MARKer1:Y?\\n\")\n        pwr = self.anritsu_con_socket.recv(1024)\n    elif method == 2:\n        # 3.1 Find the maximum peak\n        self.anritsu_con_socket.send(b\":CALCulate:PEAK:COUNt 1\\n\")\n\n        # 3.2 Read the frequency and power\n        self.anritsu_con_socket.send(b\":FETCh:PEAK?\\n\")\n        rsp = self.anritsu_con_socket.recv(4096)\n        freq, pwr = rsp.decode().split(',')\n    else:\n        raise Exception(\"Error: Method not supported.\")\n    # 4. Resume the measurement collection\n    self.anritsu_con_socket.send(b\"INIT:CONT ON\\n\")\n\n    #print(f\"Max power {float(pwr):.2f} dBm at {float(freq)*1e-9:.3f} GHz\")\n\n    return {'MAG': float(pwr), 'MAG_UNITS': 'dBm', 'FREQ': float(freq), 'FREQ_UNITS': 'Hz'}\n</code></pre>"},{"location":"AnritsuSA/#a2gmeasurements.myAnritsuSpectrumAnalyzer.spectrum_analyzer_close","title":"<code>spectrum_analyzer_close()</code>","text":"<p>Closes the socket.</p> Source code in <code>a2gmeasurements.py</code> <pre><code>def spectrum_analyzer_close(self):\n    \"\"\"\n    Closes the socket.\n    \"\"\"\n\n    self.anritsu_con_socket.close()\n</code></pre>"},{"location":"AnritsuSA/#a2gmeasurements.myAnritsuSpectrumAnalyzer.spectrum_analyzer_connect","title":"<code>spectrum_analyzer_connect(HOST='127.0.0.1', PORT=9001)</code>","text":"<p>Creates a socket to connect to the spectrum analyzer.</p> <p>Parameters:</p> Name Type Description Default <code>HOST</code> <code>str</code> <p>ip address of the spectrum analyzer. Defaults to <code>127.0.0.1</code>.</p> <code>'127.0.0.1'</code> <code>PORT</code> <code>int</code> <p>TCP/IP port. Defaults to 9001.</p> <code>9001</code> Source code in <code>a2gmeasurements.py</code> <pre><code>def spectrum_analyzer_connect(self, HOST='127.0.0.1', PORT=9001):\n    \"\"\"\n    Creates a socket to connect to the spectrum analyzer.\n\n    Args:\n        HOST (str, optional): ip address of the spectrum analyzer. Defaults to ``127.0.0.1``.\n        PORT (int, optional): TCP/IP port. Defaults to 9001.\n    \"\"\"\n\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    self.anritsu_con_socket = s\n    self.anritsu_con_socket.connect((HOST, PORT))\n</code></pre>"},{"location":"CommunicationProtocol/","title":"Communication protocol","text":"<p>A TCP communication is established between the ground and drone nodes. This link is bidirectional and is used to retrieve information, send control and configuration instructions. </p> <p>In the communication link, the ground node works as the server while the drone node works as the client.</p> <p>Each message between both nodes has the 5 mandatory fields shown in the following Table.</p> Field Bytes Description Values <code>source_id</code> 1 Identifier for the message sender <code>0x01</code>: ground node, <code>0x02</code>: drone node <code>destination_id</code> 1 Identifier for the message received <code>0x01</code>: ground node, <code>0x02</code>: drone node <code>message_type</code> 1 Distinguish between messages with acknowledgment from the receiver, and no acknowledgment <code>0x01</code>: short msg with no ack, <code>0x02</code>: long msg with no ack, <code>0x03</code>: short msg with ack <code>cmd</code> 1 Identifier for the command <code>0x01</code>-<code>0x09</code> when <code>message_type</code>=<code>0x01</code>. Otherwise, <code>0x01</code> <code>length</code> 1 Counts either the number of bytes or the number of keys in a dictionary in the optional <code>data</code> field. If no <code>data</code> is provided is 0 0 - 255 <p>The list of available commands are shown in the following Table.</p> cmd message_type Command name Description <code>0x01</code> <code>0x01</code> <code>FOLLOWGIMBAL</code> Asks the msg receiver to send its GPS coordinates to use them for steering the sender's gimbal towards the receiver <code>0x02</code> <code>0x01</code> <code>GETGPS</code> Asks the msg receiver to send its GPS coordinates to use them for visualization or other purposes different from steering sender's gimbal <code>0x03</code> <code>0x01</code> <code>SETGIMBAL</code> Sets the msg receiver's yaw, pitch and roll angles for its connected gimbal <code>0x04</code> <code>0x01</code> <code>STARTDRONERFSOC</code> Unidirectional command sent always from the ground node to the drone node. Starts a measurement in the drone RFSoC <code>0x05</code> <code>0x01</code> <code>STOPDRONERFSOC</code> Unidirectional command sent always from the ground node to the drone node. Stops a measurement in the drone RFSoC <code>0x06</code> <code>0x01</code> <code>FINISHDRONERFSOC</code> Unidirectional command sent always from the ground node to the drone node. Finishes a measurement in the drone RFSoC <code>0x07</code> <code>0x01</code> <code>CLOSEDGUI</code> Unidirectional command sent always from the ground node to the drone node. Tells the drone node that it can stop the execution of its running script <code>0x08</code> <code>0x01</code> <code>SETREMOTEFMFLAG</code> Unidirectional command sent always from the ground node to the drone node. Activates the <code>drone_fm_flag</code> flag used to initiate the steering of the drone's gimbal towards the ground node. Sends a data field with the sub-fields shown in next Table <code>0x09</code> <code>0x01</code> <code>SETREMOTESTOPFM</code> Unidirectional command sent always from the ground node to the drone node. Deactivates the <code>drone_fm_flag flag</code> <code>0x01</code> <code>0x02</code> <code>SETIRF</code> Unidirectional command sent always from the ground node to the drone node. Sends a data field containing a measured Power Angular Profile. More info in next Table <code>0x01</code> <code>0x03</code> <code>ANS</code> to <code>GETGPS</code> Answer to a <code>GETGPS</code> command. The answer contains a <code>data</code> field with the sub-fields shown in next Table <p>The data field of the messages send is used under specific commands. The length of the data field depends specifically on the command. The information send in the <code>data</code> field for the different commands is shown in the following Table:</p> Data field Command name Available options <code>FMODE</code> <code>FOLLOWGIMBAL</code> <code>0x00</code>: steer azimuth and elevation axis of ground node's gimbal.  <code>0x01</code>: steer elevation axis of ground node's gimbal, <code>0x02</code>: steer azimuth axis of ground node's gimbal <code>YAW</code> <code>SETGIMBAL</code> Sets the yaw at which to set the other (remote) gimbal <code>PITCH</code> <code>SETGIMBAL</code> Sets the pitch at which to set the other (remote) gimbal <code>ROLL</code> <code>SETGIMBAL</code> Sets the roll at which to set the other (remote) gimbal <code>carrier_freq</code> <code>STARTDRONERFSOC</code> Sets the operating frequency on drone's RFSoC <code>rx_gain_ctrl_bb1</code> <code>STARTDRONERFSOC</code> Sets the first baseband (BB) gain for the Sivers receiver <code>rx_gain_ctrl_bb2</code> <code>`STARTDRONERFSOC</code> Sets the second BB gain for the Sivers receiver <code>rx_gain_ctrl_bb3</code> <code>STARTDRONERFSOC</code> Sets the third BB gain for the Sivers receiver <code>rx_gain_ctrl_bfrf</code> <code>STARTDRONERFSOC</code> Sets the gain for the I, Q signals before the RF mixer <code>X</code> <code>SETREMOTEFMFLAG</code> If the ground node's mobility has been set as static, this parameter sets the geocentric <code>X</code> coordinate corresponding to EPSG 4978. The actual value is set by the user in the GUI by setting the latitude, longitude and altitude coordinates of the ground node <code>Y</code> <code>SETREMOTEFMFLAG</code> If the ground node's mobility has been set as static, this parameter sets the geocentric <code>Y</code> coordinate corresponding to EPSG 4978. The actual value is set by the user in the GUI by setting the latitude, longitude and altitude coordinates of the ground node <code>Z</code> <code>SETREMOTEFMFLAG</code> If the ground node's mobility has been set as static, this parameter sets the geocentric <code>Z</code> coordinate corresponding to EPSG 4978. The actual value is set by the user in the GUI by setting the latitude, longitude and altitude coordinates of the ground node <code>FMODE</code> <code>SETREMOTEFMFLAG</code> <code>0x00</code>: steer azimuth and elevation axis of drone node's gimbal. <code>0x01</code>: steer elevation axis of drone node's gimbal. <code>0x02</code>: steer azimuth axis of drone node's gimbal <code>MOBILITY</code> <code>SETREMOTEFMFLAG</code> <code>0x00</code>: ground node is moving,  <code>0x01</code> ground node is static <p>NOTE: it seems that the Raspbian OS (64 bits) restricts TCP messages to have a maximum of 1472 bytes, no matter if the MTU is bigger. This issue has to be solved if it is desired to send a Power Angular Profile (PAP) that contains more than 23 time snapshots and/or more than 16 beams.</p>"},{"location":"GUIparameters/","title":"GUI global parameters","text":"<p>The variable <code>update_vis_time_pap</code> has to be higher or equal than the regularity at which <code>send_pap_for_vis</code> is called. The latter function is called each time the buffer <code>hest</code> reaches the size given by <code>MAX_PAP_BUF_SIZE</code>. </p> <p>For example, for <code>MAX_PAP_BUF_SIZE</code> $ = 220$ and an average callback time of 100 ms for <code>receive_signal_async</code>, the function <code>send_pap_for_vis()</code> will be called each 2.2 s.</p>"},{"location":"GUIsetupWin/","title":"Graphical User Interface: Setup window","text":"<p>             Bases: <code>QDialog</code></p> <p>Creates a new dialog with configuration options for the user, when is pressed the <code>Setup</code> &gt; <code>Setup devices and more</code> menu.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>class SetupWindow(QDialog):\n    \"\"\"\n    Creates a new dialog with configuration options for the user, when is pressed the ``Setup`` &gt; ``Setup devices and more`` menu.\n    \"\"\"\n    def __init__(self, parent=None):\n        \"\"\"\n        Creates the PyQt5 components of the setup dialog and sets its layout with them.\n\n        Args:\n            parent (none, optional): not used. Defaults to None.\n        \"\"\"\n\n        super(SetupWindow, self).__init__(parent)\n        self.setWindowTitle(\"Setup\")\n        #self.setGeometry(100, 100, 300, 220)\n\n        self.droneGimbalChoiceTDMenu = QComboBox()\n        self.droneGimbalChoiceTDMenu.addItems([\"DJI Ronin RS2\", \"Gremsy H16\"])\n\n        droneGimbalChoiceLabel = QLabel(\"&amp;Choose drone gimbal:\")\n        droneGimbalChoiceLabel.setBuddy(self.droneGimbalChoiceTDMenu)\n\n        self.fm_droneGimbal_TDMenu = QComboBox()\n        self.fm_droneGimbal_TDMenu.addItems([\"Only elevation\", \"Only azimuth\", \"Elevation and azimuth\"])\n\n        fmdroneGimbalChoiceLabel = QLabel(\"&amp;Choose drone gimbal following mode (if it will be used):\")\n        fmdroneGimbalChoiceLabel.setBuddy(self.fm_droneGimbal_TDMenu)\n\n        self.fm_gndGimbal_TDMenu = QComboBox()\n        self.fm_gndGimbal_TDMenu.addItems([\"Only elevation\", \"Only azimuth\", \"Elevation and azimuth\"])\n\n        fmgndGimbalChoiceLabel = QLabel(\"&amp;Choose ground gimbal following mode (if it will be used):\")\n        fmgndGimbalChoiceLabel.setBuddy(self.fm_gndGimbal_TDMenu)\n\n        self.gnd_mobility_TDMenu = QComboBox()\n        self.gnd_mobility_TDMenu.addItems([\"Moving\", \"Static\"])\n        self.gnd_mobility_TDMenu.activated[str].connect(self.enable_gnd_coords_callback)\n\n        gnd_mobility_label = QLabel(\"&amp;Choose ground node mobility:\")\n        gnd_mobility_label.setBuddy(self.gnd_mobility_TDMenu)\n\n        self.gnd_lat_textEdit = QLineEdit('')\n        gnd_lat_label = QLabel(\"Enter lat of static (ground) node:\")\n        self.gnd_lon_textEdit = QLineEdit('')\n        gnd_lon_label = QLabel(\"Enter lon of static (ground) node:\")\n        self.gnd_alt_textEdit = QLineEdit('')\n        gnd_alt_label = QLabel(\"Enter altitude of static (ground) node:\")\n        self.gnd_lat_textEdit.setEnabled(False)\n        self.gnd_lon_textEdit.setEnabled(False)\n        self.gnd_alt_textEdit.setEnabled(False)\n\n        self.drone_mobility_TDMenu = QComboBox()\n        self.drone_mobility_TDMenu.addItems([\"Moving\", \"Static\"])\n        self.drone_mobility_TDMenu.activated[str].connect(self.enable_drone_coords_callback)\n\n        drone_mobility_label = QLabel(\"&amp;Choose drone node mobility:\")\n        drone_mobility_label.setBuddy(self.drone_mobility_TDMenu)\n\n        self.drone_lat_textEdit = QLineEdit('')\n        drone_lat_label = QLabel(\"Enter lat of static (drone) node:\")\n        self.drone_lon_textEdit = QLineEdit('')\n        drone_lon_label = QLabel(\"Enter lon of static (drone) node:\")\n        self.drone_alt_textEdit = QLineEdit('')\n        drone_alt_label = QLabel(\"Enter alt of static (drone) node:\")\n        self.drone_lat_textEdit.setEnabled(False)\n        self.drone_lon_textEdit.setEnabled(False)\n        self.drone_alt_textEdit.setEnabled(False)\n\n        self.gnd_gps_att_offset_textEdit = QLineEdit('0')\n        gnd_gps_att_offset_label = QLabel(\"Enter the heading offset for the ground gps:\")\n\n        self.ok_button = QPushButton(\"OK\")\n        self.ok_button.clicked.connect(self.accept)\n\n        layout = QGridLayout()\n        layout.addWidget(droneGimbalChoiceLabel, 0, 0, 1, 3)\n        layout.addWidget(self.droneGimbalChoiceTDMenu, 0, 3, 1, 3)\n        layout.addWidget(fmdroneGimbalChoiceLabel, 1, 0, 1, 3)\n        layout.addWidget(self.fm_droneGimbal_TDMenu, 1, 3, 1, 3)\n        layout.addWidget(fmgndGimbalChoiceLabel, 2, 0, 1, 3)\n        layout.addWidget(self.fm_gndGimbal_TDMenu, 2, 3, 1, 3)\n\n        layout.addWidget(gnd_mobility_label, 3, 0, 1, 3)\n        layout.addWidget(self.gnd_mobility_TDMenu, 3, 3, 1, 3)\n        layout.addWidget(gnd_lat_label, 4, 0, 1, 3)\n        layout.addWidget(self.gnd_lat_textEdit, 4, 3, 1, 3)\n        layout.addWidget(gnd_lon_label, 5, 0, 1, 3)\n        layout.addWidget(self.gnd_lon_textEdit, 5, 3, 1, 3)\n        layout.addWidget(gnd_alt_label, 6, 0, 1, 3)\n        layout.addWidget(self.gnd_alt_textEdit, 6, 3, 1, 3)\n\n        layout.addWidget(drone_mobility_label, 7, 0, 1, 3)\n        layout.addWidget(self.drone_mobility_TDMenu, 7, 3, 1, 3)\n        layout.addWidget(drone_lat_label, 8, 0, 1, 3)\n        layout.addWidget(self.drone_lat_textEdit, 8, 3, 1, 3)\n        layout.addWidget(drone_lon_label, 9, 0, 1, 3)\n        layout.addWidget(self.drone_lon_textEdit, 9, 3, 1, 3)\n        layout.addWidget(drone_alt_label, 10, 0, 1, 3)\n        layout.addWidget(self.drone_alt_textEdit, 10, 3, 1, 3)\n        layout.addWidget(gnd_gps_att_offset_label, 11, 0, 1, 3)\n        layout.addWidget(self.gnd_gps_att_offset_textEdit, 11, 3, 1, 3)\n\n        layout.addWidget(self.ok_button, 12, 0, 1, 6)\n        self.setLayout(layout)  \n\n    def enable_gnd_coords_callback(self, myinput):\n        \"\"\"\n        Enables the ground coordinates QLineEdits when the user inputs a ``Static`` mobility for the ground node in the Setup dialog.\n\n        Args:\n            myinput (str): ground node mobility. Either ``Static`` or ``Moving``.\n        \"\"\"\n\n        if myinput == \"Static\":\n            self.gnd_lat_textEdit.setEnabled(True)\n            self.gnd_lon_textEdit.setEnabled(True)\n            self.gnd_alt_textEdit.setEnabled(True)\n        elif myinput == \"Moving\":\n            self.gnd_lat_textEdit.setEnabled(False)\n            self.gnd_lon_textEdit.setEnabled(False)\n            self.gnd_alt_textEdit.setEnabled(False)\n\n    def enable_drone_coords_callback(self, myinput):\n        \"\"\"\n        Enables the drone coordinates QLineEdits when the user inputs a ``Static`` mobility for the drone node in the Setup dialog.\n\n        Args:\n            myinput (str): drone node mobility. Either ``Static`` or ``Moving``.\n        \"\"\"\n\n        if myinput == \"Static\":\n            self.drone_lat_textEdit.setEnabled(True)\n            self.drone_lon_textEdit.setEnabled(True)\n            self.drone_alt_textEdit.setEnabled(True)\n        elif myinput == \"Moving\":\n            self.drone_lat_textEdit.setEnabled(False)\n            self.drone_lon_textEdit.setEnabled(False)\n            self.drone_alt_textEdit.setEnabled(False)\n</code></pre>"},{"location":"GUIsetupWin/#GUI_A2G_MEAS.SetupWindow.__init__","title":"<code>__init__(parent=None)</code>","text":"<p>Creates the PyQt5 components of the setup dialog and sets its layout with them.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>none</code> <p>not used. Defaults to None.</p> <code>None</code> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def __init__(self, parent=None):\n    \"\"\"\n    Creates the PyQt5 components of the setup dialog and sets its layout with them.\n\n    Args:\n        parent (none, optional): not used. Defaults to None.\n    \"\"\"\n\n    super(SetupWindow, self).__init__(parent)\n    self.setWindowTitle(\"Setup\")\n    #self.setGeometry(100, 100, 300, 220)\n\n    self.droneGimbalChoiceTDMenu = QComboBox()\n    self.droneGimbalChoiceTDMenu.addItems([\"DJI Ronin RS2\", \"Gremsy H16\"])\n\n    droneGimbalChoiceLabel = QLabel(\"&amp;Choose drone gimbal:\")\n    droneGimbalChoiceLabel.setBuddy(self.droneGimbalChoiceTDMenu)\n\n    self.fm_droneGimbal_TDMenu = QComboBox()\n    self.fm_droneGimbal_TDMenu.addItems([\"Only elevation\", \"Only azimuth\", \"Elevation and azimuth\"])\n\n    fmdroneGimbalChoiceLabel = QLabel(\"&amp;Choose drone gimbal following mode (if it will be used):\")\n    fmdroneGimbalChoiceLabel.setBuddy(self.fm_droneGimbal_TDMenu)\n\n    self.fm_gndGimbal_TDMenu = QComboBox()\n    self.fm_gndGimbal_TDMenu.addItems([\"Only elevation\", \"Only azimuth\", \"Elevation and azimuth\"])\n\n    fmgndGimbalChoiceLabel = QLabel(\"&amp;Choose ground gimbal following mode (if it will be used):\")\n    fmgndGimbalChoiceLabel.setBuddy(self.fm_gndGimbal_TDMenu)\n\n    self.gnd_mobility_TDMenu = QComboBox()\n    self.gnd_mobility_TDMenu.addItems([\"Moving\", \"Static\"])\n    self.gnd_mobility_TDMenu.activated[str].connect(self.enable_gnd_coords_callback)\n\n    gnd_mobility_label = QLabel(\"&amp;Choose ground node mobility:\")\n    gnd_mobility_label.setBuddy(self.gnd_mobility_TDMenu)\n\n    self.gnd_lat_textEdit = QLineEdit('')\n    gnd_lat_label = QLabel(\"Enter lat of static (ground) node:\")\n    self.gnd_lon_textEdit = QLineEdit('')\n    gnd_lon_label = QLabel(\"Enter lon of static (ground) node:\")\n    self.gnd_alt_textEdit = QLineEdit('')\n    gnd_alt_label = QLabel(\"Enter altitude of static (ground) node:\")\n    self.gnd_lat_textEdit.setEnabled(False)\n    self.gnd_lon_textEdit.setEnabled(False)\n    self.gnd_alt_textEdit.setEnabled(False)\n\n    self.drone_mobility_TDMenu = QComboBox()\n    self.drone_mobility_TDMenu.addItems([\"Moving\", \"Static\"])\n    self.drone_mobility_TDMenu.activated[str].connect(self.enable_drone_coords_callback)\n\n    drone_mobility_label = QLabel(\"&amp;Choose drone node mobility:\")\n    drone_mobility_label.setBuddy(self.drone_mobility_TDMenu)\n\n    self.drone_lat_textEdit = QLineEdit('')\n    drone_lat_label = QLabel(\"Enter lat of static (drone) node:\")\n    self.drone_lon_textEdit = QLineEdit('')\n    drone_lon_label = QLabel(\"Enter lon of static (drone) node:\")\n    self.drone_alt_textEdit = QLineEdit('')\n    drone_alt_label = QLabel(\"Enter alt of static (drone) node:\")\n    self.drone_lat_textEdit.setEnabled(False)\n    self.drone_lon_textEdit.setEnabled(False)\n    self.drone_alt_textEdit.setEnabled(False)\n\n    self.gnd_gps_att_offset_textEdit = QLineEdit('0')\n    gnd_gps_att_offset_label = QLabel(\"Enter the heading offset for the ground gps:\")\n\n    self.ok_button = QPushButton(\"OK\")\n    self.ok_button.clicked.connect(self.accept)\n\n    layout = QGridLayout()\n    layout.addWidget(droneGimbalChoiceLabel, 0, 0, 1, 3)\n    layout.addWidget(self.droneGimbalChoiceTDMenu, 0, 3, 1, 3)\n    layout.addWidget(fmdroneGimbalChoiceLabel, 1, 0, 1, 3)\n    layout.addWidget(self.fm_droneGimbal_TDMenu, 1, 3, 1, 3)\n    layout.addWidget(fmgndGimbalChoiceLabel, 2, 0, 1, 3)\n    layout.addWidget(self.fm_gndGimbal_TDMenu, 2, 3, 1, 3)\n\n    layout.addWidget(gnd_mobility_label, 3, 0, 1, 3)\n    layout.addWidget(self.gnd_mobility_TDMenu, 3, 3, 1, 3)\n    layout.addWidget(gnd_lat_label, 4, 0, 1, 3)\n    layout.addWidget(self.gnd_lat_textEdit, 4, 3, 1, 3)\n    layout.addWidget(gnd_lon_label, 5, 0, 1, 3)\n    layout.addWidget(self.gnd_lon_textEdit, 5, 3, 1, 3)\n    layout.addWidget(gnd_alt_label, 6, 0, 1, 3)\n    layout.addWidget(self.gnd_alt_textEdit, 6, 3, 1, 3)\n\n    layout.addWidget(drone_mobility_label, 7, 0, 1, 3)\n    layout.addWidget(self.drone_mobility_TDMenu, 7, 3, 1, 3)\n    layout.addWidget(drone_lat_label, 8, 0, 1, 3)\n    layout.addWidget(self.drone_lat_textEdit, 8, 3, 1, 3)\n    layout.addWidget(drone_lon_label, 9, 0, 1, 3)\n    layout.addWidget(self.drone_lon_textEdit, 9, 3, 1, 3)\n    layout.addWidget(drone_alt_label, 10, 0, 1, 3)\n    layout.addWidget(self.drone_alt_textEdit, 10, 3, 1, 3)\n    layout.addWidget(gnd_gps_att_offset_label, 11, 0, 1, 3)\n    layout.addWidget(self.gnd_gps_att_offset_textEdit, 11, 3, 1, 3)\n\n    layout.addWidget(self.ok_button, 12, 0, 1, 6)\n    self.setLayout(layout)  \n</code></pre>"},{"location":"GUIsetupWin/#GUI_A2G_MEAS.SetupWindow.enable_drone_coords_callback","title":"<code>enable_drone_coords_callback(myinput)</code>","text":"<p>Enables the drone coordinates QLineEdits when the user inputs a <code>Static</code> mobility for the drone node in the Setup dialog.</p> <p>Parameters:</p> Name Type Description Default <code>myinput</code> <code>str</code> <p>drone node mobility. Either <code>Static</code> or <code>Moving</code>.</p> required Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def enable_drone_coords_callback(self, myinput):\n    \"\"\"\n    Enables the drone coordinates QLineEdits when the user inputs a ``Static`` mobility for the drone node in the Setup dialog.\n\n    Args:\n        myinput (str): drone node mobility. Either ``Static`` or ``Moving``.\n    \"\"\"\n\n    if myinput == \"Static\":\n        self.drone_lat_textEdit.setEnabled(True)\n        self.drone_lon_textEdit.setEnabled(True)\n        self.drone_alt_textEdit.setEnabled(True)\n    elif myinput == \"Moving\":\n        self.drone_lat_textEdit.setEnabled(False)\n        self.drone_lon_textEdit.setEnabled(False)\n        self.drone_alt_textEdit.setEnabled(False)\n</code></pre>"},{"location":"GUIsetupWin/#GUI_A2G_MEAS.SetupWindow.enable_gnd_coords_callback","title":"<code>enable_gnd_coords_callback(myinput)</code>","text":"<p>Enables the ground coordinates QLineEdits when the user inputs a <code>Static</code> mobility for the ground node in the Setup dialog.</p> <p>Parameters:</p> Name Type Description Default <code>myinput</code> <code>str</code> <p>ground node mobility. Either <code>Static</code> or <code>Moving</code>.</p> required Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def enable_gnd_coords_callback(self, myinput):\n    \"\"\"\n    Enables the ground coordinates QLineEdits when the user inputs a ``Static`` mobility for the ground node in the Setup dialog.\n\n    Args:\n        myinput (str): ground node mobility. Either ``Static`` or ``Moving``.\n    \"\"\"\n\n    if myinput == \"Static\":\n        self.gnd_lat_textEdit.setEnabled(True)\n        self.gnd_lon_textEdit.setEnabled(True)\n        self.gnd_alt_textEdit.setEnabled(True)\n    elif myinput == \"Moving\":\n        self.gnd_lat_textEdit.setEnabled(False)\n        self.gnd_lon_textEdit.setEnabled(False)\n        self.gnd_alt_textEdit.setEnabled(False)\n</code></pre>"},{"location":"GUIwidgetGallery/","title":"Graphical User Interface: Main window","text":"<p>             Bases: <code>QMainWindow</code></p> <p>Python class responsible for creating the main window of the GUI and all the functionality to handle user interaction.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>class WidgetGallery(QMainWindow):\n    \"\"\"\n    Python class responsible for creating the main window of the GUI and all the functionality to handle user interaction.\n\n    \"\"\"\n    def __init__(self, parent=None):\n        \"\"\"\n        Calls the functions to create some class attributes and the menu bar with its associated callbacks.\n\n        Args:\n            parent (none, optional): not used, but required. Defaults to None.\n        \"\"\"\n\n        super(WidgetGallery, self).__init__(parent)\n\n        self.setWindowTitle(\"A2G Measurements Center\")\n\n        self.init_constants()\n\n        self.createMenu()\n\n        self.dummyWidget = QWidget()\n        self.setCentralWidget(self.dummyWidget)\n        #self.setLayout(mainLayout)\n\n        self.showMaximized()\n\n    def init_constants(self):\n        \"\"\"\n        Creates some class attributes. \n\n        The ``STATIC_DRONE_IP_ADDRESS`` is to set a static IP address for the drone. This IP address must be assigned to the drone from the router configuration interface (this IP address was set for the drone on the Archer AX router)\n\n        \"\"\"\n        # Parameters of the GUI\n        self.debug_cnt_1 = 1\n        self.STATIC_DRONE_IP_ADDRESS = '192.168.0.157'\n        self.number_lines_log_terminal = 100\n        self.log_terminal_txt = \"\"\n        self.remote_drone_conn = None\n\n        self.SUCCESS_PING_DRONE = False\n        self.SUCCESS_SSH = False\n        self.SUCCESS_DRONE_FPGA = False\n        self.SUCCESS_DRONE_GPS = False\n        self.SUCCES_DRONE_GIMBAL = False\n        self.SUCCESS_GND_FPGA = False\n        self.SUCCESS_GND_GIMBAL = False\n        self.SUCCESS_GND_GPS = False\n\n        self.url_get_map = \"\"\"'http://127.0.0.1:8000/gps/get'\"\"\"\n        self.url_post_map = \"http://127.0.0.1:8000/gps/post/septentrio\"\n        self.url_put_map = \"http://127.0.0.1:8000/gps/update/septentrio\"\n\n    def showCentralWidget(self):\n        \"\"\"\n        Creates and shows the panels of the main window according to grid layout defined in this function.\n        \"\"\"\n\n        #self.original_stdout = sys.stdout\n        self.create_check_connections_panel()\n        #self.create_log_terminal()\n        self.create_Gimbal_GND_panel()\n        self.create_Gimbal_AIR_panel()\n        self.create_fpga_and_sivers_panel()\n        self.create_Planning_Measurements_panel()\n        self.create_GPS_visualization_panel()\n        self.create_pap_plot_panel()\n\n        mainLayout = QGridLayout()\n        mainLayout.addWidget(self.checkConnPanel, 0, 0, 1 , 4)\n        mainLayout.addWidget(self.gimbalTXPanel, 1, 0, 3, 1)\n        mainLayout.addWidget(self.gimbalRXPanel, 1, 1, 3, 1)\n        mainLayout.addWidget(self.fpgaAndSiversSettingsPanel, 1, 2, 3, 2)\n        mainLayout.addWidget(self.papPlotPanel, 4, 0, 7, 2)\n        mainLayout.addWidget(self.gps_vis_panel, 4, 2, 7, 2)\n        mainLayout.addWidget(self.planningMeasurementsPanel, 11, 0, 2, 2)\n        #mainLayout.addWidget(self.log_widget, 11, 2, 2, 2)\n        #self.write_to_log_terminal('Welcome to A2G Measurements Center!')\n\n        self.dummyWidget.setLayout(mainLayout)\n\n    def showSetupMenu(self):\n        \"\"\"\n        Creates an instance of the SetupWindow class (a Setup dialog), and create attributes for this class with the values the user input in the Setup dialog.\n        \"\"\"\n        setupWin = SetupWindow()\n        result = setupWin.exec_()\n\n        # Save the gps attitude offset for both nodes\n        self.gnd_gps_att_offset = setupWin.gnd_gps_att_offset_textEdit\n\n        self.droneGimbalChoice = setupWin.droneGimbalChoiceTDMenu.currentText()\n\n        if setupWin.fm_droneGimbal_TDMenu.currentText() == \"Only elevation\":\n            self.fm_drone_gimbal = {'FMODE': 0x01}\n        elif setupWin.fm_droneGimbal_TDMenu.currentText() == \"Only azimuth\":\n            self.fm_drone_gimbal = {'FMODE': 0x02}\n        elif setupWin.fm_droneGimbal_TDMenu.currentText() == \"Elevation and azimuth\":\n            self.fm_drone_gimbal = {'FMODE': 0x00}\n\n        if setupWin.fm_gndGimbal_TDMenu.currentText() == \"Only elevation\":\n            self.fm_gnd_gimbal = {'FMODE': 0x01}\n        elif setupWin.fm_gndGimbal_TDMenu.currentText() == \"Only azimuth\":\n            self.fm_gnd_gimbal = {'FMODE': 0x02}\n        elif setupWin.fm_gndGimbal_TDMenu.currentText() == \"Elevation and azimuth\":\n            self.fm_gnd_gimbal = {'FMODE': 0x00}\n\n        if setupWin.gnd_mobility_TDMenu.currentText() == \"Static\":\n            self.gnd_mobility = \"Static\"\n            try:\n                self.static_gnd_coords = [float(setupWin.gnd_lat_textEdit.text()), \n                                          float(setupWin.gnd_lon_textEdit.text()),\n                                          float(setupWin.gnd_alt_textEdit.text())] # lat, lon, altitude above sea level\n            except Exception as e:\n                print(\"[DEBUG]: Wrong input ground coords OR no input ground coords\")\n                print(\"[DEBUG]: Enter again the ground coordinates correctly\")\n                return\n        else: \n            self.gnd_mobility = \"Moving\"\n        if setupWin.drone_mobility_TDMenu.currentText() == \"Static\":\n            self.drone_mobility = \"Static\"\n            try:\n                self.static_drone_coords = [float(setupWin.drone_lat_textEdit.text()), \n                                            float(setupWin.drone_lon_textEdit.text()),\n                                            float(setupWin.drone_alt_textEdit.text())] # lat, lon\n            except Exception as e:\n                print(\"[DEBUG]: Wrong input drone coords OR no input drone coords\")\n                print(\"[DEBUG]: Enter again the drone coordinates correctly\")\n                return\n        else:\n            self.drone_mobility = \"Moving\"\n\n        # Remove a previous layout to set it again\n        if self.dummyWidget.layout() is not None:\n            del self.dummyWidget\n            self.setCentralWidget(None)\n            self.dummyWidget = QWidget()\n            self.setCentralWidget(self.dummyWidget)\n            self.init_constants()\n        self.showCentralWidget()\n\n        self.setupDevicesAndMoreAction.setDisabled(True)\n\n    def showPlanningMeasurementsMenu(self):\n        plannMeasWin = PlanningMeasurementsWindow()\n        result = plannMeasWin.exec_()\n\n        coordinates_ground = plannMeasWin.ground_fixed_coordinates_textEditor.document().toPlainText()\n        coordinates_drone = plannMeasWin.drone_fixed_coordinates_textEditor.document().toPlainText()\n\n        coordinates_ground = coordinates_ground.split(\"\\n\")\n        coordinates_drone = coordinates_drone.split(\"\\n\")\n\n        coordinates_ground = [i.split(\",\") for i in coordinates_ground]\n        coordinates_drone = [i.split(\",\") for i in coordinates_drone]\n\n        plannMeasWin.m.save(\"index.html\")\n        #plannMeasWin.m.save(\"map.html\")\n\n    def createMenu(self):\n        \"\"\"\n        Creates the menu bar and associates the callback functions for when the user clicks on each of the menu items.          \n        \"\"\"\n\n        # Place the menus and actions here\n        menuBar = QMenuBar()\n        self.setMenuBar(menuBar)\n        setupMenu = menuBar.addMenu(\"&amp;Setup\")\n        threadsMenu = menuBar.addMenu(\"&amp;Threads\")\n\n        self.setupDevicesAndMoreAction = QAction(\"&amp;Setup devices and more\", self)\n        setupMenu.addAction(self.setupDevicesAndMoreAction)        \n        self.setupDevicesAndMoreAction.triggered.connect(self.showSetupMenu)\n\n        self.planningMeasurementsAction = QAction(\"&amp;Plan measurements\", self)\n        setupMenu.addAction(self.planningMeasurementsAction)        \n        self.planningMeasurementsAction.triggered.connect(self.showPlanningMeasurementsMenu)\n        self.planningMeasurementsAction.setDisabled(True)\n\n        self.start_gnd_gimbal_fm_action = QAction(\"Start GND gimbal following its pair\", self)\n        threadsMenu.addAction(self.start_gnd_gimbal_fm_action)\n        self.start_gnd_gimbal_fm_action.triggered.connect(self.start_thread_gnd_gimbal_fm)\n        self.start_gnd_gimbal_fm_action.setDisabled(True)\n\n        self.stop_gnd_gimbal_fm_action = QAction(\"Stop GND gimbal following its pair\", self)\n        threadsMenu.addAction(self.stop_gnd_gimbal_fm_action)\n        self.stop_gnd_gimbal_fm_action.triggered.connect(self.stop_thread_gnd_gimbal_fm)\n        self.stop_gnd_gimbal_fm_action.setDisabled(True)\n\n        self.start_drone_gimbal_fm_action = QAction(\"Start DRONE gimbal following its pair\", self)\n        threadsMenu.addAction(self.start_drone_gimbal_fm_action)\n        self.start_drone_gimbal_fm_action.triggered.connect(self.start_thread_drone_gimbal_fm)\n        self.start_drone_gimbal_fm_action.setDisabled(True)\n\n        self.stop_drone_gimbal_fm_action = QAction(\"Stop DRONE gimbal following its pair\", self)\n        threadsMenu.addAction(self.stop_drone_gimbal_fm_action)\n        self.stop_drone_gimbal_fm_action.triggered.connect(self.stop_thread_drone_gimbal_fm)\n        self.stop_drone_gimbal_fm_action.setDisabled(True)\n\n        self.start_gps_visualization_action = QAction(\"Start GPS visualization\", self)\n        threadsMenu.addAction(self.start_gps_visualization_action)\n        self.start_gps_visualization_action.triggered.connect(self.start_thread_gps_visualization)\n        self.start_gps_visualization_action.setDisabled(False)\n\n        self.stop_gps_visualization_action = QAction(\"Stop GPS visualization\", self)\n        threadsMenu.addAction(self.stop_gps_visualization_action)\n        self.stop_gps_visualization_action.triggered.connect(self.stop_thread_gps_visualization)\n        self.stop_gps_visualization_action.setDisabled(True)\n\n    def start_thread_gnd_gimbal_fm(self):\n        \"\"\"\n        Creates and starts a timer thread (periodical callback) to send periodically the ``FOLLOWGIMBAL`` command to the drone node, for (this) ground node gimbal to follow the drone node location. \n        \"\"\"\n\n        if hasattr(self, 'myhelpera2g'):\n            self.update_time_gimbal_follow = 1\n            self.stop_event_gimbal_follow_thread = threading.Event()\n            self.periodical_gimbal_follow_thread = TimerThread(self.stop_event_gimbal_follow_thread, self.update_time_gimbal_follow)\n\n            if self.drone_mobility == \"Moving\":\n                self.periodical_gimbal_follow_thread.update.connect(lambda: self.myhelpera2g.socket_send_cmd(type_cmd='FOLLOWGIMBAL', data=self.fm_gnd_gimbal))\n            elif self.drone_mobility == \"Static\":\n                x,y,z = geodetic2geocentric(self.static_drone_coords[0], self.static_drone_coords[1], self.static_drone_coords[2])\n                data = {'X': x, 'Y': y, 'Z': z, 'FMODE': self.fm_gnd_gimbal['FMODE']}\n                self.periodical_gimbal_follow_thread.update.connect(lambda: self.myhelpera2g.process_answer_get_gps(data=data))\n            self.periodical_gimbal_follow_thread.start()\n\n        self.start_gnd_gimbal_fm_action.setEnabled(False)\n        self.stop_gnd_gimbal_fm_action.setEnabled(True)\n\n    def stop_thread_gnd_gimbal_fm(self):\n        \"\"\"\n        Stops the timer thread to send periodic ``FOLLOWGIMBAL`` commands to the drone node.\n        \"\"\"\n\n        if hasattr(self, 'periodical_gimbal_follow_thread'):\n            if self.periodical_gimbal_follow_thread.isRunning():\n                self.stop_event_gimbal_follow_thread.set()\n\n        self.start_gnd_gimbal_fm_action.setEnabled(True)\n        self.stop_gnd_gimbal_fm_action.setEnabled(False)\n\n    def start_thread_drone_gimbal_fm(self):\n        \"\"\"\n        Sets the ``drone_fm_flag`` flag in drone's HelperA2GMeasurements class instance, so that the drone periodically send a ``FOLLOWGIMBAL`` command to the ground node, for it (drone) node's gimbal to follow the location of the ground node.\n\n        The periodical ``FOLLOWGIMBAL`` command is sent from the drone node main script (``drone_main.py``).\n        \"\"\"\n\n        if hasattr(self, 'myhelpera2g'):\n            if self.gnd_mobility == \"Moving\":\n                data = {'X': 0, 'Y': 0, 'Z': 0, 'FMODE': self.fm_drone_gimbal['FMODE'], 'MOBILITY': 0x00}\n            elif self.gnd_mobility == \"Static\":\n                x,y,z = geodetic2geocentric(self.static_gnd_coords[0], self.static_gnd_coords[1], self.static_gnd_coords[2])\n                data = {'X': x, 'Y': y, 'Z': z, 'FMODE': self.fm_drone_gimbal['FMODE'], 'MOBILITY': 0x01}\n            self.myhelpera2g.socket_send_cmd(type_cmd='SETREMOTEFMFLAG', data=data)\n\n        self.start_drone_gimbal_fm_action.setEnabled(False)\n        self.stop_drone_gimbal_fm_action.setEnabled(True)\n\n    def stop_thread_drone_gimbal_fm(self):\n        \"\"\"\n        Unsets ``drone_fm_flag`` in drone's HelperA2GMeasurements class instance, so that the drone's gimbal stops following ground node location.\n        \"\"\"\n        if hasattr(self, 'myhelpera2g'):\n            self.myhelpera2g.socket_send_cmd(type_cmd='SETREMOTESTOPFM')\n\n        self.start_drone_gimbal_fm_action.setEnabled(True)\n        self.stop_drone_gimbal_fm_action.setEnabled(False)\n\n    def start_thread_gps_visualization(self):\n        \"\"\"\n        Creates and starts a timer thread (repeating callback) to display in the GPS panel updated gps coordinates of drone's location.\n\n        NOTE: *the callback ``periodical_gps_display_callback`` works as expected with synthetic gps coordinates. However, this function has not been tested with the actual gps and thus, minor bugs might appear*\n        \"\"\"\n        #if hasattr(self, 'myhelpera2g'):   \n        self.update_vis_time_gps = 1\n\n        self.periodical_gps_display_thread = QTimer(self)\n        self.periodical_gps_display_thread.timeout.connect(self.periodical_gps_display_callback)\n        self.periodical_gps_display_thread.start(1000*self.update_vis_time_gps)  \n\n        self.start_gps_visualization_action.setEnabled(False)\n        self.stop_gps_visualization_action.setEnabled(True)\n\n    def stop_thread_gps_visualization(self):\n        \"\"\"\n        Stops the timer thread responsible for display gps coordinates in the GPS panel.\n        \"\"\"\n        if self.periodical_gps_display_thread.isActive():\n            self.periodical_gps_display_thread.stop()\n\n        self.start_gps_visualization_action.setEnabled(True)\n        self.stop_gps_visualization_action.setEnabled(False)\n\n    def check_if_ssh_2_drone_reached(self, drone_ip, username, password):\n        \"\"\"\n        Checks if it is possible to ping and establish an SSH connection betwwen the host computer of the ground node and the host computer of the drone node.\n\n        Error checking of the input parameters SHOULD BE DONE by the caller function.\n\n        Args:\n            drone_ip (str): drone's IP address for the WiFi interface.\n            username (str): SSH username\n            password (str): SSH password\n\n        Returns:\n            success_ping_network (bool): True if drone node is reachable.\n            success_air_node_ssh (bool): True if ssh connection can be established.\n            success_drone_fpga (bool): True if rfsoc on drone is detected.\n        \"\"\"\n\n        try:\n            success_ping_network = ping3.ping(drone_ip, timeout=10)\n        except Exception as e:\n            print(\"[DEBUG]: Error in ping \", e)\n            success_ping_network = False\n\n        #if success_ping_network is not None:\n        if success_ping_network:\n            success_ping_network = True\n            print(\"[DEBUG]: DRONE-AP-GND Network is reachable\")\n            if self.remote_drone_conn is None:\n                try:\n                    remote_drone_conn = paramiko.SSHClient()\n                    remote_drone_conn.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n                    remote_drone_conn.connect(drone_ip, username=username, password=password)\n                    print(\"[DEBUG]: SSH connection to DRONE is successful.\")            \n                except paramiko.AuthenticationException:\n                    print(\"SSH Authentication failed. Please check your credentials.\")\n                    success_air_node_ssh = False\n                    self.remote_drone_conn = None\n                    success_drone_fpga = None\n                    return success_ping_network, success_air_node_ssh, success_drone_fpga\n                except paramiko.SSHException as ssh_exception:\n                    print(f\"Unable to establish SSH connection: {ssh_exception}\")\n                    success_air_node_ssh = False\n                    self.remote_drone_conn = None\n                    success_drone_fpga = None\n                    return success_ping_network, success_air_node_ssh, success_drone_fpga\n                except Exception as e:\n                    print(f\"An error occurred: {e}\")\n                    success_air_node_ssh = False\n                    self.remote_drone_conn = None\n                    success_drone_fpga = None\n                    return success_ping_network, success_air_node_ssh, success_drone_fpga\n\n                self.remote_drone_conn = remote_drone_conn\n\n            # Will execute either if 'try' statemente success or if self.remote_drone_conn is precisely None\n            success_air_node_ssh = True            \n            success_drone_fpga = self.check_if_drone_fpga_connected()\n        else:\n            print(\"[DEBUG]: DRONE-AP-GND Network is NOT reachable\")\n            success_ping_network = False\n            success_air_node_ssh = None\n            success_drone_fpga = None\n            self.remote_drone_conn = None\n\n        return success_ping_network, success_air_node_ssh, success_drone_fpga\n\n    def check_if_drone_fpga_connected(self, drone_fpga_static_ip_addr='10.1.1.40'):\n        \"\"\"\n        Checks if the rfsoc is detected on the drone. \n\n        Caller function SHOULD check first if there is an SSH connection.\n\n        Args:\n            drone_fpga_static_ip_addr (str, optional): drone's RFSoC IP address for the Ethernet interface. Defaults to '10.1.1.40'.\n\n        Returns:\n            success_drone_fpga (bool): True if the ping to the rfsoc IP address (Ethernet interface) is replied.\n        \"\"\"\n\n        # Execute the command and obtain the input, output, and error streams\n        stdin, stdout, stderr = self.remote_drone_conn.exec_command('ping ' + drone_fpga_static_ip_addr)\n\n        # Read the output from the command\n        output = stdout.read().decode('utf-8')\n        error = stderr.read().decode('utf-8')\n\n        expected_str_out = \"Reply from \" + drone_fpga_static_ip_addr\n        # Print the output and error, if any\n        if expected_str_out in output:\n            print(\"[DEBUG]: RFSoC detected at DRONE node\")\n            success_drone_fpga = True\n        else:\n            success_drone_fpga = False\n        if error:\n            print(f\"Command error:\\n{error}\")\n            response_drone_fpga = None\n\n        return success_drone_fpga\n\n    def check_if_gnd_fpga_connected(self, gnd_fpga_static_ip_addr='10.1.1.30'):\n        \"\"\"\n        Check if the rfsoc is detected on the ground node.\n\n        Args:\n            gnd_fpga_static_ip_addr (str, optional): ground's RFSoC IP address for the Ethernet interface. Defaults to '10.1.1.30'.\n\n        Returns:\n            success_ping_gnd_fpga (bool): True if ping is successful, False otherwise.\n        \"\"\"\n\n        try:\n            success_ping_gnd_fpga = ping3.ping(gnd_fpga_static_ip_addr, timeout=7)\n        except Exception as e:\n            print(\"[DEBUG]: Error in ping \", e)\n            print(\"[DEBUG]: RFSoC is NOT detected at GND node\")\n            success_ping_gnd_fpga = False\n            return\n\n        if success_ping_gnd_fpga is not None or success_ping_gnd_fpga:\n            print(\"[DEBUG]: RFSoC is detected at GND node\")\n            success_ping_gnd_fpga = True\n        else:\n            print(\"[DEBUG]: RFSoC is NOT detected at GND node\")\n            success_ping_gnd_fpga = False\n\n        return success_ping_gnd_fpga\n\n    def check_if_drone_gimbal_connected(self):\n        \"\"\"\n        Checks if a gimbal (Ronin RS2 or Gremsy H16) is connected to the host computer of the drone node.\n\n        Returns:\n            success_drone_gimbal (bool): True if the gimbal is detected, False if not. None if an error appeared.\n        \"\"\"\n        if self.remote_drone_conn is None:\n            success_drone_gimbal = None\n            print('[DEBUG]: No SSH connection to drone detected. The drone gps connection check can not be done.')\n        else:\n            try:\n                stdin, stdout, stderr = self.remote_drone_conn.exec_command('PowerShell')\n                stdin.channel.send(\"Get-PnpDevice -PresentOnly | Where-Object { $_.InstanceId -match '^USB' } | Format-List\\n\")\n                stdin.channel.shutdown_write()\n                usb_list_str = stdout.read().decode('utf-8')\n\n                # Exit the PowerShell\n                stdin, stdout, stderr = self.remote_drone_conn.exec_command('exit')\n            except Exception as e:\n                print(\"[DEBUG]: Error encountered executing the Gimbal check commands on drone\")\n                print(\"[DEBUG]: \", e)\n                success_drone_gimbal = None\n            else:\n                if self.droneGimbalChoice == \"DJI Ronin RS2\":\n                    if 'PCAN-USB' in usb_list_str:\n                        success_drone_gimbal = True\n                        print(\"[DEBUG]: Ronin RS2 is detected at DRONE\")\n                    else:\n                        success_drone_gimbal = False\n                        print(\"[DEBUG]: Ronin RS2 is NOT detected at DRONE\")\n                elif self.droneGimbalChoice == \"Gremsy H16\":\n                    if 'USB Serial Converter' in usb_list_str:\n                        success_drone_gimbal = True\n                        print(\"[DEBUG]: Gremsy Gimbal is detected at DRONE\")\n                    else:\n                        success_drone_gimbal = False\n                        print(\"[DEBUG]: Gremsy Gimbal is NOT detected at DRONE\")\n\n        return success_drone_gimbal\n\n    def check_if_gnd_gimbal_connected(self):\n        \"\"\"\n        Checks if a Ronin RS2 gimbal is connected to the host computer of the ground node.\n\n        Returns:\n            success_gnd_gimbal (bool): True if a PCAN device is detected, False otherwise.\n        \"\"\"\n\n        try:\n            # Check if gimbal is connected by looking if connection is established\n            bus = can.interface.Bus(interface=\"pcan\", channel=\"PCAN_USBBUS1\", bitrate=1000000)\n        except Exception as e:\n            success_gnd_gimbal = False\n        else:\n            bus.shutdown()\n            del bus\n            success_gnd_gimbal = True\n\n        return success_gnd_gimbal\n\n    def check_if_server_running_drone_fpga(self):\n        \"\"\"\n        Checks if the server.py daemon is running on drone's RFSoC (the PS of the RFSoC). If it is not running, this function starts it.\n\n        ASSUMES DRONE RFSOC IP STATIC ADDR FOR ETH INTERFACE IS 10.1.1.40 (THIS IS THE DEFAULT SETUP)\n\n        Returns:\n            success_server_drone_fpga (bool): True if the server.py daemon is running. False if not. None if the daemon could not be started.\n        \"\"\"\n\n        if self.remote_drone_conn is None:\n            print('[DEBUG]: No SSH connection to drone detected. The server-running-on-drone check can not be done.')\n            success_server_drone_fpga = False\n        else:\n            try:\n                shell = self.remote_drone_conn.invoke_shell()\n                while(shell.recv_ready() == False):\n                    time.sleep(0.1)\n                out_now = shell.recv(65535).decode('utf-8')\n\n                shell.send(\"ssh xilinx@10.1.1.40\\r\\n\")\n                while(shell.recv_ready() == False):\n                    time.sleep(0.1)\n                out_now = shell.recv(65535).decode('utf-8')\n\n                aux = \"Permission denied, please try again\"\n                cnt=1\n                while((\"Permission denied, please try again\" in aux) and cnt&lt;10):\n                    shell.send(\"xilinx\\r\\n\")\n                    while(shell.recv_ready() == False):\n                        time.sleep(0.1)\n                    out_now = shell.recv(65535).decode('utf-8')\n                    aux = out_now\n                    cnt = cnt +1\n                if cnt == 10:\n                    print(\"[DEBUG]: Unsuccesfull check of drone fpga server. Please CHECK IT MANUALLY on the drone\")\n                    success_server_drone_fpga = False\n                    return success_server_drone_fpga\n\n                aux = \"xilinx: command not found\"\n                cnt=1\n                while((\"xilinx: command not found\" in aux) and cnt&lt;10):\n                    shell.send(\"ps aux | grep mmwsdr\\r\\n\")\n                    while(shell.recv_ready() == False):\n                        time.sleep(0.1)\n                    out_now = shell.recv(65535).decode('utf-8')\n                    aux=out_now\n                    cnt=cnt+1\n                if cnt == 10:\n                    print(\"[DEBUG]: Unsuccesfull check of drone fpga server. Please CHECK IT MANUALLY on the drone\")\n                    success_server_drone_fpga = False\n                    return success_server_drone_fpga\n\n                #shell.close()\n            except Exception as e:\n                print(f\"[DEBUG]:Error when trying to check if server is running on drone fpga: {e}\")\n                success_server_drone_fpga = None\n                return success_server_drone_fpga\n\n            if 'server.py'in out_now and 'run.sh' in out_now:\n                print(\"[DEBUG]: Server script is running on DRONE fpga\")\n            else:\n                print(\"[DEBUG]: Server script is not running on DRONE fpga\")\n                print(\"[DEBUG]: Starting server daemon on DRONE fpga\")\n                try:\n                    # The shell is not closed                    \n                    shell.send(\"cd jupyter_notebook/mmwsdr\\r\\n\")\n                    while(shell.recv_ready() == False):\n                        time.sleep(0.1)\n                    out_now = shell.recv(65535).decode('utf-8')\n\n                    shell.send(\"sudo ./run.sh\\r\\n\")\n                    while(shell.recv_ready() == False):\n                        time.sleep(0.1)\n                    out_now = shell.recv(65535).decode('utf-8')\n\n                    shell.send(\"xilinx\\r\\n\")\n                    while(shell.recv_ready() == False):\n                        time.sleep(0.1)\n                    out_now = shell.recv(65535).decode('utf-8')\n\n                    shell.close()\n\n                    print(\"[DEBUG]: Server daemon on drone fpga has started\")\n                    success_server_drone_fpga = True\n                except Exception as e:\n                    print(f\"This error occurred when trying to init daemon server on drone fpga: {e}\")\n                    success_server_drone_fpga = None\n                    return success_server_drone_fpga\n        return success_server_drone_fpga\n\n    def check_if_server_running_gnd_fpga(self):\n        \"\"\"\n        Checks if the server.py daemon is running on ground's RFSoC (the PS of the RFSoC). If it is not running, this function starts it.\n\n        ASSUMES GROUND RFSOC IP STATIC ADDR FOR ETH INTERFACE IS 10.1.1.30 (THIS IS THE DEFAULT SETUP)\n\n        Returns:\n            success_server_gnd_fpga (bool): True if the server.py daemon is running on ground's RFSoC. False otherwise.\n        \"\"\"\n\n        try:\n            conn_gnd_fpga = paramiko.SSHClient()\n            conn_gnd_fpga.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n            conn_gnd_fpga.connect('10.1.1.30', username='xilinx', password='xilinx')\n        except Exception as e:\n            print(f\"This error occurred when trying to check if server is running on GND fpga: {e}\")\n            success_server_gnd_fpga = False\n            return success_server_gnd_fpga\n        try:\n            stdin, stdout, stderr = conn_gnd_fpga.exec_command('ps aux | grep mmwsdr')\n            output = stdout.read().decode()\n\n            if stderr.read().decode() == '' and 'server.py' in output and 'run.sh' in output:\n                print(\"[DEBUG]: Server script is running on GND fpga\")\n            else:\n                print(\"[DEBUG]: Server script is not running on GND fpga\")\n                conn_gnd_fpga.exec_command('cd jupyter_notebooks/mmwsdr')\n                stdin, stdout, stderr = conn_gnd_fpga.exec_command('sudo ./run.sh')\n                stdin.channel.send(\"xilinx\\n\")\n                stdin.channel.shutdown_write()\n                print(\"[DEBUG]: GND node has started the Server Daemon in its FPGA\")\n        except Exception as e:\n            print(\"[DEBUG]: Could not check if Server script is running in this node FPGA\")\n            success_server_gnd_fpga = False\n            return success_server_gnd_fpga\n\n        success_server_gnd_fpga = True\n\n        # Close this connection\n        conn_gnd_fpga.close()\n\n        return success_server_gnd_fpga\n\n    def check_if_gnd_gps_connected(self):\n        \"\"\"\n        Checks if a Septentrio gps is connected to the host computer of the ground node.\n\n        Returns:\n            success_gnd_gps (bool): True if a gps is detected, False otherwise.\n        \"\"\"\n\n        tmp = []\n        for (_, desc, _) in sorted(comports()):\n            tmp.append(\"Septentrio\" in desc)\n        if any(tmp):\n            success_gnd_gps = True\n            print(\"[DEBUG]: GPS is detected at GND\")\n        else:\n            success_gnd_gps = False\n            print(\"[DEBUG]: GPS is NOT detected at GND\")\n\n        return success_gnd_gps        \n\n    def check_if_drone_gps_connected(self):\n        \"\"\"\n        Checks if a Septentrio gps is connected to the host computer of the drone node.\n\n        Requires that there is a SSH connection already established.\n\n        Returns:\n            success_drone_gps (bool): True if connected, False if not, None if no SSH connection.\n        \"\"\"\n\n        # Double check\n        if self.remote_drone_conn is None:\n            success_drone_gps = None\n            print('[DEBUG]: No SSH connection to drone detected. The drone gps connection check can not be done.')\n        else:\n            try:\n                stdin, stdout, stderr = self.remote_drone_conn.exec_command('PowerShell')\n                stdin.channel.send(\"Get-PnpDevice -PresentOnly | Where-Object { $_.InstanceId -match '^USB' } | Format-List\\n\")\n                stdin.channel.shutdown_write()\n                usb_list_str = stdout.read().decode('utf-8')\n\n                # Exit the PowerShell\n                stdin, stdout, stderr = self.remote_drone_conn.exec_command('exit')\n            except Exception as e:\n                print(\"[DEBUG]: Error encountered executing the GPS check commands on drone\")\n                print(\"[DEBUG]: \", e)\n                success_drone_gps = None\n            else:\n                if 'Septentrio' in usb_list_str:\n                    success_drone_gps = True\n                    print(\"[DEBUG]: GPS is detected at DRONE\")\n                else:\n                    success_drone_gps = False\n                    print(\"[DEBUG]: GPS is NOT detected at DRONE\")                \n\n        return success_drone_gps\n\n    def get_gnd_ip_node_address(self):\n        \"\"\"\n        Gets the IP address ground's node WiFi interface.\n\n        Caller function IS RESPONSIBLE for checking if there is a WiFi operating. \n        \"\"\"\n\n        if platform.system() == \"Windows\":\n            ifconfig_info = subprocess.Popen([\"ipconfig\"], stdout=subprocess.PIPE)\n        else:\n            ifconfig_info = subprocess.Popen([\"ifconfig\"], stdout=subprocess.PIPE)\n        out, err = ifconfig_info.communicate()\n        stdout_str = out.decode()\n\n        pattern = r'inet\\s+\\d+.\\d+.\\d+.\\d+'        \n\n        try:\n            # This is how the IP address should appear, as the GND-DRONE connection is wireless through an AP\n            stdout_str_split = stdout_str.split('wlan0: ')\n\n            gnd_ip_addr = re.findall(pattern, stdout_str_split[-1])\n            gnd_ip_addr = gnd_ip_addr[0].split('inet ')\n            gnd_ip_addr = gnd_ip_addr[-1]\n        except Exception as e:\n            print(\"[DEBUG]: Error detecting the GND IP address \", e)\n        else:\n            self.GND_ADDRESS = gnd_ip_addr\n\n    def check_status_all_devices(self):\n        \"\"\"\n        Callback for when user presses the \"Check\" button. Gets the connection status of all devices.\n        \"\"\"\n\n        pattern_ip_addresses = r'[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}'\n        self.DRONE_ADDRESS = self.air_ip_addr_value_text_edit.text()\n        is_ip_addr = bool(re.match(pattern_ip_addresses, self.DRONE_ADDRESS))\n\n        # Input error checking\n        if self.DRONE_ADDRESS == '' or not is_ip_addr:\n            print('[DEBUG]: No DRONE or incorrect IP address supplied')\n            self.network_exists_label_modifiable.setText(str(None))\n            self.ssh_conn_gnd_2_drone_label_modifiable.setText(str(None))\n            self.drone_rfsoc_conn_label_modifiable.setText(str(None))\n        else:\n            SUCCESS_PING_DRONE, SUCCESS_SSH, SUCCESS_DRONE_FPGA = self.check_if_ssh_2_drone_reached(self.DRONE_ADDRESS, \"manifold-uav-vtt\", \"mfold2208\")\n            SUCCESS_DRONE_GPS = self.check_if_drone_gps_connected()\n            SUCCES_DRONE_GIMBAL = self.check_if_drone_gimbal_connected()\n            self.network_exists_label_modifiable.setText(str(SUCCESS_PING_DRONE))\n            self.ssh_conn_gnd_2_drone_label_modifiable.setText(str(SUCCESS_SSH))\n            self.drone_rfsoc_conn_label_modifiable.setText(str(SUCCESS_DRONE_FPGA))\n            self.drone_gps_conn_label_modifiable.setText(str(SUCCESS_DRONE_GPS))\n            self.drone_gimbal_conn_label_modifiable.setText(str(SUCCES_DRONE_GIMBAL))\n            self.SUCCESS_PING_DRONE = SUCCESS_PING_DRONE\n            self.SUCCESS_SSH = SUCCESS_SSH\n            self.SUCCESS_DRONE_FPGA = SUCCESS_DRONE_FPGA\n            self.SUCCESS_DRONE_GPS = SUCCESS_DRONE_GPS\n            self.SUCCES_DRONE_GIMBAL = SUCCES_DRONE_GIMBAL\n\n        SUCCESS_GND_FPGA = self.check_if_gnd_fpga_connected()\n        SUCCESS_GND_GIMBAL = self.check_if_gnd_gimbal_connected()        \n        SUCCESS_GND_GPS = self.check_if_gnd_gps_connected()\n        #SUCCESS_DRONE_SERVER_FPGA = self.check_if_server_running_drone_fpga()\n        #SUCCESS_GND_SERVER_FPGA = self.check_if_server_running_gnd_fpga()\n        SUCCESS_DRONE_SERVER_FPGA = None\n        SUCCESS_GND_SERVER_FPGA = None\n\n        self.get_gnd_ip_node_address()\n        self.gnd_gimbal_conn_label_modifiable.setText(str(SUCCESS_GND_GIMBAL))\n        self.gnd_gps_conn_label_modifiable.setText(str(SUCCESS_GND_GPS))\n        self.gnd_rfsoc_conn_label_modifiable.setText(str(SUCCESS_GND_FPGA))\n        self.server_drone_fpga_label_modifiable.setText(str(SUCCESS_DRONE_SERVER_FPGA))\n        self.server_gnd_fpga_label_modifiable.setText(str(SUCCESS_GND_SERVER_FPGA))\n\n        if hasattr(self, 'GND_ADDRESS'):\n            self.gnd_ip_addr_value_label.setText(self.GND_ADDRESS)\n        else:\n            self.GND_ADDRESS =  ''\n\n        self.SUCCESS_GND_FPGA = SUCCESS_GND_FPGA\n        self.SUCCESS_GND_GIMBAL = SUCCESS_GND_GIMBAL\n        self.SUCCESS_GND_GPS = SUCCESS_GND_GPS\n\n        if self.SUCCESS_SSH and self.SUCCESS_PING_DRONE:\n            self.connect_to_drone.setEnabled(True)\n\n    def create_class_instances(self, IsGPS=False, IsGimbal=False, IsRFSoC=False, GPS_Stream_Interval='sec1'):\n        \"\"\"\n        Creates ``HelperA2GMeasurements`` class instance for this (ground) node and starts the WiFi communication thread.\n\n        Args:\n            IsGPS (bool, optional): True if there is a Septentrio GPS connected to this (ground) host computer. Defaults to False.\n            IsGimbal (bool, optional): True if there is a Ronin RS2 gimbal connected to this (ground) host computer. Defaults to False.\n            IsRFSoC (bool, optional): True if there is an RFSoC connected to this (ground) host computer. Defaults to False.\n            GPS_Stream_Interval (str, optional): controls the regularity of getting GPS coordinates in this (ground) node. Available options are provided in ``GpsSignaling.start_gps_data_retrieval``. Defaults to 'sec1'.\n        \"\"\"\n\n        # As this app is executed at the ground device...\n        self.myhelpera2g = HelperA2GMeasurements('GROUND', self.GND_ADDRESS, IsRFSoC=IsRFSoC, IsGimbal=IsGimbal, IsGPS=IsGPS, rfsoc_static_ip_address='10.1.1.30', GPS_Stream_Interval=GPS_Stream_Interval, DBG_LVL_0=False, DBG_LVL_1=False, heading_offset=self.gnd_gps_att_offset)\n        self.myhelpera2g.HelperStartA2GCom()\n\n        print(\"[DEBUG]: Starting GUI threads\")\n        time.sleep(1)\n\n        #self.start_GUI_threads()\n\n    def start_GUI_threads(self):\n        \"\"\"\n        Start GUI related threads. This threads are related only to the display of information\n        on the GUI.\n\n        \"\"\"\n\n        print(\"[DEBUG]: Starting GUI threads...\")\n        # Although thus function should be called when a HelperA2GMeasurements class instance has been created, better to do a double check\n        if hasattr(self, 'myhelpera2g'):\n            print(\"[DEBUG]: Detected helper class at creating GUI threads\")\n            if self.gps_display_flag:      \n                print(\"[DEBUG]: GPS dispplay flag activated\")      \n                self.update_vis_time_gps = 1\n                #self.periodical_gps_display_thread = RepeatTimer(self.update_vis_time_gps, self.periodical_gps_display_callback)\n                self.stop_event_gps_display = threading.Event()\n                self.periodical_gps_display_thread = TimerThread(self.stop_event_gps_display, self.update_vis_time_gps)\n                self.periodical_gps_display_thread.update.connect(self.periodical_gps_display_callback)\n                self.periodical_gps_display_thread.start()\n\n            if self.rs2_fm_flag:\n                print(\"[DEBUG]: Gimbal RS2 FM Flag activated\")\n                self.update_time_gimbal_follow = 1\n                self.stop_event_gimbal_follow_thread = threading.Event()\n                self.periodical_gimbal_follow_thread = TimerThread(self.stop_event_gimbal_follow_thread, self.update_time_gimbal_follow)\n                self.periodical_gimbal_follow_thread.update.connect(lambda: self.myhelpera2g.socket_send_cmd(type_cmd='FOLLOWGIMBAL', data=self.fm_gnd_gimbal))\n                self.periodical_gimbal_follow_thread.start()\n\n    def periodical_pap_display_callback(self):\n        \"\"\"\n        Callback for display the PAP of the measured CIR in the PAP panel of the GUI.\n        \"\"\"\n\n        if hasattr(self, 'myhelpera2g'):\n            if hasattr(self.myhelpera2g, 'PAP_TO_PLOT'):\n                if len(self.myhelpera2g.PAP_TO_PLOT) &gt; 0:\n                    self.plot_widget.clear()\n                    img = pg.ImageItem()\n                    img.setImage(self.myhelpera2g.PAP_TO_PLOT)\n                    self.plot_widget.addItem(img)\n                    print(f\"[DEBUG]: Executed plot command at {self.myhelpera2g.ID}. PAP shape: {self.myhelpera2g.PAP_TO_PLOT.shape}\")\n\n    def periodical_gps_display_callback(self):\n        \"\"\"\n        Displays (periodically) GPS position of the drone node on the GPS panel. \n\n        The period is controlled by the property \"update_vis_time_gps\" of this class.\n\n        Uses the ``show_air_moving`` function of the class ``GpsOnMap``, meaning that such method has to implement the functionality to display gps coordinates on a given input (PyQt5 panel).\n        \"\"\"\n\n        # Display coords\n        if hasattr(self, 'myhelpera2g'):\n            '''\n            coords, head_info = self.myhelpera2g.mySeptentrioGPS.get_last_sbf_buffer_info(what='Both')\n\n            if coords['X'] == self.ERR_GPS_CODE_BUFF_NULL or self.ERR_GPS_CODE_SMALL_BUFF_SZ:\n                print(\"[DEBUG]: Error in received GPS coordinates from DRONE\")\n                print(\"[DEBUG]: Due to this error, DRONE location will not be seen\")\n            else:\n                lat_gnd_node, lon_gnd_node, height_node = geocentric2geodetic(coords['X'], coords['Y'], coords['Z'])\n            '''\n            if hasattr(self.myhelpera2g, 'last_drone_coords_requested'):\n                gps_drone_coords_json = {\"lat\": self.last_drone_coords_requested['LAT'], \"lon\": self.last_drone_coords_requested['LON']}\n                response = requests.put(self.url_put_map, json=gps_drone_coords_json)\n        else:# DEBUG: test showing something updating each self.update_vis_time\n            self.debug_cnt_1 = self.debug_cnt_1 + 1\n            alfa = np.random.rand()\n            point1 = [60.187372669712566, 24.96109446381862]\n            point2 = [60.18490587854025, 24.948227873431904]\n            point = np.array(point1)*alfa + (1-alfa)*np.array(point2)\n            point = point.tolist()\n            gps_drone_coords_json = {\"lat\": point[0], \"lon\": point[1]}\n            response = requests.put(self.url_put_map, json=gps_drone_coords_json)    \n            print(\"Periodical GPS\", self.debug_cnt_1)\n\n    def write_to_log_terminal(self, newLine):\n        '''\n        New line to be written into the log terminal. The number of new lines it can handle is controlled\n        by the parameter number_lines_log_terminal.\n\n        TO BE CHECKED: THE NUMBER OF MAX CHARACTERS FOR A LINE HAS TO BE CHECKED IN THE CODE\n\n        '''\n\n        log_txt = self.log_terminal_txt.splitlines()\n\n        if len(log_txt) &lt; self.number_lines_log_terminal:\n            self.log_terminal_txt = self.log_terminal_txt + newLine + \"\\n\"\n        else:\n            for i in range(len(log_txt)-1, 0, -1):\n                log_txt[i] = log_txt[i-1] + \"\\n\"\n            log_txt[0] = newLine + \"\\n\"\n\n            log_txt = ''.join(log_txt) \n            self.log_terminal_txt = log_txt\n\n        self.log_widget.setPlainText(self.log_terminal_txt)\n\n    def create_log_terminal(self):\n        \"\"\"\n        Access the widget contents by using ``self.log_widget.setPlainText('')``\n        \"\"\"\n        self.log_widget = CustomTextEdit(self)\n\n        #self.log_widget = QTextEdit(self)\n        self.log_widget.setReadOnly(True) # make it read-only        \n\n        # Redirect output of myFunc to the QTextEdit widget\n        sys.stdout = self.log_widget\n\n    def create_check_connections_panel(self):\n        \"\"\"\n        Creates the \"Check connections\" panel with its widgets and layout.\n        \"\"\"\n        self.checkConnPanel = QGroupBox('Connections')\n\n        gnd_gimbal_conn_label = QLabel('Ground gimbal:')\n        gnd_gps_conn_label = QLabel('Ground GPS:')\n        gnd_rfsoc_conn_label = QLabel('Ground RFSoC:')\n        network_exists_label = QLabel('Able to PING drone?:')\n        ssh_conn_gnd_2_drone_label = QLabel('SSH to drone:')\n        drone_rfsoc_conn_label = QLabel('Drone RFSoC:')\n        drone_gps_conn_label = QLabel('Drone GPS:')\n        drone_gimbal_conn_label = QLabel('Drone Gimbal:')\n        server_gnd_fpga_label = QLabel('Ground FPGA server?:')\n        server_drone_fpga_label = QLabel('Drone FPGA server?:')\n\n        gnd_ip_addr_label = QLabel('Ground IP:')\n        air_ip_addr_label = QLabel('Drone IP:')\n        self.gnd_ip_addr_value_label = QLabel('')\n        self.air_ip_addr_value_text_edit = QLineEdit(self.STATIC_DRONE_IP_ADDRESS)\n\n        #self.GndGimbalFollowingCheckBox = QCheckBox(\"&amp;RS2 FM\")\n        #self.GndGimbalFollowingCheckBox.setChecked(False)\n        #self.GndGimbalFollowingCheckBox.toggled.connect(self.activate_rs2_fm_flag)\n        #self.rs2_fm_flag = False\n\n        #self.GpsDisplayCheckBox = QCheckBox(\"&amp;GPS Display\")\n        #self.GpsDisplayCheckBox.setChecked(False)\n        #self.GpsDisplayCheckBox.toggled.connect(self.activate_gps_display_flag)\n        #self.gps_display_flag = False\n\n        self.check_connections_push_button = QPushButton('Check')\n        self.connect_to_drone = QPushButton('Connect drone')\n        self.disconnect_from_drone = QPushButton('Disconnect drone')\n        self.check_connections_push_button.clicked.connect(self.check_status_all_devices)\n        self.disconnect_from_drone.setEnabled(False)\n        self.connect_to_drone.setEnabled(False)\n        self.connect_to_drone.clicked.connect(self.connect_drone_callback)\n        self.disconnect_from_drone.clicked.connect(self.disconnect_drone_callback)\n\n        self.gnd_gimbal_conn_label_modifiable = QLabel('--')\n        self.gnd_gps_conn_label_modifiable = QLabel('--')\n        self.gnd_rfsoc_conn_label_modifiable = QLabel('--')\n        self.network_exists_label_modifiable = QLabel('--')\n        self.ssh_conn_gnd_2_drone_label_modifiable = QLabel('--')\n        self.drone_rfsoc_conn_label_modifiable = QLabel('--')\n        self.drone_gps_conn_label_modifiable = QLabel('--')\n        self.drone_gimbal_conn_label_modifiable = QLabel('--')\n        self.server_gnd_fpga_label_modifiable = QLabel('--')\n        self.server_drone_fpga_label_modifiable = QLabel('--')\n\n        layout = QGridLayout()\n\n        layout.addWidget(gnd_ip_addr_label, 0, 0, 1, 1)\n        layout.addWidget(self.gnd_ip_addr_value_label, 0, 1, 1, 1)\n        layout.addWidget(gnd_gimbal_conn_label, 0, 2, 1, 1)\n        layout.addWidget(self.gnd_gimbal_conn_label_modifiable, 0, 3, 1, 1)\n        layout.addWidget(gnd_gps_conn_label, 0, 4, 1, 1)\n        layout.addWidget(self.gnd_gps_conn_label_modifiable, 0, 5, 1, 1)\n        layout.addWidget(gnd_rfsoc_conn_label, 0, 6, 1, 1)\n        layout.addWidget(self.gnd_rfsoc_conn_label_modifiable, 0, 7, 1, 1)\n        layout.addWidget(network_exists_label, 0, 8, 1, 1)\n        layout.addWidget(self.network_exists_label_modifiable, 0, 9, 1, 1)\n        layout.addWidget(ssh_conn_gnd_2_drone_label, 0, 10, 1, 1)\n        layout.addWidget(self.ssh_conn_gnd_2_drone_label_modifiable, 0, 11, 1, 1)\n        layout.addWidget(drone_rfsoc_conn_label, 0, 12, 1, 1)\n        layout.addWidget(self.drone_rfsoc_conn_label_modifiable, 0, 13, 1, 1)\n        layout.addWidget(drone_gps_conn_label, 0, 14, 1, 1)       \n        layout.addWidget(self.drone_gps_conn_label_modifiable, 0, 15, 1, 1)\n        layout.addWidget(air_ip_addr_label, 1, 0, 1, 1)\n        layout.addWidget(self.air_ip_addr_value_text_edit, 1, 1, 1, 2)\n        layout.addWidget(drone_gimbal_conn_label, 1, 3, 1, 1)\n        layout.addWidget(self.drone_gimbal_conn_label_modifiable, 1, 4, 1, 1) \n        layout.addWidget(server_gnd_fpga_label, 1, 5, 1, 1)\n        layout.addWidget(self.server_gnd_fpga_label_modifiable, 1, 6, 1, 1)\n        layout.addWidget(server_drone_fpga_label, 1, 7, 1, 1)\n        layout.addWidget(self.server_drone_fpga_label_modifiable, 1, 8, 1, 1)\n        layout.addWidget(self.check_connections_push_button, 1, 9, 1, 3)\n        layout.addWidget(self.connect_to_drone, 1, 12, 1, 2)\n        layout.addWidget(self.disconnect_from_drone, 1, 14, 1, 2)\n\n        self.checkConnPanel.setLayout(layout)\n\n    def activate_rs2_fm_flag(self):   \n        \"\"\"\n        Toggles the ``rs2_fm_flag``\n        \"\"\"     \n\n        if self.rs2_fm_flag:\n            self.rs2_fm_flag = False\n        else:\n            self.rs2_fm_flag = True\n\n    def activate_gps_display_flag(self):\n        \"\"\"\n        Toggles the ``gps_display_flag``\n        \"\"\"\n        if self.gps_display_flag:\n            self.gps_display_flag = False\n        else:\n            self.gps_display_flag = True\n\n    def connect_drone_callback(self):\n        \"\"\"\n        Callback for when the user presses the \"Connect\" button.\n\n        Calls the ``create_class_instance`` method to create the Helper class in this (ground) node, depending on the availability of ground and drone devices. \n        \"\"\"\n\n        if self.SUCCESS_GND_GIMBAL and self.SUCCESS_GND_FPGA and self.SUCCESS_GND_GPS:\n            self.create_class_instances(IsGimbal=True, IsGPS=True, IsRFSoC=True)\n            self.start_meas_togglePushButton.setEnabled(True)\n            if self.SUCCESS_DRONE_GPS: \n                self.start_gps_visualization_action.setEnabled(True)\n                self.stop_gps_visualization_action.setEnabled(False)\n\n                # Only activate gnd FM actions if GND GIMBAL and GND GPS and DRONE GPS\n                self.start_gnd_gimbal_fm_action.setEnabled(True)\n                self.stop_gnd_gimbal_fm_action.setEnabled(False)\n            print(\"[DEBUG]: Class created at GND with Gimbal, GPS and RFSoC\")               \n        if self.SUCCESS_GND_GIMBAL and self.SUCCESS_GND_FPGA and not self.SUCCESS_GND_GPS:\n            self.create_class_instances(IsGimbal=True, IsRFSoC=True)\n            print(\"[DEBUG]: Class created at GND with Gimbal and RFSoC\")\n            self.start_meas_togglePushButton.setEnabled(True)\n        if self.SUCCESS_GND_GIMBAL and not self.SUCCESS_GND_FPGA and not self.SUCCESS_GND_GPS:\n            self.create_class_instances(IsGimbal=True)\n            self.start_meas_togglePushButton.setEnabled(False)\n            print(\"[DEBUG]: Class created at GND with Gimbal\")\n        if self.SUCCESS_GND_GIMBAL and not self.SUCCESS_GND_FPGA and self.SUCCESS_GND_GPS:\n            self.create_class_instances(IsGimbal=True, IsGPS=True)\n            self.start_meas_togglePushButton.setEnabled(False)\n            print(\"[DEBUG]: Class created at GND with Gimbal and GPS\")\n            if self.SUCCESS_DRONE_GPS:\n                self.start_gnd_gimbal_fm_action.setEnabled(True)\n                self.stop_gnd_gimbal_fm_action.setEnabled(False)\n            if self.SUCCESS_DRONE_GPS:\n                self.start_gps_visualization_action.setEnabled(True)\n                self.stop_gps_visualization_action.setEnabled(False)\n        if not self.SUCCESS_GND_GIMBAL and self.SUCCESS_GND_FPGA and self.SUCCESS_GND_GPS:\n            self.create_class_instances(IsGPS=True, IsRFSoC=True)\n            self.start_meas_togglePushButton.setEnabled(True)\n            print(\"[DEBUG]: Class created at GND with GPS and RFSoC\")\n            if self.SUCCESS_DRONE_GPS:\n                self.start_gps_visualization_action.setEnabled(True)\n                self.stop_gps_visualization_action.setEnabled(False)\n        if not self.SUCCESS_GND_GIMBAL and self.SUCCESS_GND_FPGA and not self.SUCCESS_GND_GPS:\n            self.create_class_instances(IsRFSoC=True)\n            self.start_meas_togglePushButton.setEnabled(True)\n            print(\"[DEBUG]: Class created at GND with RFSoC\")\n        if not self.SUCCESS_GND_GIMBAL and not self.SUCCESS_GND_FPGA and not self.SUCCESS_GND_GPS:\n            self.create_class_instances()\n            self.start_meas_togglePushButton.setEnabled(False)\n            print(\"[DEBUG]: Class created at GND with NO devices\")\n        if not self.SUCCESS_GND_GIMBAL and not self.SUCCESS_GND_FPGA and self.SUCCESS_GND_GPS:\n            self.create_class_instances(IsGPS=True)\n            self.start_meas_togglePushButton.setEnabled(False)\n            print(\"[DEBUG]: Class created at GND with GPS\")\n            if self.SUCCESS_DRONE_GPS:\n                self.start_gps_visualization_action.setEnabled(True)\n                self.stop_gps_visualization_action.setEnabled(False)\n\n        if self.SUCCES_DRONE_GIMBAL and self.SUCCESS_DRONE_GPS:\n            self.start_drone_gimbal_fm_action.setEnabled(True)\n            self.stop_drone_gimbal_fm_action.setEnabled(False)\n\n        self.stop_meas_togglePushButton.setEnabled(False)\n        self.finish_meas_togglePushButton.setEnabled(False)\n        self.connect_to_drone.setEnabled(False)\n        self.disconnect_from_drone.setEnabled(True)\n        self.setupDevicesAndMoreAction.setDisabled(True)\n\n    def disconnect_drone_callback(self):\n        \"\"\"\n        Callback for when the user presses the \"Disconnect\" button.\n\n        If there is an ongoing measurement it will be finished.\n\n        The WiFi thread will be stopped and its associated socket will be closed in this node. Devices connection to this node will be closed.\n        \"\"\"\n\n        if hasattr(self, 'periodical_gimbal_follow_thread'):\n            if self.periodical_gimbal_follow_thread.isRunning():\n                self.stop_event_gimbal_follow_thread.set()\n\n        if hasattr(self, 'periodical_gps_display_thread'):\n            if self.periodical_gps_display_thread.isActive():\n                self.periodical_gps_display_thread.stop()\n\n        if self.stop_meas_togglePushButton.isChecked():\n            print(\"[DEBUG]: Before disconnecting, the ongoing measurement will be stopped\")\n            self.stop_meas_button_callback()\n        if self.finish_meas_togglePushButton.isChecked():\n            print(\"[DEBUG]: Before disconnecting, the ongoing measurement will be finished\")\n            self.finish_meas_button_callback()\n\n        self.myhelpera2g.socket_send_cmd(type_cmd='CLOSEDGUI')\n        self.myhelpera2g.HelperA2GStopCom(DISC_WHAT='ALL') # shutdowns the devices that where passed by parameters as True, when the class instance is created\n        del self.myhelpera2g\n\n        self.start_meas_togglePushButton.setEnabled(False)\n        self.stop_meas_togglePushButton.setEnabled(False)\n        self.finish_meas_togglePushButton.setEnabled(False)\n        self.connect_to_drone.setEnabled(True)\n        self.disconnect_from_drone.setEnabled(False)\n\n        self.setupDevicesAndMoreAction.setEnabled(True)\n        self.start_gnd_gimbal_fm_action.setEnabled(True)\n        self.stop_gnd_gimbal_fm_action.setEnabled(False)\n        self.start_drone_gimbal_fm_action.setEnabled(True)\n        self.stop_drone_gimbal_fm_action.setEnabled(False)        \n        self.start_gps_visualization_action.setEnabled(True)\n        self.stop_gps_visualization_action.setEnabled(False)\n\n    def create_fpga_and_sivers_panel(self):\n        \"\"\"\n        Creates the \"Sivers settings\" panel with its widgets and layout.\n        \"\"\"\n\n        self.fpgaAndSiversSettingsPanel = QGroupBox('Sivers settings')\n\n        rf_op_freq_label = QLabel('Freq. Operation [Hz]:')\n        tx_bb_gain_label = QLabel('Tx BB Gain [dB]:')\n        tx_bb_phase_label = QLabel('Tx BB Phase [dB]:')\n        tx_bb_iq_gain_label = QLabel('Tx BB IQ Gain [dB]:')\n        tx_bfrf_gain_label = QLabel('Tx BF &amp; RF Gain [dB]:')\n        rx_bb_gain_1_label = QLabel('Rx BB Gain 1 [dB]:')\n        rx_bb_gain_2_label = QLabel('Rx BB Gain 2 [dB]:')\n        rx_bb_gain_3_label = QLabel('Rx BB Gain 3 [dB]:')\n        rx_bfrf_gain_label = QLabel('Rx BF &amp; RF Gain [dB]:')\n\n        tx_bb_gain_label.leaveEvent = lambda e: QToolTip.hideText()\n        tx_bb_gain_label.enterEvent = lambda e: QToolTip.showText(QCursor.pos(), \"Not available to the user for the moment\")\n\n        #tx_bb_phase_label.leaveEvent = lambda e: QToolTip.hideText()\n        #tx_bb_phase_label.enterEvent = lambda e: QToolTip.showText(QCursor.pos(), \"Defaults to 0.\")\n\n        # Luckily lambda functions can help us to re implement QLabel methods leaveEvent and enterEvent in one line\n        tx_bb_iq_gain_label.leaveEvent = lambda e: QToolTip.hideText()\n        tx_bb_iq_gain_label.enterEvent = lambda e: QToolTip.showText(QCursor.pos(), \"INPUT A VALUE IN: [0,6] dB\\nThis sets the BB gain for the I, Q signals.\\nThe actual value in dB is chosen as the closest value in the array linspace(0,6,16)\")\n\n        tx_bfrf_gain_label.leaveEvent = lambda e: QToolTip.hideText()\n        tx_bfrf_gain_label.enterEvent = lambda e: QToolTip.showText(QCursor.pos(), \"INPUT A VALUE IN: [0,15] dB\\nThis sets the gain after RF mixer for the I, Q signals.\\nThe actual value in dB is chosen as the closest value in the array linspace(0,15,16)\")\n\n        rx_bb_gain_1_label.leaveEvent = lambda e: QToolTip.hideText()\n        rx_bb_gain_1_label.enterEvent = lambda e: QToolTip.showText(QCursor.pos(), \"INPUT A VALUE IN: [-6,0] dB\\nThis sets the rx 1st BB gain for the I, Q signals.\\nThe actual value in dB is chosen as the closest value in the array linspace(-6,0,4)\")\n\n        rx_bb_gain_2_label.leaveEvent = lambda e: QToolTip.hideText()\n        rx_bb_gain_2_label.enterEvent = lambda e: QToolTip.showText(QCursor.pos(), \"INPUT A VALUE IN: [-6,0] dB\\nThis sets the rx 2nd BB gain for the I, Q signals.\\nThe actual value in dB is chosen as the closest value in the array linspace(-6,0,4)\")\n\n        rx_bb_gain_3_label.leaveEvent = lambda e: QToolTip.hideText()\n        rx_bb_gain_3_label.enterEvent = lambda e: QToolTip.showText(QCursor.pos(), \"INPUT A VALUE IN: [0,6] dB\\nThis sets the rx 3rd BB gain for the I, Q signals.\\nThe actual value in dB is chosen as the closest value in the array linspace(0,6,16)\")\n\n        rx_bfrf_gain_label.leaveEvent = lambda e: QToolTip.hideText()\n        rx_bfrf_gain_label.enterEvent = lambda e: QToolTip.showText(QCursor.pos(), \"INPUT A VALUE IN: [0,15] dB\\nThis sets the rx gain before the RF mixer for the I, Q signals.\\nThe actual value in dB is chosen as the closest value in the array linspace(0,15,16)\")\n\n        self.rf_op_freq_text_edit = QLineEdit('57.51e9')\n        self.tx_bb_gain_text_edit = QLineEdit('3')\n        self.tx_bb_phase_text_edit = QLineEdit('0')\n        self.tx_bb_iq_gain_text_edit = QLineEdit('1.6')\n        self.tx_bfrf_gain_text_edit = QLineEdit('3')\n        self.rx_bb_gain_1_text_edit = QLineEdit('-1.5')\n        self.rx_bb_gain_2_text_edit = QLineEdit('-4.5')\n        self.rx_bb_gain_3_text_edit = QLineEdit('1.6')\n        self.rx_bfrf_gain_text_edit = QLineEdit('7')\n        self.tx_bb_phase_text_edit.setEnabled(False)\n        self.tx_bb_gain_text_edit.setEnabled(False)\n\n        layout = QGridLayout()\n\n        layout.addWidget(rf_op_freq_label, 0, 0, 1, 2)\n        layout.addWidget(self.rf_op_freq_text_edit, 0, 2, 1, 2)\n        layout.addWidget(tx_bb_gain_label, 1, 0, 1, 1)\n        layout.addWidget(self.tx_bb_gain_text_edit, 1, 1, 1, 1)\n        layout.addWidget(rx_bb_gain_1_label, 1, 2, 1, 1)\n        layout.addWidget(self.rx_bb_gain_1_text_edit, 1, 3, 1, 1)\n\n        layout.addWidget(tx_bb_phase_label, 2, 0, 1, 1)\n        layout.addWidget(self.tx_bb_phase_text_edit, 2, 1, 1, 1)\n        layout.addWidget(rx_bb_gain_2_label, 2, 2, 1, 1)\n        layout.addWidget(self.rx_bb_gain_2_text_edit, 2, 3, 1, 1)\n\n        layout.addWidget(tx_bb_iq_gain_label, 3, 0, 1, 1)\n        layout.addWidget(self.tx_bb_iq_gain_text_edit, 3, 1, 1, 1)\n        layout.addWidget(rx_bb_gain_3_label, 3, 2, 1, 1)\n        layout.addWidget(self.rx_bb_gain_3_text_edit, 3, 3, 1, 1)\n\n        layout.addWidget(tx_bfrf_gain_label, 4, 0, 1, 1)\n        layout.addWidget(self.tx_bfrf_gain_text_edit, 4, 1, 1, 1)\n        layout.addWidget(rx_bfrf_gain_label, 4, 2, 1, 1)\n        layout.addWidget(self.rx_bfrf_gain_text_edit, 4, 3, 1, 1)\n\n        self.fpgaAndSiversSettingsPanel.setLayout(layout)\n\n    def checker_gimbal_input_range(self, angle):\n        \"\"\"\n        Checks if a given angle is within the allowed range.\n\n        Args:\n            angle (float): angle in degrees.\n\n        Returns:\n            incorrect_angle_value (bool): True if the angle is within the allowed range, False otherwise.\n        \"\"\"\n\n        incorrect_angle_value = False\n        if angle &gt; 180 or angle &lt; -180:\n            print(\"[DEBUG]: Angle value outside of range\")\n            incorrect_angle_value = True\n\n        return incorrect_angle_value\n\n    def move_button_gimbal_gnd_callback(self):\n        \"\"\"\n        Callback for when the user presses the \"Move\" button from the Gimbal GND panel. The yaw and pitch QLineEdits control the amount of movement, and the absolute or relative QRadioButtons if the movement is absolute or relative. BOTH yaw and pitch inputs are required.\n\n        Example:\n\n        For a yaw absolute movement to -20 deg and a pitch to 97 deg, the user MUST select the absolute radio button and enter -20 in the yaw text box and enter 97 in the pitch text box.\n        \"\"\"\n\n        if hasattr(self, 'myhelpera2g'):\n            if hasattr(self.myhelpera2g, 'myGimbal'):\n                yaw = self.tx_yaw_value_text_edit.text()\n                pitch = self.tx_pitch_value_text_edit.text()\n\n                if yaw == '' or pitch == '':\n                    print(\"[DEBUG]: No YAW or PITCH values provided. No gimbal movement will done.\")\n                else:\n                    if self.tx_abs_radio_button.isChecked():\n                        ctrl_byte = 0x01\n                    if self.tx_rel_radio_button.isChecked():\n                        ctrl_byte = 0x00\n\n                    try:\n                        yaw = int(float(yaw))\n                        pitch = int(float(pitch))\n                        incorrect_angle_value = self.checker_gimbal_input_range(yaw)\n                        incorrect_angle_value = self.checker_gimbal_input_range(pitch)\n                        self.myhelpera2g.myGimbal.setPosControl(yaw=yaw*10, roll=0, pitch=pitch*10, ctrl_byte=ctrl_byte)\n                        print(f\"[DEBUG]: gimbal moved {yaw} degs in YAW and {pitch} in PITCH from application\")\n                    except Exception as e:\n                        print(\"[DEBUG]: Error executing gimbal movement. Most probably wrong angle input, \", e)\n            else:\n                print(\"[DEBUG]: No gimbal has been created at GND, so buttons will do nothing\")\n        else:\n            print(\"[DEBUG]: No HelperA2GMeasurements class instance is available\")\n\n    def left_button_gimbal_gnd_callback(self):\n        \"\"\"\n        Callback for when the user presses the ``Left`` button from the Gimbal GND panel. \n\n        Direction buttons (up, down, left, right) move the gimbal the direction they indicate, by the amount given in the ``Step`` textbox. The movement is relative to the angle before the button was pressed.\n\n        If no value is provided in the ``Step`` textbox, the gimbal moves a value of 10 degrees in the direction indicated by this button.\n        \"\"\"\n\n        if hasattr(self, 'myhelpera2g'):\n            if hasattr(self.myhelpera2g, 'myGimbal'):\n                movement_step = self.tx_step_manual_move_gimbal_text_edit.text()\n\n                if movement_step != '':\n                    try:\n                        tmp = int(float(movement_step))\n                        incorrect_angle_value = self.checker_gimbal_input_range(tmp)\n                        if tmp &lt; 0:\n                            tmp = abs(tmp)\n                            print(\"[DEBUG]: The movement step Textbox in the Gimbal Control Panel is always taken as positive. Direction is given by arrows.\")\n                        self.myhelpera2g.myGimbal.setPosControl(yaw=-tmp*10, roll=0, pitch=0, ctrl_byte=0x00)\n                        print(f\"[DEBUG]: gimbal moved -{movement_step} degs from application\")\n                    except Exception as e:\n                        print(\"[DEBUG]: Error executing gimbal movement. Most probably wrong MOVEMENT STEP format, \", e)\n                else:\n                    self.myhelpera2g.myGimbal.setPosControl(yaw=-100, roll=0, pitch=0, ctrl_byte=0x00)\n                    print(\"[DEBUG]: gimbal moved from application by a predetermined angle of -10 deg, since no angle was specified\")\n\n            else:\n                print(\"[DEBUG]: No gimbal has been created at GND, so buttons will do nothing\")\n        else:\n            print(\"[DEBUG]: No HelperA2GMeasurements class instance is available\")\n\n    def right_button_gimbal_gnd_callback(self):\n        \"\"\"\n        Callback for when the user presses the ``Right`` button from the Gimbal GND panel. \n\n        Direction buttons (up, down, left, right) move the gimbal the direction they indicate, by the amount given in the ``Step`` textbox. The movement is relative to the angle before the button was pressed.\n\n        If no value is provided in the ``Step`` textbox, the gimbal moves a value of 10 degrees in the direction indicated by this button.\n        \"\"\"        \n\n        if hasattr(self, 'myhelpera2g'):\n            if hasattr(self.myhelpera2g, 'myGimbal'):\n                movement_step = self.tx_step_manual_move_gimbal_text_edit.text()\n\n                if movement_step != '':\n                    try:\n                        tmp = int(float(movement_step))\n                        incorrect_angle_value = self.checker_gimbal_input_range(tmp)\n                        if tmp &lt; 0:\n                            tmp = abs(tmp)\n                            print(\"[DEBUG]: The movement step Textbox in the Gimbal Control Panel is always taken as positive. Direction is given by arrows.\")\n                        self.myhelpera2g.myGimbal.setPosControl(yaw=tmp*10, roll=0, pitch=0, ctrl_byte=0x00)\n                        print(f\"[DEBUG]: gimbal moved {movement_step} degs from application\")\n                    except Exception as e:\n                        print(\"[DEBUG]: Error executing gimbal movement. Most probably wrong MOVEMENT STEP format, \", e)\n                else:\n                    self.myhelpera2g.myGimbal.setPosControl(yaw=100, roll=0, pitch=0, ctrl_byte=0x00)\n                    print(\"[DEBUG]: gimbal moved from application by a predetermined angle of 10 deg, since no angle was specified\")\n\n            else:\n                print(\"[DEBUG]: No gimbal has been created at GND, so buttons will do nothing\")\n        else:\n            print(\"[DEBUG]: No HelperA2GMeasurements class instance is available\")\n\n    def up_button_gimbal_gnd_callback(self):\n        \"\"\"\n        Callback for when the user presses the ``Up`` button from the Gimbal GND panel. \n\n        Direction buttons (up, down, left, right) move the gimbal the direction they indicate, by the amount given in the ``Step`` textbox. The movement is relative to the angle before the button was pressed.\n\n        If no value is provided in the ``Step`` textbox, the gimbal moves a value of 10 degrees in the direction indicated by this button.\n        \"\"\"\n\n        if hasattr(self, 'myhelpera2g'):\n            if hasattr(self.myhelpera2g, 'myGimbal'):\n                movement_step = self.tx_step_manual_move_gimbal_text_edit.text()\n\n                if movement_step != '':\n                    try:\n                        tmp = int(float(movement_step))\n                        incorrect_angle_value = self.checker_gimbal_input_range(tmp)\n                        if tmp &lt; 0:\n                            tmp = abs(tmp)\n                            print(\"[DEBUG]: The movement step Textbox in the Gimbal Control Panel is always taken as positive. Direction is given by arrows.\")\n                        self.myhelpera2g.myGimbal.setPosControl(yaw=0, roll=0, pitch=tmp*10, ctrl_byte=0x00)\n                        print(f\"[DEBUG]: gimbal moved -{movement_step} degs from application\")\n                    except Exception as e:\n                        print(\"[DEBUG]: Error executing gimbal movement. Most probably wrong MOVEMENT STEP format, \", e)\n                else:\n                    self.myhelpera2g.myGimbal.setPosControl(yaw=0, roll=0, pitch=100, ctrl_byte=0x00)\n                    print(\"[DEBUG]: gimbal moved from application by a predetermined angle of 10 deg, since no angle was specified\")\n\n            else:\n                print(\"[DEBUG]: No gimbal has been created at GND, so buttons will do nothing\")\n        else:\n            print(\"[DEBUG]: No HelperA2GMeasurements class instance is available\")\n\n    def down_button_gimbal_gnd_callback(self):\n        \"\"\"\n        Callback for when the user presses the ``Down`` button from the Gimbal GND panel. \n\n        Direction buttons (up, down, left, right) move the gimbal the direction they indicate, by the amount given in the ``Step`` textbox. The movement is relative to the angle before the button was pressed.\n\n        If no value is provided in the ``Step`` textbox, the gimbal moves a value of 10 degrees in the direction indicated by this button.\n        \"\"\"\n\n        if hasattr(self, 'myhelpera2g'):\n            if hasattr(self.myhelpera2g, 'myGimbal'):\n                movement_step = self.tx_step_manual_move_gimbal_text_edit.text()\n\n                if movement_step != '':\n                    try:\n                        tmp = int(float(movement_step))\n                        incorrect_angle_value = self.checker_gimbal_input_range(tmp)\n                        if tmp &lt; 0:\n                            tmp = abs(tmp)\n                            print(\"[DEBUG]: The movement step Textbox in the Gimbal Control Panel is always taken as positive. Direction is given by arrows.\")\n                        self.myhelpera2g.myGimbal.setPosControl(yaw=0, roll=0, pitch=-tmp*10, ctrl_byte=0x00)\n                        print(f\"[DEBUG]: gimbal moved {movement_step} degs from application\")\n                    except Exception as e:\n                        print(\"[DEBUG]: Error executing gimbal movement. Most probably wrong MOVEMENT STEP format, \", e)\n                else:\n                    self.myhelpera2g.myGimbal.setPosControl(yaw=0, roll=0, pitch=-100, ctrl_byte=0x00)\n                    print(\"[DEBUG]: gimbal moved from application by a predetermined angle of -10 deg, since no angle was specified\")\n\n            else:\n                print(\"[DEBUG]: No gimbal has been created at GND, so buttons will do nothing\")\n        else:\n            print(\"[DEBUG]: No HelperA2GMeasurements class instance is available\")\n\n    def move_button_gimbal_drone_callback(self):\n        \"\"\"\n        Callback for when the user presses the \"Move\" button from the Gimbal Drone panel. The yaw and pitch QLineEdits control the amount of movement, and the absolute or relative QRadioButtons if the movement is absolute or relative. BOTH yaw and pitch inputs are required.\n\n        Example:\n\n        For a yaw absolute movement to -20 deg and a pitch to 97 deg, the user MUST select the absolute radio button and enter -20 in the yaw text box and enter 97 in the pitch text box.\n        \"\"\"\n        if hasattr(self, 'myhelpera2g'):\n            yaw = self.rx_yaw_value_text_edit.text()\n            pitch = self.rx_pitch_value_text_edit.text()\n\n            if yaw == '' or pitch == '':\n                print(\"[DEBUG]: No YAW or PITCH values provided. No gimbal movement will done.\")\n            else:\n                if self.rx_abs_radio_button.isChecked():\n                    ctrl_byte = 0x01\n                if self.rx_rel_radio_button.isChecked():\n                    ctrl_byte = 0x00\n                try:\n                    yaw = int(float(yaw))\n                    pitch = int(float(pitch))\n                    incorrect_angle_value = self.checker_gimbal_input_range(yaw)\n                    incorrect_angle_value = self.checker_gimbal_input_range(pitch)\n                    if self.droneGimbalChoice == \"DJI Ronin RS2\":\n                        data = {'YAW': yaw*10, 'PITCH': pitch*10, 'ROLL': 0, 'MODE': ctrl_byte}\n                    elif self.droneGimbalChoice == \"Gremsy H16\":\n                        data = {'YAW': yaw, 'PITCH': pitch, 'ROLL': 0, 'MODE': ctrl_byte}\n                    self.myhelpera2g.socket_send_cmd(type_cmd='SETGIMBAL', data=data)\n                    print(f\"[DEBUG]: gimbal moved {yaw} degs in YAW and {pitch} in PITCH from application\")\n                except Exception as e:\n                    print(\"[DEBUG]: Error executing gimbal movement. Most probably wrong angle input, \", e)\n        else:\n            print(\"[DEBUG]: No HelperA2GMeasurements class instance is available\")\n\n    def left_button_gimbal_drone_callback(self):\n        \"\"\"\n        Callback for when the user presses the \"Left\" button from the Gimbal Drone panel. \n\n        Direction buttons (up, down, left, right) move the gimbal the direction they indicate, by the amount given in the \"Step\" textbox. The movement is relative to the angle before the button was pressed.\n\n        If no value is provided in the \"Step\" textbox, the gimbal moves a value of 10 degrees in the direction indicated by this button.\n        \"\"\"\n        if hasattr(self, 'myhelpera2g'):\n            movement_step = self.rx_step_manual_move_gimbal_text_edit.text()\n            if movement_step != '':\n                try:\n                    tmp = int(float(movement_step))\n                    incorrect_angle_value = self.checker_gimbal_input_range(tmp)\n                    if tmp &lt; 0:\n                        tmp = abs(tmp)\n                        print(\"[DEBUG]: The movement step Textbox in the Gimbal Control Panel is always taken as positive. Direction is given by arrows.\")\n\n                    if self.droneGimbalChoice == \"DJI Ronin RS2\":\n                        data = {'YAW': -tmp*10, 'PITCH': 0, 'ROLL': 0, 'MODE': 0x00}\n                    elif self.droneGimbalChoice == \"Gremsy H16\":\n                        data = {'YAW': -tmp, 'PITCH': 0, 'ROLL': 0, 'MODE': 0x00}\n                    self.myhelpera2g.socket_send_cmd(type_cmd='SETGIMBAL', data=data)\n                    print(f\"[DEBUG]: gimbal moved -{movement_step} degs from application\")\n                except Exception as e:\n                        print(\"[DEBUG]: Error executing gimbal movement. Most probably wrong MOVEMENT STEP format, \", e)\n            else:\n                if self.droneGimbalChoice == \"DJI Ronin RS2\":\n                    data = {'YAW': -100, 'PITCH': 0, 'ROLL': 0,'MODE': 0x00}\n                elif self.droneGimbalChoice == \"Gremsy H16\":\n                    data = {'YAW': -10, 'PITCH': 0, 'ROLL': 0,'MODE': 0x00}\n                self.myhelpera2g.socket_send_cmd(type_cmd='SETGIMBAL', data=data)\n                print(\"[DEBUG]: gimbal moved from application by a predetermined angle of -10 deg, since no angle was specified\")\n        else:\n            print(\"[DEBUG]: No HelperA2GMeasurements class instance is available\")\n\n    def right_button_gimbal_drone_callback(self):\n        \"\"\"\n        Callback for when the user presses the \"Left\" button from the Gimbal drone panel. \n\n        Direction buttons (up, down, left, right) move the gimbal the direction they indicate, by the amount given in the \"Step\" textbox. The movement is relative to the angle before the button was pressed.\n\n        If no value is provided in the \"Step\" textbox, the gimbal moves a value of 10 degrees in the direction indicated by this button.\n        \"\"\"\n        if hasattr(self, 'myhelpera2g'):\n            movement_step = self.rx_step_manual_move_gimbal_text_edit.text()\n            if movement_step != '':\n                try:\n                    tmp = int(float(movement_step))\n                    incorrect_angle_value = self.checker_gimbal_input_range(tmp)\n                    if tmp &lt; 0:\n                        tmp = abs(tmp)\n                        print(\"[DEBUG]: The movement step Textbox in the Gimbal Control Panel is always taken as positive. Direction is given by arrows.\")\n                    if self.droneGimbalChoice == \"DJI Ronin RS2\":\n                        data = {'YAW': tmp*10, 'PITCH': 0,'ROLL': 0, 'MODE': 0x00}\n                    elif self.droneGimbalChoice == \"Gremsy H16\":\n                        data = {'YAW': tmp, 'PITCH': 0,'ROLL': 0, 'MODE': 0x00}\n                    self.myhelpera2g.socket_send_cmd(type_cmd='SETGIMBAL', data=data)\n                    print(f\"[DEBUG]: gimbal moved {movement_step} degs from application\")\n                except Exception as e:\n                        print(\"[DEBUG]: Error executing gimbal movement. Most probably wrong MOVEMENT STEP format, \", e)\n            else:\n                if self.droneGimbalChoice == \"DJI Ronin RS2\":\n                    data = {'YAW': 100, 'PITCH': 0,'ROLL': 0, 'MODE': 0x00}\n                elif self.droneGimbalChoice == \"Gremsy H16\":\n                    data = {'YAW': 10, 'PITCH': 0,'ROLL': 0, 'MODE': 0x00}\n                self.myhelpera2g.socket_send_cmd(type_cmd='SETGIMBAL', data=data)\n                print(\"[DEBUG]: gimbal moved from application by a predetermined angle of -10 deg, since no angle was specified\")\n        else:\n            print(\"[DEBUG]: No HelperA2GMeasurements class instance is available\")\n\n    def up_button_gimbal_drone_callback(self):\n        \"\"\"\n        Callback for when the user presses the \"Left\" button from the Gimbal drone panel. \n\n        Direction buttons (up, down, left, right) move the gimbal the direction they indicate, by the amount given in the \"Step\" textbox. The movement is relative to the angle before the button was pressed.\n\n        If no value is provided in the \"Step\" textbox, the gimbal moves a value of 10 degrees in the direction indicated by this button.\n        \"\"\"\n        if hasattr(self, 'myhelpera2g'):\n            movement_step = self.rx_step_manual_move_gimbal_text_edit.text()\n            if movement_step != '':\n                try:\n                    tmp = int(float(movement_step))\n                    incorrect_angle_value = self.checker_gimbal_input_range(tmp)\n                    if tmp &lt; 0:\n                        tmp = abs(tmp)\n                        print(\"[DEBUG]: The movement step Textbox in the Gimbal Control Panel is always taken as positive. Direction is given by arrows.\")\n                    if self.droneGimbalChoice == \"DJI Ronin RS2\":\n                        data = {'YAW': 0, 'PITCH': tmp*10,'ROLL': 0, 'MODE': 0x00}\n                    elif self.droneGimbalChoice == \"Gremsy H16\":    \n                        data = {'YAW': 0, 'PITCH': tmp,'ROLL': 0, 'MODE': 0x00}\n                    self.myhelpera2g.socket_send_cmd(type_cmd='SETGIMBAL', data=data)\n                    print(f\"[DEBUG]: gimbal moved {movement_step} degs from application\")\n                except Exception as e:\n                        print(\"[DEBUG]: Error executing gimbal movement. Most probably wrong MOVEMENT STEP format, \", e)\n            else:\n                if self.droneGimbalChoice == \"DJI Ronin RS2\":\n                    data = {'YAW': 0, 'PITCH': 100, 'ROLL': 0,'MODE': 0x00}\n                elif self.droneGimbalChoice == \"Gremsy H16\":\n                    data = {'YAW': 0, 'PITCH': 10, 'ROLL': 0,'MODE': 0x00}\n                self.myhelpera2g.socket_send_cmd(type_cmd='SETGIMBAL', data=data)\n                print(\"[DEBUG]: gimbal moved from application by a predetermined angle of 10 deg, since no angle was specified\")\n        else:\n            print(\"[DEBUG]: No HelperA2GMeasurements class instance is available\")\n\n    def down_button_gimbal_drone_callback(self):\n        \"\"\"\n        Callback for when the user presses the \"Left\" button from the Gimbal drone panel. \n\n        Direction buttons (up, down, left, right) move the gimbal the direction they indicate, by the amount given in the \"Step\" textbox. The movement is relative to the angle before the button was pressed.\n\n        If no value is provided in the \"Step\" textbox, the gimbal moves a value of 10 degrees in the direction indicated by this button.\n        \"\"\"\n        if hasattr(self, 'myhelpera2g'):\n            movement_step = self.rx_step_manual_move_gimbal_text_edit.text()\n            if movement_step != '':\n                try:\n                    tmp = int(float(movement_step))\n                    incorrect_angle_value = self.checker_gimbal_input_range(tmp)\n                    if tmp &lt; 0:\n                        tmp = abs(tmp)\n                        print(\"[DEBUG]: The movement step Textbox in the Gimbal Control Panel is always taken as positive. Direction is given by arrows.\")\n                    if self.droneGimbalChoice == \"DJI Ronin RS2\":\n                        data = {'YAW': 0, 'PITCH': -tmp*10,'ROLL': 0, 'MODE': 0x00}\n                    elif self.droneGimbalChoice == \"Gremsy H16\":\n                        data = {'YAW': 0, 'PITCH': -tmp,'ROLL': 0, 'MODE': 0x00}\n                    self.myhelpera2g.socket_send_cmd(type_cmd='SETGIMBAL', data=data)\n                    print(f\"[DEBUG]: gimbal moved -{movement_step} degs from application\")\n                except Exception as e:\n                        print(\"[DEBUG]: Error executing gimbal movement. Most probably wrong MOVEMENT STEP format, \", e)\n            else:\n                if self.droneGimbalChoice == \"DJI Ronin RS2\":\n                    data = {'YAW': 0, 'PITCH': -100,'ROLL': 0, 'MODE': 0x00}\n                elif self.droneGimbalChoice == \"Gremsy H16\":\n                    data = {'YAW': 0, 'PITCH': -10, 'ROLL': 0,'MODE': 0x00}\n                self.myhelpera2g.socket_send_cmd(type_cmd='SETGIMBAL', data=data)\n                print(\"[DEBUG]: gimbal moved from application by a predetermined angle of -10 deg, since no angle was specified\")\n        else:\n            print(\"[DEBUG]: No HelperA2GMeasurements class instance is available\")\n\n    def tx_move_according_coords_push_button_callback(self):\n        1\n\n    def rx_move_according_coords_push_button_callback(self):\n        1\n\n    def create_Gimbal_GND_panel(self):\n        \"\"\"\n        Creates the ground gimbal panel with its widgets and layout.\n        \"\"\"\n\n        self.gimbalTXPanel = QGroupBox('GND Gimbal')\n\n        yaw_label = QLabel('Yaw [D]:')\n        pitch_label = QLabel('Pitch [D]:')\n\n        self.tx_abs_radio_button = QRadioButton(\"Absolute\")\n        self.tx_rel_radio_button = QRadioButton(\"Relative\")        \n        self.tx_abs_radio_button.setChecked(True)\n\n        self.tx_yaw_value_text_edit = QLineEdit('')\n        self.tx_pitch_value_text_edit = QLineEdit('')\n        self.tx_step_manual_move_gimbal_text_edit = QLineEdit('')\n\n        thisLatLabel = QLabel('This Lat:')\n        thisLonLabel = QLabel('This Lon:')\n        otherLatLabel = QLabel('Other Lat:')\n        otherLonLabel = QLabel('Other Lon:')\n\n        self.tx_this_lat_text_edit = QLineEdit('')\n        self.tx_this_lon_text_edit = QLineEdit('')\n        self.tx_other_lat_text_edit = QLineEdit('')\n        self.tx_other_lon_text_edit = QLineEdit('')\n\n        self.tx_move_according_coords_push_button = QPushButton('Coords Move')\n        self.tx_move_according_coords_push_button.clicked.connect(self.tx_move_according_coords_push_button_callback)\n\n        self.tx_gimbal_manual_move_push_button = QPushButton('Move')\n        self.tx_gimbal_manual_move_push_button.clicked.connect(self.move_button_gimbal_gnd_callback)\n        self.tx_gimbal_move_left_push_button = QPushButton('Left')\n        self.tx_gimbal_move_left_push_button.clicked.connect(self.left_button_gimbal_gnd_callback)\n        self.tx_gimbal_move_right_push_button = QPushButton('Right')\n        self.tx_gimbal_move_right_push_button.clicked.connect(self.right_button_gimbal_gnd_callback)\n        self.tx_gimbal_move_up_push_button = QPushButton('Up')\n        self.tx_gimbal_move_up_push_button.clicked.connect(self.up_button_gimbal_gnd_callback)\n        self.tx_gimbal_move_down_push_button = QPushButton('Down')\n        self.tx_gimbal_move_down_push_button.clicked.connect(self.down_button_gimbal_gnd_callback)\n\n        layout = QGridLayout()\n        layout.addWidget(self.tx_gimbal_move_up_push_button, 0, 0, 1, 3)\n        layout.addWidget(self.tx_gimbal_move_left_push_button, 1, 0, 1, 3)\n        layout.addWidget(self.tx_step_manual_move_gimbal_text_edit, 2, 0, 1, 3)\n        layout.addWidget(self.tx_gimbal_move_right_push_button, 3, 0, 1, 3)\n        layout.addWidget(self.tx_gimbal_move_down_push_button, 4, 0, 1, 3)\n\n        layout.addWidget(self.tx_abs_radio_button, 0, 3, 1, 3)\n        layout.addWidget(self.tx_rel_radio_button, 1, 3, 1, 3)\n        layout.addWidget(yaw_label, 2, 3, 1, 1)\n        layout.addWidget(self.tx_yaw_value_text_edit, 2, 4, 1, 2)\n        layout.addWidget(pitch_label, 3, 3, 1, 1)        \n        layout.addWidget(self.tx_pitch_value_text_edit, 3, 4, 1, 2)\n        layout.addWidget(self.tx_gimbal_manual_move_push_button, 4, 3, 1, 3)     \n\n        layout.addWidget(thisLatLabel, 0, 6, 1, 1)\n        layout.addWidget(self.tx_this_lat_text_edit, 0, 7, 1, 2)\n        layout.addWidget(thisLonLabel, 1, 6, 1, 1)\n        layout.addWidget(self.tx_this_lon_text_edit, 1, 7, 1, 2)\n        layout.addWidget(otherLatLabel, 2, 6, 1, 1)        \n        layout.addWidget(self.tx_other_lat_text_edit, 2, 7, 1, 2)\n        layout.addWidget(otherLonLabel, 3, 6, 1, 1)\n        layout.addWidget(self.tx_other_lon_text_edit, 3, 7, 1, 2)\n        layout.addWidget(self.tx_move_according_coords_push_button, 4, 6, 1, 3)\n\n        self.gimbalTXPanel.setLayout(layout)\n\n    def create_Gimbal_AIR_panel(self):\n        \"\"\"\n        Creates the drone gimbal panel with its widgets and layout.\n        \"\"\"\n        self.gimbalRXPanel = QGroupBox('Drone Gimbal')\n\n        yaw_label = QLabel('Yaw [D]:')\n        pitch_label = QLabel('Pitch [D]:')\n\n        self.drone_gimbal_top_down_menu = QComboBox()\n\n        if self.droneGimbalChoice == \"DJI Ronin RS2\":\n            self.rx_abs_radio_button = QRadioButton(\"Absolute\")\n            self.rx_rel_radio_button = QRadioButton(\"Relative\")\n            self.rx_abs_radio_button.setChecked(True)\n        elif self.droneGimbalChoice == \"Gremsy H16\":\n            self.rx_lock_mode_radio_button = QRadioButton(\"Lock\")\n            self.rx_follow_mode_radio_button = QRadioButton(\"Follow\")\n            self.rx_lock_mode_radio_button.setChecked(True)\n\n            self.rx_lock_mode_radio_button.clicked.connect(self.rx_lock_mode_radio_button_callback)\n            self.rx_follow_mode_radio_button.clicked.connect(self.rx_follow_mode_radio_button_callback)\n\n        self.rx_yaw_value_text_edit = QLineEdit('')\n        self.rx_pitch_value_text_edit = QLineEdit('')\n        self.rx_step_manual_move_gimbal_text_edit = QLineEdit('')\n\n        self.rx_move_according_coords_push_button = QPushButton('Coords Move')\n        self.rx_move_according_coords_push_button.clicked.connect(self.rx_move_according_coords_push_button_callback)\n\n        self.rx_gimbal_manual_move_push_button = QPushButton('Move')\n        self.rx_gimbal_manual_move_push_button.clicked.connect(self.move_button_gimbal_drone_callback)\n        self.rx_gimbal_move_left_push_button = QPushButton('Left')\n        self.rx_gimbal_move_left_push_button.clicked.connect(self.left_button_gimbal_drone_callback)\n        self.rx_gimbal_move_right_push_button = QPushButton('Right')\n        self.rx_gimbal_move_right_push_button.clicked.connect(self.right_button_gimbal_drone_callback)\n        self.rx_gimbal_move_up_push_button = QPushButton('Up')\n        self.rx_gimbal_move_up_push_button.clicked.connect(self.up_button_gimbal_drone_callback)\n        self.rx_gimbal_move_down_push_button = QPushButton('Down')\n        self.rx_gimbal_move_down_push_button.clicked.connect(self.down_button_gimbal_drone_callback)\n\n        thisLatLabel = QLabel('This Lat:')\n        thisLonLabel = QLabel('This Lon:')\n        otherLatLabel = QLabel('Other Lat:')\n        otherLonLabel = QLabel('Other Lon:')\n\n        self.rx_this_lat_text_edit = QLineEdit('')\n        self.rx_this_lon_text_edit = QLineEdit('')\n        self.rx_other_lat_text_edit = QLineEdit('')\n        self.rx_other_lon_text_edit = QLineEdit('')        \n\n        layout = QGridLayout()\n        layout.addWidget(self.rx_gimbal_move_up_push_button, 0, 0, 1, 3)\n        layout.addWidget(self.rx_gimbal_move_left_push_button, 1, 0, 1, 3)\n        layout.addWidget(self.rx_step_manual_move_gimbal_text_edit, 2, 0, 1, 3)\n        layout.addWidget(self.rx_gimbal_move_right_push_button, 3, 0, 1, 3)\n        layout.addWidget(self.rx_gimbal_move_down_push_button, 4, 0, 1, 3)\n\n        if self.droneGimbalChoice == \"DJI Ronin RS2\":\n            layout.addWidget(self.rx_abs_radio_button, 0, 3, 1, 3)\n            layout.addWidget(self.rx_rel_radio_button, 1, 3, 1, 3)\n        elif self.droneGimbalChoice == \"Gremsy H16\":\n            layout.addWidget(self.rx_lock_mode_radio_button, 0, 3, 1, 3)\n            layout.addWidget(self.rx_follow_mode_radio_button, 1, 3, 1, 3)\n        layout.addWidget(yaw_label, 2, 3, 1, 1)\n        layout.addWidget(self.rx_yaw_value_text_edit, 2, 4, 1, 2)\n        layout.addWidget(pitch_label, 3, 3, 1, 1)        \n        layout.addWidget(self.rx_pitch_value_text_edit, 3, 4, 1, 2)\n        layout.addWidget(self.rx_gimbal_manual_move_push_button, 4, 3, 1, 3)     \n\n        layout.addWidget(thisLatLabel, 0, 6, 1, 1)\n        layout.addWidget(self.rx_this_lat_text_edit, 0, 7, 1, 2)\n        layout.addWidget(thisLonLabel, 1, 6, 1, 1)\n        layout.addWidget(self.rx_this_lon_text_edit, 1, 7, 1, 2)\n        layout.addWidget(otherLatLabel, 2, 6, 1, 1)        \n        layout.addWidget(self.rx_other_lat_text_edit, 2, 7, 1, 2)\n        layout.addWidget(otherLonLabel, 3, 6, 1, 1)\n        layout.addWidget(self.rx_other_lon_text_edit, 3, 7, 1, 2)\n        layout.addWidget(self.rx_move_according_coords_push_button, 4, 6, 1, 3)\n\n        self.gimbalRXPanel.setLayout(layout)\n\n    def rx_lock_mode_radio_button_callback(self):\n        \"\"\"\n        Callback for when the user presses the \"LOCK\" radio button in the drone gimbal panel and when it has selected the \"Gremsy H16\" gimbal in the Setup dialog.\n        \"\"\"\n\n        if hasattr(self, 'myhelpera2g'):\n            try:\n                data = {'MODE': 'LOCK'}\n                self.myhelpera2g.socket_send_cmd(type_cmd='SETGIMBAL', data=data)\n                print(f\"[DEBUG]: gimbal mode set to {data['MODE']} from application\")\n            except Exception as e:\n                print(\"[DEBUG]: An error ocurred in the transmission of the Gremsy gimbal mode, \", e)\n        else:\n            print(\"[DEBUG]: No HelperA2GMeasurements class instance is available\")\n\n    def rx_follow_mode_radio_button_callback(self):\n        \"\"\"\n        Callback for when the user presses the \"FOLLOW\" radio button in the drone gimbal panel and when it has selected the \"Gremsy H16\" gimbal in the Setup dialog.\n        \"\"\"\n\n        if hasattr(self, 'myhelpera2g'):\n            try:\n                data = {'MODE': 'FOLLOW'}\n                self.myhelpera2g.socket_send_cmd(type_cmd='SETGIMBAL', data=data)\n                print(f\"[DEBUG]: gimbal mode set to {data['MODE']} from application\")\n            except Exception as e:\n                print(\"[DEBUG]: An error ocurred in the transmission of the Gremsy gimbal mode, \", e)\n        else:\n            print(\"[DEBUG]: No HelperA2GMeasurements class instance is available\")\n\n    def convert_dB_to_valid_hex_sivers_register_values(self):\n        \"\"\"\n        Converts the dB gain values (all of them) the user has input in the \"Sivers settings\" panel to the actual values required for the Sivers EVK registers.\n\n        Returns:\n            tx_signal_values (dict): dictionary with the Tx gain values to be set at the Tx Sivers EVK registers.\n            rx_signal_values (dict): dictionary with the Rx gain values to be set at the RX Sivers EVK registers.\n        \"\"\"\n\n        rxbb1 = float(self.rx_bb_gain_1_text_edit.text())\n        rxbb2 = float(self.rx_bb_gain_2_text_edit.text())\n        rxbb3 = float(self.rx_bb_gain_3_text_edit.text())\n        rxbfrf = float(self.rx_bfrf_gain_text_edit.text())\n\n        txbb = self.tx_bb_gain_text_edit.text()\n        txbbiq = float(self.tx_bb_iq_gain_text_edit.text())\n        txbbphase = self.tx_bb_phase_text_edit.text()\n        txbf = float(self.tx_bfrf_gain_text_edit.text())\n\n        valid_values_rx_bb = [0x00, 0x11, 0x33, 0x77, 0xFF]\n        valid_values_rx_bb_dB = np.linspace(-6, 0, 5)\n\n        valid_values_rx_bb3_bf = [0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF]\n        valid_values_rx_bb3_dB = np.linspace(0,6,16)\n        valid_values_rx_bf_dB = np.linspace(0,15,16)\n\n        valid_values_tx_bbiq_bf = [0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF]\n        valid_values_tx_bbiq_dB = np.linspace(0,6,16)\n        valid_values_tx_bf_dB = np.linspace(0,15,16)        \n\n        tx_signal_values = {'tx_bb_gain':int(txbb,16), \n                            'tx_bb_iq_gain':valid_values_tx_bbiq_bf[np.abs(txbbiq - valid_values_tx_bbiq_dB).argmin()],\n                            'tx_bb_phase':int(txbbphase,16), \n                            'tx_bfrf_gain':valid_values_tx_bbiq_bf[np.abs(txbf - valid_values_tx_bf_dB).argmin()]}\n\n        rx_signal_values = {'rx_gain_ctrl_bb1': valid_values_rx_bb[np.abs(rxbb1 - valid_values_rx_bb_dB).argmin()],\n                'rx_gain_ctrl_bb2': valid_values_rx_bb[np.abs(rxbb2 - valid_values_rx_bb_dB).argmin()],\n                'rx_gain_ctrl_bb3': valid_values_rx_bb3_bf[np.abs(rxbb3 - valid_values_rx_bb3_dB).argmin()],\n                'rx_gain_ctrl_bfrf': valid_values_rx_bb3_bf[np.abs(rxbfrf - valid_values_rx_bf_dB).argmin()]}\n\n        return tx_signal_values, rx_signal_values\n\n    def start_meas_button_callback(self):\n        \"\"\"\n        Callback for when the user presses the \"START\" button. Starts sending pilot signal from the TX Sivers.\n\n        Sends the parameters to the RX sivers (RX RFSoC server) for it to be configured and start to listen incoming signals over the air. \n        \"\"\"\n\n        tx_signal_values, rx_signal_values = self.convert_dB_to_valid_hex_sivers_register_values()\n\n        # Experiment starts\n        self.myhelpera2g.myrfsoc.transmit_signal(carrier_freq=float(self.rf_op_freq_text_edit.text()),\n                                                tx_bb_gain=tx_signal_values['tx_bb_gain'],\n                                                tx_bb_iq_gain=tx_signal_values['tx_bb_iq_gain'],\n                                                tx_bb_phase=tx_signal_values['tx_bb_phase'],\n                                                tx_bfrf_gain=tx_signal_values['tx_bfrf_gain'])\n\n        rx_signal_values['carrier_freq'] = float(self.rf_op_freq_text_edit.text())\n\n        self.myhelpera2g.socket_send_cmd(type_cmd='STARTDRONERFSOC', data=rx_signal_values)\n\n        self.start_meas_togglePushButton.setEnabled(False)\n        self.stop_meas_togglePushButton.setEnabled(True)\n        self.finish_meas_togglePushButton.setEnabled(False)\n        self.update_vis_time_pap = 0.5\n\n        #self.periodical_pap_display_thread = RepeatTimer(self.update_vis_time_pap, self.periodical_pap_display_callback)\n\n        self.stop_event_pap_display_thread = threading.Event()\n        self.periodical_pap_display_thread = TimerThread(self.stop_event_pap_display_thread, self.update_vis_time_pap)\n        self.periodical_pap_display_thread.update.connect(self.periodical_pap_display_callback)\n        self.periodical_pap_display_thread.start()\n        #self.periodical_pap_display_thread = QTimer()\n        #self.periodical_pap_display_thread.timeout.connect(self.periodical_pap_display_callback)\n        #self.periodical_pap_display_thread.start(1000)\n        print(f\"[DEBUG]: This {self.myhelpera2g.ID} started thread periodical_pap_display\")\n\n    def stop_meas_button_callback(self):\n        \"\"\"\n        Callback for when the user presses the \"STOP\" button. Sends a ``STOPDRONERFSOC`` command to the drone, to stop its rfsoc thread.\n        \"\"\"\n\n        self.myhelpera2g.socket_send_cmd(type_cmd='STOPDRONERFSOC')\n        print(\"[DEBUG]: SENT REQUEST to STOP measurement\")\n        self.start_meas_togglePushButton.setEnabled(True)\n        self.stop_meas_togglePushButton.setEnabled(False)\n        self.finish_meas_togglePushButton.setEnabled(True)\n        self.stop_event_pap_display_thread.set()\n\n    def finish_meas_button_callback(self):\n        \"\"\"\n        Callback for when the user presses the \"FINISH\" button. Sends a ``FINISHDRONERFSOC`` command to the drone, to stop its rfsoc thread.\n        \"\"\"\n\n        self.myhelpera2g.socket_send_cmd(type_cmd='FINISHDRONERFSOC')\n        print(\"[DEBUG]: SENT REQUEST to FINISH measurement\")\n\n        datestr = datetime.datetime.now()\n        datestr = datestr.strftime('%Y-%m-%d-%H-%M-%S')\n\n        current_text = self.meas_description_text_edit.document().toPlainText()\n        if self.myhelpera2g.IsGimbal!=0:\n            if hasattr(self.myhelpera2g, 'myGimbal'):\n                current_text = current_text + f\"\\nYaw at pressing FINISH: {self.myhelpera2g.myGimbal.yaw}\" + '\\n' + f\"Pitch at pressing FINISH: {self.myhelpera2g.myGimbal.pitch}\"\n        with open('description_' + datestr + '.txt', 'a+') as file:\n            file.write(current_text)\n\n        print(\"[DEBUG]: Saved description file on GND node\")\n\n        self.start_meas_togglePushButton.setEnabled(True)\n        self.stop_meas_togglePushButton.setEnabled(False)\n        self.finish_meas_togglePushButton.setEnabled(False)\n\n        if hasattr(self, 'periodical_gimbal_follow_thread'):\n            if self.periodical_gimbal_follow_thread.isRunning():\n                self.stop_event_gimbal_follow_thread.set()\n        if hasattr(self, 'periodical_gps_display_thread'):\n            if self.periodical_gps_display_thread.isActive():\n                    self.periodical_gps_display_thread.stop()\n\n    def create_Planning_Measurements_panel(self):\n        \"\"\"\n        Creates the \"Control measurements\" panel with its widgets and layout.\n        \"\"\"\n\n        self.planningMeasurementsPanel = QGroupBox('Control measurements')\n\n        self.start_meas_togglePushButton = QPushButton(\"START\")\n        self.start_meas_togglePushButton.setEnabled(False)\n        self.start_meas_togglePushButton.clicked.connect(self.start_meas_button_callback)\n\n        self.stop_meas_togglePushButton = QPushButton(\"STOP\")\n        self.stop_meas_togglePushButton.setEnabled(False)\n        self.stop_meas_togglePushButton.clicked.connect(self.stop_meas_button_callback)\n\n        self.finish_meas_togglePushButton = QPushButton(\"FINISH\")\n        self.finish_meas_togglePushButton.setEnabled(False)\n        self.finish_meas_togglePushButton.clicked.connect(self.finish_meas_button_callback)\n\n        self.meas_description_text_edit = QPlainTextEdit('')\n        self.meas_description_text_edit.setPlaceholderText(\"Enter measurement description here\")\n\n        layout = QGridLayout()\n        layout.addWidget(self.meas_description_text_edit, 0, 0, 3, 6)\n\n        layout.addWidget(self.start_meas_togglePushButton, 0, 6, 1, 2)\n        layout.addWidget(self.stop_meas_togglePushButton, 1, 6, 1, 2)\n        layout.addWidget(self.finish_meas_togglePushButton, 2, 6, 1, 2)\n\n        self.planningMeasurementsPanel.setLayout(layout)\n\n    def create_GPS_visualization_panel(self):\n        \"\"\"\n        Creates the GPS visuzliation panel. The ``gps_start_point_in_finland_json`` can be set to any coordinate.\n\n        Requires the ``gpsRESTHandler.py`` file where the REST API for the gps is implemented.\n        \"\"\"\n\n        self.gps_vis_panel = QGroupBox('GPS visualization')\n\n        # This starting point can be anything, as it will be updated throught the PUT requests\n        gps_start_point_json = {\"lat\": 60.15301542729288, \"lon\": 24.316255998379482}\n\n        response = requests.post(self.url_post_map, json=gps_start_point_json)\n\n        time.sleep(0.05)\n\n        js_handler_of_non_geoson = JsCode(\"\"\"\n        function(responseHandler, errorHandler) {\n            let url =\"\"\"+self.url_get_map+\"\"\";\n\n            fetch(url)\n            .then((response) =&gt; {\n                return response.json().then((data) =&gt; {\n                    var {lat, lon } = data;\n                    var id=45;\n                    return {\n                        \"type\": \"FeatureCollection\",\n                        \"features\": [{\n                            \"type\": \"Feature\",\n                            \"geometry\": {\n                                \"type\": \"Point\",\n                                \"coordinates\": [lon, lat]\n                            },\n                            \"properties\": {\n                                \"id\": id\n                            }\n                        }]\n                    };\n                })\n            })\n            .then(responseHandler)\n            .catch(errorHandler);\n        }\n        \"\"\")\n\n        self.gps_map = folium.Map()\n        self.map_rt_foilum_plugin = realtime.Realtime(js_handler_of_non_geoson, interval=5000)\n        self.map_rt_foilum_plugin.add_to(self.gps_map)\n\n        self.webview = QWebEngineView()\n        self.webview.setHtml(self.gps_map._repr_html_())\n\n        tx_info_label = QLabel('TX')\n        rx_info_label = QLabel('RX')\n\n        tx_info_label.setAlignment(Qt.AlignCenter)\n        rx_info_label.setAlignment(Qt.AlignCenter)\n\n        tx_x_label = QLabel('X:')\n        tx_y_label = QLabel('Y:')\n        tx_z_label = QLabel('Z:')\n        tx_x_value_label = QLabel('')\n        tx_y_value_label = QLabel('')\n        tx_z_value_label = QLabel('')\n\n        rx_x_label = QLabel('X:')\n        rx_y_label = QLabel('Y:')\n        rx_z_label = QLabel('Z:')\n        rx_x_value_label = QLabel('')\n        rx_y_value_label = QLabel('')\n        rx_z_value_label = QLabel('')\n\n        layout = QGridLayout()\n        layout.addWidget(self.webview, 0, 0, 8, 10)\n        layout.addWidget(tx_info_label, 8, 0, 1, 5)\n        layout.addWidget(rx_info_label, 8, 5, 1, 5)\n        layout.addWidget(tx_x_label, 9, 0, 1, 1)\n        layout.addWidget(tx_z_label, 10, 0, 1, 1)\n        layout.addWidget(tx_y_label, 11, 0, 1, 1)\n        layout.addWidget(tx_x_value_label, 9, 1, 1, 4)\n        layout.addWidget(tx_y_value_label, 10, 1, 1, 4)\n        layout.addWidget(tx_z_value_label, 11, 1, 1, 4)\n        layout.addWidget(rx_x_label, 9, 5, 1, 1)\n        layout.addWidget(rx_z_label, 10, 5, 1, 1)\n        layout.addWidget(rx_y_label, 11, 5, 1, 1)\n        layout.addWidget(rx_x_value_label, 9, 6, 1, 4)\n        layout.addWidget(rx_y_value_label, 10, 6, 1, 4)\n        layout.addWidget(rx_z_value_label, 11, 6, 1, 4)\n\n        # Set the layout of the group box\n        self.gps_vis_panel.setLayout(layout)\n\n    def create_pap_plot_panel(self):\n        \"\"\"\n        Creates the \"PAP\" panel (responsible for ploting the Power Angular Profile of the measured CIRs).\n        \"\"\"\n\n        self.papPlotPanel = QGroupBox('PAP')\n        self.time_snaps = 22\n        self.plot_widget = pg.PlotWidget() \n        self.plot_widget.setLabel('left', 'Beam steering angle [deg]')\n        self.plot_widget.setLabel('bottom', 'Time snapshot number')\n\n        layout = QVBoxLayout()\n        layout.addWidget(self.plot_widget)\n        self.papPlotPanel.setLayout(layout)\n\n        rx_sivers_beam_index_mapping_file = open('data/rx_sivers_beam_index_mapping.csv')\n        csvreader = csv.reader(rx_sivers_beam_index_mapping_file)\n        beam_idx_map = [float(i[1]) for cnt,i in enumerate(csvreader) if cnt != 0]\n        ticksla = beam_idx_map[::4]\n        self.beam_angs = ticksla\n        ticks = np.arange(0,16) \n        y_ticks = [(ticks[cnt], f'{tickla:1.2f}\u00b0') for cnt, tickla in enumerate(ticksla)]\n        self.plot_widget.getAxis('left').setTicks([y_ticks, []])\n\n        x_ticks = [(i, str(i)) for i in np.arange(self.time_snaps)]\n        self.plot_widget.getAxis('bottom').setTicks([x_ticks, []])\n\n    def closeEvent(self, event):\n        if hasattr(self, 'myhelpera2g'):\n            self.myhelpera2g.HelperA2GStopCom(DISC_WHAT='ALL')\n        #if hasattr(self, 'periodical_pap_display_thread'):\n            #self.periodical_pap_display_thread.cancel()\n            #self.periodical_pap_display_thread.stop()\n        if hasattr(self, 'periodical_gps_display_thread'):\n            if self.periodical_gps_display_thread.isActive():\n                self.periodical_gps_display_thread.stop()\n        if hasattr(self, 'periodical_gimbal_follow_thread'):\n            if self.periodical_gimbal_follow_thread.isRunning():\n                self.stop_event_gimbal_follow_thread.set()\n\n        # Last thing to do is to redirect the stdout\n        #sys.stdout = self.original_stdout\n\n    def eventFilter(self, source, event):\n        if event.type()== event.Close:\n            self.closeEvent(event)\n            return True\n\n        return super().eventFilter(source,event)\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.__init__","title":"<code>__init__(parent=None)</code>","text":"<p>Calls the functions to create some class attributes and the menu bar with its associated callbacks.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>none</code> <p>not used, but required. Defaults to None.</p> <code>None</code> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def __init__(self, parent=None):\n    \"\"\"\n    Calls the functions to create some class attributes and the menu bar with its associated callbacks.\n\n    Args:\n        parent (none, optional): not used, but required. Defaults to None.\n    \"\"\"\n\n    super(WidgetGallery, self).__init__(parent)\n\n    self.setWindowTitle(\"A2G Measurements Center\")\n\n    self.init_constants()\n\n    self.createMenu()\n\n    self.dummyWidget = QWidget()\n    self.setCentralWidget(self.dummyWidget)\n    #self.setLayout(mainLayout)\n\n    self.showMaximized()\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.activate_gps_display_flag","title":"<code>activate_gps_display_flag()</code>","text":"<p>Toggles the <code>gps_display_flag</code></p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def activate_gps_display_flag(self):\n    \"\"\"\n    Toggles the ``gps_display_flag``\n    \"\"\"\n    if self.gps_display_flag:\n        self.gps_display_flag = False\n    else:\n        self.gps_display_flag = True\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.activate_rs2_fm_flag","title":"<code>activate_rs2_fm_flag()</code>","text":"<p>Toggles the <code>rs2_fm_flag</code></p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def activate_rs2_fm_flag(self):   \n    \"\"\"\n    Toggles the ``rs2_fm_flag``\n    \"\"\"     \n\n    if self.rs2_fm_flag:\n        self.rs2_fm_flag = False\n    else:\n        self.rs2_fm_flag = True\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.check_if_drone_fpga_connected","title":"<code>check_if_drone_fpga_connected(drone_fpga_static_ip_addr='10.1.1.40')</code>","text":"<p>Checks if the rfsoc is detected on the drone. </p> <p>Caller function SHOULD check first if there is an SSH connection.</p> <p>Parameters:</p> Name Type Description Default <code>drone_fpga_static_ip_addr</code> <code>str</code> <p>drone's RFSoC IP address for the Ethernet interface. Defaults to '10.1.1.40'.</p> <code>'10.1.1.40'</code> <p>Returns:</p> Name Type Description <code>success_drone_fpga</code> <code>bool</code> <p>True if the ping to the rfsoc IP address (Ethernet interface) is replied.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def check_if_drone_fpga_connected(self, drone_fpga_static_ip_addr='10.1.1.40'):\n    \"\"\"\n    Checks if the rfsoc is detected on the drone. \n\n    Caller function SHOULD check first if there is an SSH connection.\n\n    Args:\n        drone_fpga_static_ip_addr (str, optional): drone's RFSoC IP address for the Ethernet interface. Defaults to '10.1.1.40'.\n\n    Returns:\n        success_drone_fpga (bool): True if the ping to the rfsoc IP address (Ethernet interface) is replied.\n    \"\"\"\n\n    # Execute the command and obtain the input, output, and error streams\n    stdin, stdout, stderr = self.remote_drone_conn.exec_command('ping ' + drone_fpga_static_ip_addr)\n\n    # Read the output from the command\n    output = stdout.read().decode('utf-8')\n    error = stderr.read().decode('utf-8')\n\n    expected_str_out = \"Reply from \" + drone_fpga_static_ip_addr\n    # Print the output and error, if any\n    if expected_str_out in output:\n        print(\"[DEBUG]: RFSoC detected at DRONE node\")\n        success_drone_fpga = True\n    else:\n        success_drone_fpga = False\n    if error:\n        print(f\"Command error:\\n{error}\")\n        response_drone_fpga = None\n\n    return success_drone_fpga\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.check_if_drone_gimbal_connected","title":"<code>check_if_drone_gimbal_connected()</code>","text":"<p>Checks if a gimbal (Ronin RS2 or Gremsy H16) is connected to the host computer of the drone node.</p> <p>Returns:</p> Name Type Description <code>success_drone_gimbal</code> <code>bool</code> <p>True if the gimbal is detected, False if not. None if an error appeared.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def check_if_drone_gimbal_connected(self):\n    \"\"\"\n    Checks if a gimbal (Ronin RS2 or Gremsy H16) is connected to the host computer of the drone node.\n\n    Returns:\n        success_drone_gimbal (bool): True if the gimbal is detected, False if not. None if an error appeared.\n    \"\"\"\n    if self.remote_drone_conn is None:\n        success_drone_gimbal = None\n        print('[DEBUG]: No SSH connection to drone detected. The drone gps connection check can not be done.')\n    else:\n        try:\n            stdin, stdout, stderr = self.remote_drone_conn.exec_command('PowerShell')\n            stdin.channel.send(\"Get-PnpDevice -PresentOnly | Where-Object { $_.InstanceId -match '^USB' } | Format-List\\n\")\n            stdin.channel.shutdown_write()\n            usb_list_str = stdout.read().decode('utf-8')\n\n            # Exit the PowerShell\n            stdin, stdout, stderr = self.remote_drone_conn.exec_command('exit')\n        except Exception as e:\n            print(\"[DEBUG]: Error encountered executing the Gimbal check commands on drone\")\n            print(\"[DEBUG]: \", e)\n            success_drone_gimbal = None\n        else:\n            if self.droneGimbalChoice == \"DJI Ronin RS2\":\n                if 'PCAN-USB' in usb_list_str:\n                    success_drone_gimbal = True\n                    print(\"[DEBUG]: Ronin RS2 is detected at DRONE\")\n                else:\n                    success_drone_gimbal = False\n                    print(\"[DEBUG]: Ronin RS2 is NOT detected at DRONE\")\n            elif self.droneGimbalChoice == \"Gremsy H16\":\n                if 'USB Serial Converter' in usb_list_str:\n                    success_drone_gimbal = True\n                    print(\"[DEBUG]: Gremsy Gimbal is detected at DRONE\")\n                else:\n                    success_drone_gimbal = False\n                    print(\"[DEBUG]: Gremsy Gimbal is NOT detected at DRONE\")\n\n    return success_drone_gimbal\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.check_if_drone_gps_connected","title":"<code>check_if_drone_gps_connected()</code>","text":"<p>Checks if a Septentrio gps is connected to the host computer of the drone node.</p> <p>Requires that there is a SSH connection already established.</p> <p>Returns:</p> Name Type Description <code>success_drone_gps</code> <code>bool</code> <p>True if connected, False if not, None if no SSH connection.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def check_if_drone_gps_connected(self):\n    \"\"\"\n    Checks if a Septentrio gps is connected to the host computer of the drone node.\n\n    Requires that there is a SSH connection already established.\n\n    Returns:\n        success_drone_gps (bool): True if connected, False if not, None if no SSH connection.\n    \"\"\"\n\n    # Double check\n    if self.remote_drone_conn is None:\n        success_drone_gps = None\n        print('[DEBUG]: No SSH connection to drone detected. The drone gps connection check can not be done.')\n    else:\n        try:\n            stdin, stdout, stderr = self.remote_drone_conn.exec_command('PowerShell')\n            stdin.channel.send(\"Get-PnpDevice -PresentOnly | Where-Object { $_.InstanceId -match '^USB' } | Format-List\\n\")\n            stdin.channel.shutdown_write()\n            usb_list_str = stdout.read().decode('utf-8')\n\n            # Exit the PowerShell\n            stdin, stdout, stderr = self.remote_drone_conn.exec_command('exit')\n        except Exception as e:\n            print(\"[DEBUG]: Error encountered executing the GPS check commands on drone\")\n            print(\"[DEBUG]: \", e)\n            success_drone_gps = None\n        else:\n            if 'Septentrio' in usb_list_str:\n                success_drone_gps = True\n                print(\"[DEBUG]: GPS is detected at DRONE\")\n            else:\n                success_drone_gps = False\n                print(\"[DEBUG]: GPS is NOT detected at DRONE\")                \n\n    return success_drone_gps\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.check_if_gnd_fpga_connected","title":"<code>check_if_gnd_fpga_connected(gnd_fpga_static_ip_addr='10.1.1.30')</code>","text":"<p>Check if the rfsoc is detected on the ground node.</p> <p>Parameters:</p> Name Type Description Default <code>gnd_fpga_static_ip_addr</code> <code>str</code> <p>ground's RFSoC IP address for the Ethernet interface. Defaults to '10.1.1.30'.</p> <code>'10.1.1.30'</code> <p>Returns:</p> Name Type Description <code>success_ping_gnd_fpga</code> <code>bool</code> <p>True if ping is successful, False otherwise.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def check_if_gnd_fpga_connected(self, gnd_fpga_static_ip_addr='10.1.1.30'):\n    \"\"\"\n    Check if the rfsoc is detected on the ground node.\n\n    Args:\n        gnd_fpga_static_ip_addr (str, optional): ground's RFSoC IP address for the Ethernet interface. Defaults to '10.1.1.30'.\n\n    Returns:\n        success_ping_gnd_fpga (bool): True if ping is successful, False otherwise.\n    \"\"\"\n\n    try:\n        success_ping_gnd_fpga = ping3.ping(gnd_fpga_static_ip_addr, timeout=7)\n    except Exception as e:\n        print(\"[DEBUG]: Error in ping \", e)\n        print(\"[DEBUG]: RFSoC is NOT detected at GND node\")\n        success_ping_gnd_fpga = False\n        return\n\n    if success_ping_gnd_fpga is not None or success_ping_gnd_fpga:\n        print(\"[DEBUG]: RFSoC is detected at GND node\")\n        success_ping_gnd_fpga = True\n    else:\n        print(\"[DEBUG]: RFSoC is NOT detected at GND node\")\n        success_ping_gnd_fpga = False\n\n    return success_ping_gnd_fpga\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.check_if_gnd_gimbal_connected","title":"<code>check_if_gnd_gimbal_connected()</code>","text":"<p>Checks if a Ronin RS2 gimbal is connected to the host computer of the ground node.</p> <p>Returns:</p> Name Type Description <code>success_gnd_gimbal</code> <code>bool</code> <p>True if a PCAN device is detected, False otherwise.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def check_if_gnd_gimbal_connected(self):\n    \"\"\"\n    Checks if a Ronin RS2 gimbal is connected to the host computer of the ground node.\n\n    Returns:\n        success_gnd_gimbal (bool): True if a PCAN device is detected, False otherwise.\n    \"\"\"\n\n    try:\n        # Check if gimbal is connected by looking if connection is established\n        bus = can.interface.Bus(interface=\"pcan\", channel=\"PCAN_USBBUS1\", bitrate=1000000)\n    except Exception as e:\n        success_gnd_gimbal = False\n    else:\n        bus.shutdown()\n        del bus\n        success_gnd_gimbal = True\n\n    return success_gnd_gimbal\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.check_if_gnd_gps_connected","title":"<code>check_if_gnd_gps_connected()</code>","text":"<p>Checks if a Septentrio gps is connected to the host computer of the ground node.</p> <p>Returns:</p> Name Type Description <code>success_gnd_gps</code> <code>bool</code> <p>True if a gps is detected, False otherwise.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def check_if_gnd_gps_connected(self):\n    \"\"\"\n    Checks if a Septentrio gps is connected to the host computer of the ground node.\n\n    Returns:\n        success_gnd_gps (bool): True if a gps is detected, False otherwise.\n    \"\"\"\n\n    tmp = []\n    for (_, desc, _) in sorted(comports()):\n        tmp.append(\"Septentrio\" in desc)\n    if any(tmp):\n        success_gnd_gps = True\n        print(\"[DEBUG]: GPS is detected at GND\")\n    else:\n        success_gnd_gps = False\n        print(\"[DEBUG]: GPS is NOT detected at GND\")\n\n    return success_gnd_gps        \n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.check_if_server_running_drone_fpga","title":"<code>check_if_server_running_drone_fpga()</code>","text":"<p>Checks if the server.py daemon is running on drone's RFSoC (the PS of the RFSoC). If it is not running, this function starts it.</p> <p>ASSUMES DRONE RFSOC IP STATIC ADDR FOR ETH INTERFACE IS 10.1.1.40 (THIS IS THE DEFAULT SETUP)</p> <p>Returns:</p> Name Type Description <code>success_server_drone_fpga</code> <code>bool</code> <p>True if the server.py daemon is running. False if not. None if the daemon could not be started.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def check_if_server_running_drone_fpga(self):\n    \"\"\"\n    Checks if the server.py daemon is running on drone's RFSoC (the PS of the RFSoC). If it is not running, this function starts it.\n\n    ASSUMES DRONE RFSOC IP STATIC ADDR FOR ETH INTERFACE IS 10.1.1.40 (THIS IS THE DEFAULT SETUP)\n\n    Returns:\n        success_server_drone_fpga (bool): True if the server.py daemon is running. False if not. None if the daemon could not be started.\n    \"\"\"\n\n    if self.remote_drone_conn is None:\n        print('[DEBUG]: No SSH connection to drone detected. The server-running-on-drone check can not be done.')\n        success_server_drone_fpga = False\n    else:\n        try:\n            shell = self.remote_drone_conn.invoke_shell()\n            while(shell.recv_ready() == False):\n                time.sleep(0.1)\n            out_now = shell.recv(65535).decode('utf-8')\n\n            shell.send(\"ssh xilinx@10.1.1.40\\r\\n\")\n            while(shell.recv_ready() == False):\n                time.sleep(0.1)\n            out_now = shell.recv(65535).decode('utf-8')\n\n            aux = \"Permission denied, please try again\"\n            cnt=1\n            while((\"Permission denied, please try again\" in aux) and cnt&lt;10):\n                shell.send(\"xilinx\\r\\n\")\n                while(shell.recv_ready() == False):\n                    time.sleep(0.1)\n                out_now = shell.recv(65535).decode('utf-8')\n                aux = out_now\n                cnt = cnt +1\n            if cnt == 10:\n                print(\"[DEBUG]: Unsuccesfull check of drone fpga server. Please CHECK IT MANUALLY on the drone\")\n                success_server_drone_fpga = False\n                return success_server_drone_fpga\n\n            aux = \"xilinx: command not found\"\n            cnt=1\n            while((\"xilinx: command not found\" in aux) and cnt&lt;10):\n                shell.send(\"ps aux | grep mmwsdr\\r\\n\")\n                while(shell.recv_ready() == False):\n                    time.sleep(0.1)\n                out_now = shell.recv(65535).decode('utf-8')\n                aux=out_now\n                cnt=cnt+1\n            if cnt == 10:\n                print(\"[DEBUG]: Unsuccesfull check of drone fpga server. Please CHECK IT MANUALLY on the drone\")\n                success_server_drone_fpga = False\n                return success_server_drone_fpga\n\n            #shell.close()\n        except Exception as e:\n            print(f\"[DEBUG]:Error when trying to check if server is running on drone fpga: {e}\")\n            success_server_drone_fpga = None\n            return success_server_drone_fpga\n\n        if 'server.py'in out_now and 'run.sh' in out_now:\n            print(\"[DEBUG]: Server script is running on DRONE fpga\")\n        else:\n            print(\"[DEBUG]: Server script is not running on DRONE fpga\")\n            print(\"[DEBUG]: Starting server daemon on DRONE fpga\")\n            try:\n                # The shell is not closed                    \n                shell.send(\"cd jupyter_notebook/mmwsdr\\r\\n\")\n                while(shell.recv_ready() == False):\n                    time.sleep(0.1)\n                out_now = shell.recv(65535).decode('utf-8')\n\n                shell.send(\"sudo ./run.sh\\r\\n\")\n                while(shell.recv_ready() == False):\n                    time.sleep(0.1)\n                out_now = shell.recv(65535).decode('utf-8')\n\n                shell.send(\"xilinx\\r\\n\")\n                while(shell.recv_ready() == False):\n                    time.sleep(0.1)\n                out_now = shell.recv(65535).decode('utf-8')\n\n                shell.close()\n\n                print(\"[DEBUG]: Server daemon on drone fpga has started\")\n                success_server_drone_fpga = True\n            except Exception as e:\n                print(f\"This error occurred when trying to init daemon server on drone fpga: {e}\")\n                success_server_drone_fpga = None\n                return success_server_drone_fpga\n    return success_server_drone_fpga\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.check_if_server_running_gnd_fpga","title":"<code>check_if_server_running_gnd_fpga()</code>","text":"<p>Checks if the server.py daemon is running on ground's RFSoC (the PS of the RFSoC). If it is not running, this function starts it.</p> <p>ASSUMES GROUND RFSOC IP STATIC ADDR FOR ETH INTERFACE IS 10.1.1.30 (THIS IS THE DEFAULT SETUP)</p> <p>Returns:</p> Name Type Description <code>success_server_gnd_fpga</code> <code>bool</code> <p>True if the server.py daemon is running on ground's RFSoC. False otherwise.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def check_if_server_running_gnd_fpga(self):\n    \"\"\"\n    Checks if the server.py daemon is running on ground's RFSoC (the PS of the RFSoC). If it is not running, this function starts it.\n\n    ASSUMES GROUND RFSOC IP STATIC ADDR FOR ETH INTERFACE IS 10.1.1.30 (THIS IS THE DEFAULT SETUP)\n\n    Returns:\n        success_server_gnd_fpga (bool): True if the server.py daemon is running on ground's RFSoC. False otherwise.\n    \"\"\"\n\n    try:\n        conn_gnd_fpga = paramiko.SSHClient()\n        conn_gnd_fpga.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n        conn_gnd_fpga.connect('10.1.1.30', username='xilinx', password='xilinx')\n    except Exception as e:\n        print(f\"This error occurred when trying to check if server is running on GND fpga: {e}\")\n        success_server_gnd_fpga = False\n        return success_server_gnd_fpga\n    try:\n        stdin, stdout, stderr = conn_gnd_fpga.exec_command('ps aux | grep mmwsdr')\n        output = stdout.read().decode()\n\n        if stderr.read().decode() == '' and 'server.py' in output and 'run.sh' in output:\n            print(\"[DEBUG]: Server script is running on GND fpga\")\n        else:\n            print(\"[DEBUG]: Server script is not running on GND fpga\")\n            conn_gnd_fpga.exec_command('cd jupyter_notebooks/mmwsdr')\n            stdin, stdout, stderr = conn_gnd_fpga.exec_command('sudo ./run.sh')\n            stdin.channel.send(\"xilinx\\n\")\n            stdin.channel.shutdown_write()\n            print(\"[DEBUG]: GND node has started the Server Daemon in its FPGA\")\n    except Exception as e:\n        print(\"[DEBUG]: Could not check if Server script is running in this node FPGA\")\n        success_server_gnd_fpga = False\n        return success_server_gnd_fpga\n\n    success_server_gnd_fpga = True\n\n    # Close this connection\n    conn_gnd_fpga.close()\n\n    return success_server_gnd_fpga\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.check_if_ssh_2_drone_reached","title":"<code>check_if_ssh_2_drone_reached(drone_ip, username, password)</code>","text":"<p>Checks if it is possible to ping and establish an SSH connection betwwen the host computer of the ground node and the host computer of the drone node.</p> <p>Error checking of the input parameters SHOULD BE DONE by the caller function.</p> <p>Parameters:</p> Name Type Description Default <code>drone_ip</code> <code>str</code> <p>drone's IP address for the WiFi interface.</p> required <code>username</code> <code>str</code> <p>SSH username</p> required <code>password</code> <code>str</code> <p>SSH password</p> required <p>Returns:</p> Name Type Description <code>success_ping_network</code> <code>bool</code> <p>True if drone node is reachable.</p> <code>success_air_node_ssh</code> <code>bool</code> <p>True if ssh connection can be established.</p> <code>success_drone_fpga</code> <code>bool</code> <p>True if rfsoc on drone is detected.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def check_if_ssh_2_drone_reached(self, drone_ip, username, password):\n    \"\"\"\n    Checks if it is possible to ping and establish an SSH connection betwwen the host computer of the ground node and the host computer of the drone node.\n\n    Error checking of the input parameters SHOULD BE DONE by the caller function.\n\n    Args:\n        drone_ip (str): drone's IP address for the WiFi interface.\n        username (str): SSH username\n        password (str): SSH password\n\n    Returns:\n        success_ping_network (bool): True if drone node is reachable.\n        success_air_node_ssh (bool): True if ssh connection can be established.\n        success_drone_fpga (bool): True if rfsoc on drone is detected.\n    \"\"\"\n\n    try:\n        success_ping_network = ping3.ping(drone_ip, timeout=10)\n    except Exception as e:\n        print(\"[DEBUG]: Error in ping \", e)\n        success_ping_network = False\n\n    #if success_ping_network is not None:\n    if success_ping_network:\n        success_ping_network = True\n        print(\"[DEBUG]: DRONE-AP-GND Network is reachable\")\n        if self.remote_drone_conn is None:\n            try:\n                remote_drone_conn = paramiko.SSHClient()\n                remote_drone_conn.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n                remote_drone_conn.connect(drone_ip, username=username, password=password)\n                print(\"[DEBUG]: SSH connection to DRONE is successful.\")            \n            except paramiko.AuthenticationException:\n                print(\"SSH Authentication failed. Please check your credentials.\")\n                success_air_node_ssh = False\n                self.remote_drone_conn = None\n                success_drone_fpga = None\n                return success_ping_network, success_air_node_ssh, success_drone_fpga\n            except paramiko.SSHException as ssh_exception:\n                print(f\"Unable to establish SSH connection: {ssh_exception}\")\n                success_air_node_ssh = False\n                self.remote_drone_conn = None\n                success_drone_fpga = None\n                return success_ping_network, success_air_node_ssh, success_drone_fpga\n            except Exception as e:\n                print(f\"An error occurred: {e}\")\n                success_air_node_ssh = False\n                self.remote_drone_conn = None\n                success_drone_fpga = None\n                return success_ping_network, success_air_node_ssh, success_drone_fpga\n\n            self.remote_drone_conn = remote_drone_conn\n\n        # Will execute either if 'try' statemente success or if self.remote_drone_conn is precisely None\n        success_air_node_ssh = True            \n        success_drone_fpga = self.check_if_drone_fpga_connected()\n    else:\n        print(\"[DEBUG]: DRONE-AP-GND Network is NOT reachable\")\n        success_ping_network = False\n        success_air_node_ssh = None\n        success_drone_fpga = None\n        self.remote_drone_conn = None\n\n    return success_ping_network, success_air_node_ssh, success_drone_fpga\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.check_status_all_devices","title":"<code>check_status_all_devices()</code>","text":"<p>Callback for when user presses the \"Check\" button. Gets the connection status of all devices.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def check_status_all_devices(self):\n    \"\"\"\n    Callback for when user presses the \"Check\" button. Gets the connection status of all devices.\n    \"\"\"\n\n    pattern_ip_addresses = r'[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}'\n    self.DRONE_ADDRESS = self.air_ip_addr_value_text_edit.text()\n    is_ip_addr = bool(re.match(pattern_ip_addresses, self.DRONE_ADDRESS))\n\n    # Input error checking\n    if self.DRONE_ADDRESS == '' or not is_ip_addr:\n        print('[DEBUG]: No DRONE or incorrect IP address supplied')\n        self.network_exists_label_modifiable.setText(str(None))\n        self.ssh_conn_gnd_2_drone_label_modifiable.setText(str(None))\n        self.drone_rfsoc_conn_label_modifiable.setText(str(None))\n    else:\n        SUCCESS_PING_DRONE, SUCCESS_SSH, SUCCESS_DRONE_FPGA = self.check_if_ssh_2_drone_reached(self.DRONE_ADDRESS, \"manifold-uav-vtt\", \"mfold2208\")\n        SUCCESS_DRONE_GPS = self.check_if_drone_gps_connected()\n        SUCCES_DRONE_GIMBAL = self.check_if_drone_gimbal_connected()\n        self.network_exists_label_modifiable.setText(str(SUCCESS_PING_DRONE))\n        self.ssh_conn_gnd_2_drone_label_modifiable.setText(str(SUCCESS_SSH))\n        self.drone_rfsoc_conn_label_modifiable.setText(str(SUCCESS_DRONE_FPGA))\n        self.drone_gps_conn_label_modifiable.setText(str(SUCCESS_DRONE_GPS))\n        self.drone_gimbal_conn_label_modifiable.setText(str(SUCCES_DRONE_GIMBAL))\n        self.SUCCESS_PING_DRONE = SUCCESS_PING_DRONE\n        self.SUCCESS_SSH = SUCCESS_SSH\n        self.SUCCESS_DRONE_FPGA = SUCCESS_DRONE_FPGA\n        self.SUCCESS_DRONE_GPS = SUCCESS_DRONE_GPS\n        self.SUCCES_DRONE_GIMBAL = SUCCES_DRONE_GIMBAL\n\n    SUCCESS_GND_FPGA = self.check_if_gnd_fpga_connected()\n    SUCCESS_GND_GIMBAL = self.check_if_gnd_gimbal_connected()        \n    SUCCESS_GND_GPS = self.check_if_gnd_gps_connected()\n    #SUCCESS_DRONE_SERVER_FPGA = self.check_if_server_running_drone_fpga()\n    #SUCCESS_GND_SERVER_FPGA = self.check_if_server_running_gnd_fpga()\n    SUCCESS_DRONE_SERVER_FPGA = None\n    SUCCESS_GND_SERVER_FPGA = None\n\n    self.get_gnd_ip_node_address()\n    self.gnd_gimbal_conn_label_modifiable.setText(str(SUCCESS_GND_GIMBAL))\n    self.gnd_gps_conn_label_modifiable.setText(str(SUCCESS_GND_GPS))\n    self.gnd_rfsoc_conn_label_modifiable.setText(str(SUCCESS_GND_FPGA))\n    self.server_drone_fpga_label_modifiable.setText(str(SUCCESS_DRONE_SERVER_FPGA))\n    self.server_gnd_fpga_label_modifiable.setText(str(SUCCESS_GND_SERVER_FPGA))\n\n    if hasattr(self, 'GND_ADDRESS'):\n        self.gnd_ip_addr_value_label.setText(self.GND_ADDRESS)\n    else:\n        self.GND_ADDRESS =  ''\n\n    self.SUCCESS_GND_FPGA = SUCCESS_GND_FPGA\n    self.SUCCESS_GND_GIMBAL = SUCCESS_GND_GIMBAL\n    self.SUCCESS_GND_GPS = SUCCESS_GND_GPS\n\n    if self.SUCCESS_SSH and self.SUCCESS_PING_DRONE:\n        self.connect_to_drone.setEnabled(True)\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.checker_gimbal_input_range","title":"<code>checker_gimbal_input_range(angle)</code>","text":"<p>Checks if a given angle is within the allowed range.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>angle in degrees.</p> required <p>Returns:</p> Name Type Description <code>incorrect_angle_value</code> <code>bool</code> <p>True if the angle is within the allowed range, False otherwise.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def checker_gimbal_input_range(self, angle):\n    \"\"\"\n    Checks if a given angle is within the allowed range.\n\n    Args:\n        angle (float): angle in degrees.\n\n    Returns:\n        incorrect_angle_value (bool): True if the angle is within the allowed range, False otherwise.\n    \"\"\"\n\n    incorrect_angle_value = False\n    if angle &gt; 180 or angle &lt; -180:\n        print(\"[DEBUG]: Angle value outside of range\")\n        incorrect_angle_value = True\n\n    return incorrect_angle_value\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.connect_drone_callback","title":"<code>connect_drone_callback()</code>","text":"<p>Callback for when the user presses the \"Connect\" button.</p> <p>Calls the <code>create_class_instance</code> method to create the Helper class in this (ground) node, depending on the availability of ground and drone devices.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def connect_drone_callback(self):\n    \"\"\"\n    Callback for when the user presses the \"Connect\" button.\n\n    Calls the ``create_class_instance`` method to create the Helper class in this (ground) node, depending on the availability of ground and drone devices. \n    \"\"\"\n\n    if self.SUCCESS_GND_GIMBAL and self.SUCCESS_GND_FPGA and self.SUCCESS_GND_GPS:\n        self.create_class_instances(IsGimbal=True, IsGPS=True, IsRFSoC=True)\n        self.start_meas_togglePushButton.setEnabled(True)\n        if self.SUCCESS_DRONE_GPS: \n            self.start_gps_visualization_action.setEnabled(True)\n            self.stop_gps_visualization_action.setEnabled(False)\n\n            # Only activate gnd FM actions if GND GIMBAL and GND GPS and DRONE GPS\n            self.start_gnd_gimbal_fm_action.setEnabled(True)\n            self.stop_gnd_gimbal_fm_action.setEnabled(False)\n        print(\"[DEBUG]: Class created at GND with Gimbal, GPS and RFSoC\")               \n    if self.SUCCESS_GND_GIMBAL and self.SUCCESS_GND_FPGA and not self.SUCCESS_GND_GPS:\n        self.create_class_instances(IsGimbal=True, IsRFSoC=True)\n        print(\"[DEBUG]: Class created at GND with Gimbal and RFSoC\")\n        self.start_meas_togglePushButton.setEnabled(True)\n    if self.SUCCESS_GND_GIMBAL and not self.SUCCESS_GND_FPGA and not self.SUCCESS_GND_GPS:\n        self.create_class_instances(IsGimbal=True)\n        self.start_meas_togglePushButton.setEnabled(False)\n        print(\"[DEBUG]: Class created at GND with Gimbal\")\n    if self.SUCCESS_GND_GIMBAL and not self.SUCCESS_GND_FPGA and self.SUCCESS_GND_GPS:\n        self.create_class_instances(IsGimbal=True, IsGPS=True)\n        self.start_meas_togglePushButton.setEnabled(False)\n        print(\"[DEBUG]: Class created at GND with Gimbal and GPS\")\n        if self.SUCCESS_DRONE_GPS:\n            self.start_gnd_gimbal_fm_action.setEnabled(True)\n            self.stop_gnd_gimbal_fm_action.setEnabled(False)\n        if self.SUCCESS_DRONE_GPS:\n            self.start_gps_visualization_action.setEnabled(True)\n            self.stop_gps_visualization_action.setEnabled(False)\n    if not self.SUCCESS_GND_GIMBAL and self.SUCCESS_GND_FPGA and self.SUCCESS_GND_GPS:\n        self.create_class_instances(IsGPS=True, IsRFSoC=True)\n        self.start_meas_togglePushButton.setEnabled(True)\n        print(\"[DEBUG]: Class created at GND with GPS and RFSoC\")\n        if self.SUCCESS_DRONE_GPS:\n            self.start_gps_visualization_action.setEnabled(True)\n            self.stop_gps_visualization_action.setEnabled(False)\n    if not self.SUCCESS_GND_GIMBAL and self.SUCCESS_GND_FPGA and not self.SUCCESS_GND_GPS:\n        self.create_class_instances(IsRFSoC=True)\n        self.start_meas_togglePushButton.setEnabled(True)\n        print(\"[DEBUG]: Class created at GND with RFSoC\")\n    if not self.SUCCESS_GND_GIMBAL and not self.SUCCESS_GND_FPGA and not self.SUCCESS_GND_GPS:\n        self.create_class_instances()\n        self.start_meas_togglePushButton.setEnabled(False)\n        print(\"[DEBUG]: Class created at GND with NO devices\")\n    if not self.SUCCESS_GND_GIMBAL and not self.SUCCESS_GND_FPGA and self.SUCCESS_GND_GPS:\n        self.create_class_instances(IsGPS=True)\n        self.start_meas_togglePushButton.setEnabled(False)\n        print(\"[DEBUG]: Class created at GND with GPS\")\n        if self.SUCCESS_DRONE_GPS:\n            self.start_gps_visualization_action.setEnabled(True)\n            self.stop_gps_visualization_action.setEnabled(False)\n\n    if self.SUCCES_DRONE_GIMBAL and self.SUCCESS_DRONE_GPS:\n        self.start_drone_gimbal_fm_action.setEnabled(True)\n        self.stop_drone_gimbal_fm_action.setEnabled(False)\n\n    self.stop_meas_togglePushButton.setEnabled(False)\n    self.finish_meas_togglePushButton.setEnabled(False)\n    self.connect_to_drone.setEnabled(False)\n    self.disconnect_from_drone.setEnabled(True)\n    self.setupDevicesAndMoreAction.setDisabled(True)\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.convert_dB_to_valid_hex_sivers_register_values","title":"<code>convert_dB_to_valid_hex_sivers_register_values()</code>","text":"<p>Converts the dB gain values (all of them) the user has input in the \"Sivers settings\" panel to the actual values required for the Sivers EVK registers.</p> <p>Returns:</p> Name Type Description <code>tx_signal_values</code> <code>dict</code> <p>dictionary with the Tx gain values to be set at the Tx Sivers EVK registers.</p> <code>rx_signal_values</code> <code>dict</code> <p>dictionary with the Rx gain values to be set at the RX Sivers EVK registers.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def convert_dB_to_valid_hex_sivers_register_values(self):\n    \"\"\"\n    Converts the dB gain values (all of them) the user has input in the \"Sivers settings\" panel to the actual values required for the Sivers EVK registers.\n\n    Returns:\n        tx_signal_values (dict): dictionary with the Tx gain values to be set at the Tx Sivers EVK registers.\n        rx_signal_values (dict): dictionary with the Rx gain values to be set at the RX Sivers EVK registers.\n    \"\"\"\n\n    rxbb1 = float(self.rx_bb_gain_1_text_edit.text())\n    rxbb2 = float(self.rx_bb_gain_2_text_edit.text())\n    rxbb3 = float(self.rx_bb_gain_3_text_edit.text())\n    rxbfrf = float(self.rx_bfrf_gain_text_edit.text())\n\n    txbb = self.tx_bb_gain_text_edit.text()\n    txbbiq = float(self.tx_bb_iq_gain_text_edit.text())\n    txbbphase = self.tx_bb_phase_text_edit.text()\n    txbf = float(self.tx_bfrf_gain_text_edit.text())\n\n    valid_values_rx_bb = [0x00, 0x11, 0x33, 0x77, 0xFF]\n    valid_values_rx_bb_dB = np.linspace(-6, 0, 5)\n\n    valid_values_rx_bb3_bf = [0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF]\n    valid_values_rx_bb3_dB = np.linspace(0,6,16)\n    valid_values_rx_bf_dB = np.linspace(0,15,16)\n\n    valid_values_tx_bbiq_bf = [0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF]\n    valid_values_tx_bbiq_dB = np.linspace(0,6,16)\n    valid_values_tx_bf_dB = np.linspace(0,15,16)        \n\n    tx_signal_values = {'tx_bb_gain':int(txbb,16), \n                        'tx_bb_iq_gain':valid_values_tx_bbiq_bf[np.abs(txbbiq - valid_values_tx_bbiq_dB).argmin()],\n                        'tx_bb_phase':int(txbbphase,16), \n                        'tx_bfrf_gain':valid_values_tx_bbiq_bf[np.abs(txbf - valid_values_tx_bf_dB).argmin()]}\n\n    rx_signal_values = {'rx_gain_ctrl_bb1': valid_values_rx_bb[np.abs(rxbb1 - valid_values_rx_bb_dB).argmin()],\n            'rx_gain_ctrl_bb2': valid_values_rx_bb[np.abs(rxbb2 - valid_values_rx_bb_dB).argmin()],\n            'rx_gain_ctrl_bb3': valid_values_rx_bb3_bf[np.abs(rxbb3 - valid_values_rx_bb3_dB).argmin()],\n            'rx_gain_ctrl_bfrf': valid_values_rx_bb3_bf[np.abs(rxbfrf - valid_values_rx_bf_dB).argmin()]}\n\n    return tx_signal_values, rx_signal_values\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.createMenu","title":"<code>createMenu()</code>","text":"<p>Creates the menu bar and associates the callback functions for when the user clicks on each of the menu items.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def createMenu(self):\n    \"\"\"\n    Creates the menu bar and associates the callback functions for when the user clicks on each of the menu items.          \n    \"\"\"\n\n    # Place the menus and actions here\n    menuBar = QMenuBar()\n    self.setMenuBar(menuBar)\n    setupMenu = menuBar.addMenu(\"&amp;Setup\")\n    threadsMenu = menuBar.addMenu(\"&amp;Threads\")\n\n    self.setupDevicesAndMoreAction = QAction(\"&amp;Setup devices and more\", self)\n    setupMenu.addAction(self.setupDevicesAndMoreAction)        \n    self.setupDevicesAndMoreAction.triggered.connect(self.showSetupMenu)\n\n    self.planningMeasurementsAction = QAction(\"&amp;Plan measurements\", self)\n    setupMenu.addAction(self.planningMeasurementsAction)        \n    self.planningMeasurementsAction.triggered.connect(self.showPlanningMeasurementsMenu)\n    self.planningMeasurementsAction.setDisabled(True)\n\n    self.start_gnd_gimbal_fm_action = QAction(\"Start GND gimbal following its pair\", self)\n    threadsMenu.addAction(self.start_gnd_gimbal_fm_action)\n    self.start_gnd_gimbal_fm_action.triggered.connect(self.start_thread_gnd_gimbal_fm)\n    self.start_gnd_gimbal_fm_action.setDisabled(True)\n\n    self.stop_gnd_gimbal_fm_action = QAction(\"Stop GND gimbal following its pair\", self)\n    threadsMenu.addAction(self.stop_gnd_gimbal_fm_action)\n    self.stop_gnd_gimbal_fm_action.triggered.connect(self.stop_thread_gnd_gimbal_fm)\n    self.stop_gnd_gimbal_fm_action.setDisabled(True)\n\n    self.start_drone_gimbal_fm_action = QAction(\"Start DRONE gimbal following its pair\", self)\n    threadsMenu.addAction(self.start_drone_gimbal_fm_action)\n    self.start_drone_gimbal_fm_action.triggered.connect(self.start_thread_drone_gimbal_fm)\n    self.start_drone_gimbal_fm_action.setDisabled(True)\n\n    self.stop_drone_gimbal_fm_action = QAction(\"Stop DRONE gimbal following its pair\", self)\n    threadsMenu.addAction(self.stop_drone_gimbal_fm_action)\n    self.stop_drone_gimbal_fm_action.triggered.connect(self.stop_thread_drone_gimbal_fm)\n    self.stop_drone_gimbal_fm_action.setDisabled(True)\n\n    self.start_gps_visualization_action = QAction(\"Start GPS visualization\", self)\n    threadsMenu.addAction(self.start_gps_visualization_action)\n    self.start_gps_visualization_action.triggered.connect(self.start_thread_gps_visualization)\n    self.start_gps_visualization_action.setDisabled(False)\n\n    self.stop_gps_visualization_action = QAction(\"Stop GPS visualization\", self)\n    threadsMenu.addAction(self.stop_gps_visualization_action)\n    self.stop_gps_visualization_action.triggered.connect(self.stop_thread_gps_visualization)\n    self.stop_gps_visualization_action.setDisabled(True)\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.create_GPS_visualization_panel","title":"<code>create_GPS_visualization_panel()</code>","text":"<p>Creates the GPS visuzliation panel. The <code>gps_start_point_in_finland_json</code> can be set to any coordinate.</p> <p>Requires the <code>gpsRESTHandler.py</code> file where the REST API for the gps is implemented.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def create_GPS_visualization_panel(self):\n    \"\"\"\n    Creates the GPS visuzliation panel. The ``gps_start_point_in_finland_json`` can be set to any coordinate.\n\n    Requires the ``gpsRESTHandler.py`` file where the REST API for the gps is implemented.\n    \"\"\"\n\n    self.gps_vis_panel = QGroupBox('GPS visualization')\n\n    # This starting point can be anything, as it will be updated throught the PUT requests\n    gps_start_point_json = {\"lat\": 60.15301542729288, \"lon\": 24.316255998379482}\n\n    response = requests.post(self.url_post_map, json=gps_start_point_json)\n\n    time.sleep(0.05)\n\n    js_handler_of_non_geoson = JsCode(\"\"\"\n    function(responseHandler, errorHandler) {\n        let url =\"\"\"+self.url_get_map+\"\"\";\n\n        fetch(url)\n        .then((response) =&gt; {\n            return response.json().then((data) =&gt; {\n                var {lat, lon } = data;\n                var id=45;\n                return {\n                    \"type\": \"FeatureCollection\",\n                    \"features\": [{\n                        \"type\": \"Feature\",\n                        \"geometry\": {\n                            \"type\": \"Point\",\n                            \"coordinates\": [lon, lat]\n                        },\n                        \"properties\": {\n                            \"id\": id\n                        }\n                    }]\n                };\n            })\n        })\n        .then(responseHandler)\n        .catch(errorHandler);\n    }\n    \"\"\")\n\n    self.gps_map = folium.Map()\n    self.map_rt_foilum_plugin = realtime.Realtime(js_handler_of_non_geoson, interval=5000)\n    self.map_rt_foilum_plugin.add_to(self.gps_map)\n\n    self.webview = QWebEngineView()\n    self.webview.setHtml(self.gps_map._repr_html_())\n\n    tx_info_label = QLabel('TX')\n    rx_info_label = QLabel('RX')\n\n    tx_info_label.setAlignment(Qt.AlignCenter)\n    rx_info_label.setAlignment(Qt.AlignCenter)\n\n    tx_x_label = QLabel('X:')\n    tx_y_label = QLabel('Y:')\n    tx_z_label = QLabel('Z:')\n    tx_x_value_label = QLabel('')\n    tx_y_value_label = QLabel('')\n    tx_z_value_label = QLabel('')\n\n    rx_x_label = QLabel('X:')\n    rx_y_label = QLabel('Y:')\n    rx_z_label = QLabel('Z:')\n    rx_x_value_label = QLabel('')\n    rx_y_value_label = QLabel('')\n    rx_z_value_label = QLabel('')\n\n    layout = QGridLayout()\n    layout.addWidget(self.webview, 0, 0, 8, 10)\n    layout.addWidget(tx_info_label, 8, 0, 1, 5)\n    layout.addWidget(rx_info_label, 8, 5, 1, 5)\n    layout.addWidget(tx_x_label, 9, 0, 1, 1)\n    layout.addWidget(tx_z_label, 10, 0, 1, 1)\n    layout.addWidget(tx_y_label, 11, 0, 1, 1)\n    layout.addWidget(tx_x_value_label, 9, 1, 1, 4)\n    layout.addWidget(tx_y_value_label, 10, 1, 1, 4)\n    layout.addWidget(tx_z_value_label, 11, 1, 1, 4)\n    layout.addWidget(rx_x_label, 9, 5, 1, 1)\n    layout.addWidget(rx_z_label, 10, 5, 1, 1)\n    layout.addWidget(rx_y_label, 11, 5, 1, 1)\n    layout.addWidget(rx_x_value_label, 9, 6, 1, 4)\n    layout.addWidget(rx_y_value_label, 10, 6, 1, 4)\n    layout.addWidget(rx_z_value_label, 11, 6, 1, 4)\n\n    # Set the layout of the group box\n    self.gps_vis_panel.setLayout(layout)\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.create_Gimbal_AIR_panel","title":"<code>create_Gimbal_AIR_panel()</code>","text":"<p>Creates the drone gimbal panel with its widgets and layout.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def create_Gimbal_AIR_panel(self):\n    \"\"\"\n    Creates the drone gimbal panel with its widgets and layout.\n    \"\"\"\n    self.gimbalRXPanel = QGroupBox('Drone Gimbal')\n\n    yaw_label = QLabel('Yaw [D]:')\n    pitch_label = QLabel('Pitch [D]:')\n\n    self.drone_gimbal_top_down_menu = QComboBox()\n\n    if self.droneGimbalChoice == \"DJI Ronin RS2\":\n        self.rx_abs_radio_button = QRadioButton(\"Absolute\")\n        self.rx_rel_radio_button = QRadioButton(\"Relative\")\n        self.rx_abs_radio_button.setChecked(True)\n    elif self.droneGimbalChoice == \"Gremsy H16\":\n        self.rx_lock_mode_radio_button = QRadioButton(\"Lock\")\n        self.rx_follow_mode_radio_button = QRadioButton(\"Follow\")\n        self.rx_lock_mode_radio_button.setChecked(True)\n\n        self.rx_lock_mode_radio_button.clicked.connect(self.rx_lock_mode_radio_button_callback)\n        self.rx_follow_mode_radio_button.clicked.connect(self.rx_follow_mode_radio_button_callback)\n\n    self.rx_yaw_value_text_edit = QLineEdit('')\n    self.rx_pitch_value_text_edit = QLineEdit('')\n    self.rx_step_manual_move_gimbal_text_edit = QLineEdit('')\n\n    self.rx_move_according_coords_push_button = QPushButton('Coords Move')\n    self.rx_move_according_coords_push_button.clicked.connect(self.rx_move_according_coords_push_button_callback)\n\n    self.rx_gimbal_manual_move_push_button = QPushButton('Move')\n    self.rx_gimbal_manual_move_push_button.clicked.connect(self.move_button_gimbal_drone_callback)\n    self.rx_gimbal_move_left_push_button = QPushButton('Left')\n    self.rx_gimbal_move_left_push_button.clicked.connect(self.left_button_gimbal_drone_callback)\n    self.rx_gimbal_move_right_push_button = QPushButton('Right')\n    self.rx_gimbal_move_right_push_button.clicked.connect(self.right_button_gimbal_drone_callback)\n    self.rx_gimbal_move_up_push_button = QPushButton('Up')\n    self.rx_gimbal_move_up_push_button.clicked.connect(self.up_button_gimbal_drone_callback)\n    self.rx_gimbal_move_down_push_button = QPushButton('Down')\n    self.rx_gimbal_move_down_push_button.clicked.connect(self.down_button_gimbal_drone_callback)\n\n    thisLatLabel = QLabel('This Lat:')\n    thisLonLabel = QLabel('This Lon:')\n    otherLatLabel = QLabel('Other Lat:')\n    otherLonLabel = QLabel('Other Lon:')\n\n    self.rx_this_lat_text_edit = QLineEdit('')\n    self.rx_this_lon_text_edit = QLineEdit('')\n    self.rx_other_lat_text_edit = QLineEdit('')\n    self.rx_other_lon_text_edit = QLineEdit('')        \n\n    layout = QGridLayout()\n    layout.addWidget(self.rx_gimbal_move_up_push_button, 0, 0, 1, 3)\n    layout.addWidget(self.rx_gimbal_move_left_push_button, 1, 0, 1, 3)\n    layout.addWidget(self.rx_step_manual_move_gimbal_text_edit, 2, 0, 1, 3)\n    layout.addWidget(self.rx_gimbal_move_right_push_button, 3, 0, 1, 3)\n    layout.addWidget(self.rx_gimbal_move_down_push_button, 4, 0, 1, 3)\n\n    if self.droneGimbalChoice == \"DJI Ronin RS2\":\n        layout.addWidget(self.rx_abs_radio_button, 0, 3, 1, 3)\n        layout.addWidget(self.rx_rel_radio_button, 1, 3, 1, 3)\n    elif self.droneGimbalChoice == \"Gremsy H16\":\n        layout.addWidget(self.rx_lock_mode_radio_button, 0, 3, 1, 3)\n        layout.addWidget(self.rx_follow_mode_radio_button, 1, 3, 1, 3)\n    layout.addWidget(yaw_label, 2, 3, 1, 1)\n    layout.addWidget(self.rx_yaw_value_text_edit, 2, 4, 1, 2)\n    layout.addWidget(pitch_label, 3, 3, 1, 1)        \n    layout.addWidget(self.rx_pitch_value_text_edit, 3, 4, 1, 2)\n    layout.addWidget(self.rx_gimbal_manual_move_push_button, 4, 3, 1, 3)     \n\n    layout.addWidget(thisLatLabel, 0, 6, 1, 1)\n    layout.addWidget(self.rx_this_lat_text_edit, 0, 7, 1, 2)\n    layout.addWidget(thisLonLabel, 1, 6, 1, 1)\n    layout.addWidget(self.rx_this_lon_text_edit, 1, 7, 1, 2)\n    layout.addWidget(otherLatLabel, 2, 6, 1, 1)        \n    layout.addWidget(self.rx_other_lat_text_edit, 2, 7, 1, 2)\n    layout.addWidget(otherLonLabel, 3, 6, 1, 1)\n    layout.addWidget(self.rx_other_lon_text_edit, 3, 7, 1, 2)\n    layout.addWidget(self.rx_move_according_coords_push_button, 4, 6, 1, 3)\n\n    self.gimbalRXPanel.setLayout(layout)\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.create_Gimbal_GND_panel","title":"<code>create_Gimbal_GND_panel()</code>","text":"<p>Creates the ground gimbal panel with its widgets and layout.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def create_Gimbal_GND_panel(self):\n    \"\"\"\n    Creates the ground gimbal panel with its widgets and layout.\n    \"\"\"\n\n    self.gimbalTXPanel = QGroupBox('GND Gimbal')\n\n    yaw_label = QLabel('Yaw [D]:')\n    pitch_label = QLabel('Pitch [D]:')\n\n    self.tx_abs_radio_button = QRadioButton(\"Absolute\")\n    self.tx_rel_radio_button = QRadioButton(\"Relative\")        \n    self.tx_abs_radio_button.setChecked(True)\n\n    self.tx_yaw_value_text_edit = QLineEdit('')\n    self.tx_pitch_value_text_edit = QLineEdit('')\n    self.tx_step_manual_move_gimbal_text_edit = QLineEdit('')\n\n    thisLatLabel = QLabel('This Lat:')\n    thisLonLabel = QLabel('This Lon:')\n    otherLatLabel = QLabel('Other Lat:')\n    otherLonLabel = QLabel('Other Lon:')\n\n    self.tx_this_lat_text_edit = QLineEdit('')\n    self.tx_this_lon_text_edit = QLineEdit('')\n    self.tx_other_lat_text_edit = QLineEdit('')\n    self.tx_other_lon_text_edit = QLineEdit('')\n\n    self.tx_move_according_coords_push_button = QPushButton('Coords Move')\n    self.tx_move_according_coords_push_button.clicked.connect(self.tx_move_according_coords_push_button_callback)\n\n    self.tx_gimbal_manual_move_push_button = QPushButton('Move')\n    self.tx_gimbal_manual_move_push_button.clicked.connect(self.move_button_gimbal_gnd_callback)\n    self.tx_gimbal_move_left_push_button = QPushButton('Left')\n    self.tx_gimbal_move_left_push_button.clicked.connect(self.left_button_gimbal_gnd_callback)\n    self.tx_gimbal_move_right_push_button = QPushButton('Right')\n    self.tx_gimbal_move_right_push_button.clicked.connect(self.right_button_gimbal_gnd_callback)\n    self.tx_gimbal_move_up_push_button = QPushButton('Up')\n    self.tx_gimbal_move_up_push_button.clicked.connect(self.up_button_gimbal_gnd_callback)\n    self.tx_gimbal_move_down_push_button = QPushButton('Down')\n    self.tx_gimbal_move_down_push_button.clicked.connect(self.down_button_gimbal_gnd_callback)\n\n    layout = QGridLayout()\n    layout.addWidget(self.tx_gimbal_move_up_push_button, 0, 0, 1, 3)\n    layout.addWidget(self.tx_gimbal_move_left_push_button, 1, 0, 1, 3)\n    layout.addWidget(self.tx_step_manual_move_gimbal_text_edit, 2, 0, 1, 3)\n    layout.addWidget(self.tx_gimbal_move_right_push_button, 3, 0, 1, 3)\n    layout.addWidget(self.tx_gimbal_move_down_push_button, 4, 0, 1, 3)\n\n    layout.addWidget(self.tx_abs_radio_button, 0, 3, 1, 3)\n    layout.addWidget(self.tx_rel_radio_button, 1, 3, 1, 3)\n    layout.addWidget(yaw_label, 2, 3, 1, 1)\n    layout.addWidget(self.tx_yaw_value_text_edit, 2, 4, 1, 2)\n    layout.addWidget(pitch_label, 3, 3, 1, 1)        \n    layout.addWidget(self.tx_pitch_value_text_edit, 3, 4, 1, 2)\n    layout.addWidget(self.tx_gimbal_manual_move_push_button, 4, 3, 1, 3)     \n\n    layout.addWidget(thisLatLabel, 0, 6, 1, 1)\n    layout.addWidget(self.tx_this_lat_text_edit, 0, 7, 1, 2)\n    layout.addWidget(thisLonLabel, 1, 6, 1, 1)\n    layout.addWidget(self.tx_this_lon_text_edit, 1, 7, 1, 2)\n    layout.addWidget(otherLatLabel, 2, 6, 1, 1)        \n    layout.addWidget(self.tx_other_lat_text_edit, 2, 7, 1, 2)\n    layout.addWidget(otherLonLabel, 3, 6, 1, 1)\n    layout.addWidget(self.tx_other_lon_text_edit, 3, 7, 1, 2)\n    layout.addWidget(self.tx_move_according_coords_push_button, 4, 6, 1, 3)\n\n    self.gimbalTXPanel.setLayout(layout)\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.create_Planning_Measurements_panel","title":"<code>create_Planning_Measurements_panel()</code>","text":"<p>Creates the \"Control measurements\" panel with its widgets and layout.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def create_Planning_Measurements_panel(self):\n    \"\"\"\n    Creates the \"Control measurements\" panel with its widgets and layout.\n    \"\"\"\n\n    self.planningMeasurementsPanel = QGroupBox('Control measurements')\n\n    self.start_meas_togglePushButton = QPushButton(\"START\")\n    self.start_meas_togglePushButton.setEnabled(False)\n    self.start_meas_togglePushButton.clicked.connect(self.start_meas_button_callback)\n\n    self.stop_meas_togglePushButton = QPushButton(\"STOP\")\n    self.stop_meas_togglePushButton.setEnabled(False)\n    self.stop_meas_togglePushButton.clicked.connect(self.stop_meas_button_callback)\n\n    self.finish_meas_togglePushButton = QPushButton(\"FINISH\")\n    self.finish_meas_togglePushButton.setEnabled(False)\n    self.finish_meas_togglePushButton.clicked.connect(self.finish_meas_button_callback)\n\n    self.meas_description_text_edit = QPlainTextEdit('')\n    self.meas_description_text_edit.setPlaceholderText(\"Enter measurement description here\")\n\n    layout = QGridLayout()\n    layout.addWidget(self.meas_description_text_edit, 0, 0, 3, 6)\n\n    layout.addWidget(self.start_meas_togglePushButton, 0, 6, 1, 2)\n    layout.addWidget(self.stop_meas_togglePushButton, 1, 6, 1, 2)\n    layout.addWidget(self.finish_meas_togglePushButton, 2, 6, 1, 2)\n\n    self.planningMeasurementsPanel.setLayout(layout)\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.create_check_connections_panel","title":"<code>create_check_connections_panel()</code>","text":"<p>Creates the \"Check connections\" panel with its widgets and layout.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def create_check_connections_panel(self):\n    \"\"\"\n    Creates the \"Check connections\" panel with its widgets and layout.\n    \"\"\"\n    self.checkConnPanel = QGroupBox('Connections')\n\n    gnd_gimbal_conn_label = QLabel('Ground gimbal:')\n    gnd_gps_conn_label = QLabel('Ground GPS:')\n    gnd_rfsoc_conn_label = QLabel('Ground RFSoC:')\n    network_exists_label = QLabel('Able to PING drone?:')\n    ssh_conn_gnd_2_drone_label = QLabel('SSH to drone:')\n    drone_rfsoc_conn_label = QLabel('Drone RFSoC:')\n    drone_gps_conn_label = QLabel('Drone GPS:')\n    drone_gimbal_conn_label = QLabel('Drone Gimbal:')\n    server_gnd_fpga_label = QLabel('Ground FPGA server?:')\n    server_drone_fpga_label = QLabel('Drone FPGA server?:')\n\n    gnd_ip_addr_label = QLabel('Ground IP:')\n    air_ip_addr_label = QLabel('Drone IP:')\n    self.gnd_ip_addr_value_label = QLabel('')\n    self.air_ip_addr_value_text_edit = QLineEdit(self.STATIC_DRONE_IP_ADDRESS)\n\n    #self.GndGimbalFollowingCheckBox = QCheckBox(\"&amp;RS2 FM\")\n    #self.GndGimbalFollowingCheckBox.setChecked(False)\n    #self.GndGimbalFollowingCheckBox.toggled.connect(self.activate_rs2_fm_flag)\n    #self.rs2_fm_flag = False\n\n    #self.GpsDisplayCheckBox = QCheckBox(\"&amp;GPS Display\")\n    #self.GpsDisplayCheckBox.setChecked(False)\n    #self.GpsDisplayCheckBox.toggled.connect(self.activate_gps_display_flag)\n    #self.gps_display_flag = False\n\n    self.check_connections_push_button = QPushButton('Check')\n    self.connect_to_drone = QPushButton('Connect drone')\n    self.disconnect_from_drone = QPushButton('Disconnect drone')\n    self.check_connections_push_button.clicked.connect(self.check_status_all_devices)\n    self.disconnect_from_drone.setEnabled(False)\n    self.connect_to_drone.setEnabled(False)\n    self.connect_to_drone.clicked.connect(self.connect_drone_callback)\n    self.disconnect_from_drone.clicked.connect(self.disconnect_drone_callback)\n\n    self.gnd_gimbal_conn_label_modifiable = QLabel('--')\n    self.gnd_gps_conn_label_modifiable = QLabel('--')\n    self.gnd_rfsoc_conn_label_modifiable = QLabel('--')\n    self.network_exists_label_modifiable = QLabel('--')\n    self.ssh_conn_gnd_2_drone_label_modifiable = QLabel('--')\n    self.drone_rfsoc_conn_label_modifiable = QLabel('--')\n    self.drone_gps_conn_label_modifiable = QLabel('--')\n    self.drone_gimbal_conn_label_modifiable = QLabel('--')\n    self.server_gnd_fpga_label_modifiable = QLabel('--')\n    self.server_drone_fpga_label_modifiable = QLabel('--')\n\n    layout = QGridLayout()\n\n    layout.addWidget(gnd_ip_addr_label, 0, 0, 1, 1)\n    layout.addWidget(self.gnd_ip_addr_value_label, 0, 1, 1, 1)\n    layout.addWidget(gnd_gimbal_conn_label, 0, 2, 1, 1)\n    layout.addWidget(self.gnd_gimbal_conn_label_modifiable, 0, 3, 1, 1)\n    layout.addWidget(gnd_gps_conn_label, 0, 4, 1, 1)\n    layout.addWidget(self.gnd_gps_conn_label_modifiable, 0, 5, 1, 1)\n    layout.addWidget(gnd_rfsoc_conn_label, 0, 6, 1, 1)\n    layout.addWidget(self.gnd_rfsoc_conn_label_modifiable, 0, 7, 1, 1)\n    layout.addWidget(network_exists_label, 0, 8, 1, 1)\n    layout.addWidget(self.network_exists_label_modifiable, 0, 9, 1, 1)\n    layout.addWidget(ssh_conn_gnd_2_drone_label, 0, 10, 1, 1)\n    layout.addWidget(self.ssh_conn_gnd_2_drone_label_modifiable, 0, 11, 1, 1)\n    layout.addWidget(drone_rfsoc_conn_label, 0, 12, 1, 1)\n    layout.addWidget(self.drone_rfsoc_conn_label_modifiable, 0, 13, 1, 1)\n    layout.addWidget(drone_gps_conn_label, 0, 14, 1, 1)       \n    layout.addWidget(self.drone_gps_conn_label_modifiable, 0, 15, 1, 1)\n    layout.addWidget(air_ip_addr_label, 1, 0, 1, 1)\n    layout.addWidget(self.air_ip_addr_value_text_edit, 1, 1, 1, 2)\n    layout.addWidget(drone_gimbal_conn_label, 1, 3, 1, 1)\n    layout.addWidget(self.drone_gimbal_conn_label_modifiable, 1, 4, 1, 1) \n    layout.addWidget(server_gnd_fpga_label, 1, 5, 1, 1)\n    layout.addWidget(self.server_gnd_fpga_label_modifiable, 1, 6, 1, 1)\n    layout.addWidget(server_drone_fpga_label, 1, 7, 1, 1)\n    layout.addWidget(self.server_drone_fpga_label_modifiable, 1, 8, 1, 1)\n    layout.addWidget(self.check_connections_push_button, 1, 9, 1, 3)\n    layout.addWidget(self.connect_to_drone, 1, 12, 1, 2)\n    layout.addWidget(self.disconnect_from_drone, 1, 14, 1, 2)\n\n    self.checkConnPanel.setLayout(layout)\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.create_class_instances","title":"<code>create_class_instances(IsGPS=False, IsGimbal=False, IsRFSoC=False, GPS_Stream_Interval='sec1')</code>","text":"<p>Creates <code>HelperA2GMeasurements</code> class instance for this (ground) node and starts the WiFi communication thread.</p> <p>Parameters:</p> Name Type Description Default <code>IsGPS</code> <code>bool</code> <p>True if there is a Septentrio GPS connected to this (ground) host computer. Defaults to False.</p> <code>False</code> <code>IsGimbal</code> <code>bool</code> <p>True if there is a Ronin RS2 gimbal connected to this (ground) host computer. Defaults to False.</p> <code>False</code> <code>IsRFSoC</code> <code>bool</code> <p>True if there is an RFSoC connected to this (ground) host computer. Defaults to False.</p> <code>False</code> <code>GPS_Stream_Interval</code> <code>str</code> <p>controls the regularity of getting GPS coordinates in this (ground) node. Available options are provided in <code>GpsSignaling.start_gps_data_retrieval</code>. Defaults to 'sec1'.</p> <code>'sec1'</code> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def create_class_instances(self, IsGPS=False, IsGimbal=False, IsRFSoC=False, GPS_Stream_Interval='sec1'):\n    \"\"\"\n    Creates ``HelperA2GMeasurements`` class instance for this (ground) node and starts the WiFi communication thread.\n\n    Args:\n        IsGPS (bool, optional): True if there is a Septentrio GPS connected to this (ground) host computer. Defaults to False.\n        IsGimbal (bool, optional): True if there is a Ronin RS2 gimbal connected to this (ground) host computer. Defaults to False.\n        IsRFSoC (bool, optional): True if there is an RFSoC connected to this (ground) host computer. Defaults to False.\n        GPS_Stream_Interval (str, optional): controls the regularity of getting GPS coordinates in this (ground) node. Available options are provided in ``GpsSignaling.start_gps_data_retrieval``. Defaults to 'sec1'.\n    \"\"\"\n\n    # As this app is executed at the ground device...\n    self.myhelpera2g = HelperA2GMeasurements('GROUND', self.GND_ADDRESS, IsRFSoC=IsRFSoC, IsGimbal=IsGimbal, IsGPS=IsGPS, rfsoc_static_ip_address='10.1.1.30', GPS_Stream_Interval=GPS_Stream_Interval, DBG_LVL_0=False, DBG_LVL_1=False, heading_offset=self.gnd_gps_att_offset)\n    self.myhelpera2g.HelperStartA2GCom()\n\n    print(\"[DEBUG]: Starting GUI threads\")\n    time.sleep(1)\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.create_fpga_and_sivers_panel","title":"<code>create_fpga_and_sivers_panel()</code>","text":"<p>Creates the \"Sivers settings\" panel with its widgets and layout.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def create_fpga_and_sivers_panel(self):\n    \"\"\"\n    Creates the \"Sivers settings\" panel with its widgets and layout.\n    \"\"\"\n\n    self.fpgaAndSiversSettingsPanel = QGroupBox('Sivers settings')\n\n    rf_op_freq_label = QLabel('Freq. Operation [Hz]:')\n    tx_bb_gain_label = QLabel('Tx BB Gain [dB]:')\n    tx_bb_phase_label = QLabel('Tx BB Phase [dB]:')\n    tx_bb_iq_gain_label = QLabel('Tx BB IQ Gain [dB]:')\n    tx_bfrf_gain_label = QLabel('Tx BF &amp; RF Gain [dB]:')\n    rx_bb_gain_1_label = QLabel('Rx BB Gain 1 [dB]:')\n    rx_bb_gain_2_label = QLabel('Rx BB Gain 2 [dB]:')\n    rx_bb_gain_3_label = QLabel('Rx BB Gain 3 [dB]:')\n    rx_bfrf_gain_label = QLabel('Rx BF &amp; RF Gain [dB]:')\n\n    tx_bb_gain_label.leaveEvent = lambda e: QToolTip.hideText()\n    tx_bb_gain_label.enterEvent = lambda e: QToolTip.showText(QCursor.pos(), \"Not available to the user for the moment\")\n\n    #tx_bb_phase_label.leaveEvent = lambda e: QToolTip.hideText()\n    #tx_bb_phase_label.enterEvent = lambda e: QToolTip.showText(QCursor.pos(), \"Defaults to 0.\")\n\n    # Luckily lambda functions can help us to re implement QLabel methods leaveEvent and enterEvent in one line\n    tx_bb_iq_gain_label.leaveEvent = lambda e: QToolTip.hideText()\n    tx_bb_iq_gain_label.enterEvent = lambda e: QToolTip.showText(QCursor.pos(), \"INPUT A VALUE IN: [0,6] dB\\nThis sets the BB gain for the I, Q signals.\\nThe actual value in dB is chosen as the closest value in the array linspace(0,6,16)\")\n\n    tx_bfrf_gain_label.leaveEvent = lambda e: QToolTip.hideText()\n    tx_bfrf_gain_label.enterEvent = lambda e: QToolTip.showText(QCursor.pos(), \"INPUT A VALUE IN: [0,15] dB\\nThis sets the gain after RF mixer for the I, Q signals.\\nThe actual value in dB is chosen as the closest value in the array linspace(0,15,16)\")\n\n    rx_bb_gain_1_label.leaveEvent = lambda e: QToolTip.hideText()\n    rx_bb_gain_1_label.enterEvent = lambda e: QToolTip.showText(QCursor.pos(), \"INPUT A VALUE IN: [-6,0] dB\\nThis sets the rx 1st BB gain for the I, Q signals.\\nThe actual value in dB is chosen as the closest value in the array linspace(-6,0,4)\")\n\n    rx_bb_gain_2_label.leaveEvent = lambda e: QToolTip.hideText()\n    rx_bb_gain_2_label.enterEvent = lambda e: QToolTip.showText(QCursor.pos(), \"INPUT A VALUE IN: [-6,0] dB\\nThis sets the rx 2nd BB gain for the I, Q signals.\\nThe actual value in dB is chosen as the closest value in the array linspace(-6,0,4)\")\n\n    rx_bb_gain_3_label.leaveEvent = lambda e: QToolTip.hideText()\n    rx_bb_gain_3_label.enterEvent = lambda e: QToolTip.showText(QCursor.pos(), \"INPUT A VALUE IN: [0,6] dB\\nThis sets the rx 3rd BB gain for the I, Q signals.\\nThe actual value in dB is chosen as the closest value in the array linspace(0,6,16)\")\n\n    rx_bfrf_gain_label.leaveEvent = lambda e: QToolTip.hideText()\n    rx_bfrf_gain_label.enterEvent = lambda e: QToolTip.showText(QCursor.pos(), \"INPUT A VALUE IN: [0,15] dB\\nThis sets the rx gain before the RF mixer for the I, Q signals.\\nThe actual value in dB is chosen as the closest value in the array linspace(0,15,16)\")\n\n    self.rf_op_freq_text_edit = QLineEdit('57.51e9')\n    self.tx_bb_gain_text_edit = QLineEdit('3')\n    self.tx_bb_phase_text_edit = QLineEdit('0')\n    self.tx_bb_iq_gain_text_edit = QLineEdit('1.6')\n    self.tx_bfrf_gain_text_edit = QLineEdit('3')\n    self.rx_bb_gain_1_text_edit = QLineEdit('-1.5')\n    self.rx_bb_gain_2_text_edit = QLineEdit('-4.5')\n    self.rx_bb_gain_3_text_edit = QLineEdit('1.6')\n    self.rx_bfrf_gain_text_edit = QLineEdit('7')\n    self.tx_bb_phase_text_edit.setEnabled(False)\n    self.tx_bb_gain_text_edit.setEnabled(False)\n\n    layout = QGridLayout()\n\n    layout.addWidget(rf_op_freq_label, 0, 0, 1, 2)\n    layout.addWidget(self.rf_op_freq_text_edit, 0, 2, 1, 2)\n    layout.addWidget(tx_bb_gain_label, 1, 0, 1, 1)\n    layout.addWidget(self.tx_bb_gain_text_edit, 1, 1, 1, 1)\n    layout.addWidget(rx_bb_gain_1_label, 1, 2, 1, 1)\n    layout.addWidget(self.rx_bb_gain_1_text_edit, 1, 3, 1, 1)\n\n    layout.addWidget(tx_bb_phase_label, 2, 0, 1, 1)\n    layout.addWidget(self.tx_bb_phase_text_edit, 2, 1, 1, 1)\n    layout.addWidget(rx_bb_gain_2_label, 2, 2, 1, 1)\n    layout.addWidget(self.rx_bb_gain_2_text_edit, 2, 3, 1, 1)\n\n    layout.addWidget(tx_bb_iq_gain_label, 3, 0, 1, 1)\n    layout.addWidget(self.tx_bb_iq_gain_text_edit, 3, 1, 1, 1)\n    layout.addWidget(rx_bb_gain_3_label, 3, 2, 1, 1)\n    layout.addWidget(self.rx_bb_gain_3_text_edit, 3, 3, 1, 1)\n\n    layout.addWidget(tx_bfrf_gain_label, 4, 0, 1, 1)\n    layout.addWidget(self.tx_bfrf_gain_text_edit, 4, 1, 1, 1)\n    layout.addWidget(rx_bfrf_gain_label, 4, 2, 1, 1)\n    layout.addWidget(self.rx_bfrf_gain_text_edit, 4, 3, 1, 1)\n\n    self.fpgaAndSiversSettingsPanel.setLayout(layout)\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.create_log_terminal","title":"<code>create_log_terminal()</code>","text":"<p>Access the widget contents by using <code>self.log_widget.setPlainText('')</code></p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def create_log_terminal(self):\n    \"\"\"\n    Access the widget contents by using ``self.log_widget.setPlainText('')``\n    \"\"\"\n    self.log_widget = CustomTextEdit(self)\n\n    #self.log_widget = QTextEdit(self)\n    self.log_widget.setReadOnly(True) # make it read-only        \n\n    # Redirect output of myFunc to the QTextEdit widget\n    sys.stdout = self.log_widget\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.create_pap_plot_panel","title":"<code>create_pap_plot_panel()</code>","text":"<p>Creates the \"PAP\" panel (responsible for ploting the Power Angular Profile of the measured CIRs).</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def create_pap_plot_panel(self):\n    \"\"\"\n    Creates the \"PAP\" panel (responsible for ploting the Power Angular Profile of the measured CIRs).\n    \"\"\"\n\n    self.papPlotPanel = QGroupBox('PAP')\n    self.time_snaps = 22\n    self.plot_widget = pg.PlotWidget() \n    self.plot_widget.setLabel('left', 'Beam steering angle [deg]')\n    self.plot_widget.setLabel('bottom', 'Time snapshot number')\n\n    layout = QVBoxLayout()\n    layout.addWidget(self.plot_widget)\n    self.papPlotPanel.setLayout(layout)\n\n    rx_sivers_beam_index_mapping_file = open('data/rx_sivers_beam_index_mapping.csv')\n    csvreader = csv.reader(rx_sivers_beam_index_mapping_file)\n    beam_idx_map = [float(i[1]) for cnt,i in enumerate(csvreader) if cnt != 0]\n    ticksla = beam_idx_map[::4]\n    self.beam_angs = ticksla\n    ticks = np.arange(0,16) \n    y_ticks = [(ticks[cnt], f'{tickla:1.2f}\u00b0') for cnt, tickla in enumerate(ticksla)]\n    self.plot_widget.getAxis('left').setTicks([y_ticks, []])\n\n    x_ticks = [(i, str(i)) for i in np.arange(self.time_snaps)]\n    self.plot_widget.getAxis('bottom').setTicks([x_ticks, []])\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.disconnect_drone_callback","title":"<code>disconnect_drone_callback()</code>","text":"<p>Callback for when the user presses the \"Disconnect\" button.</p> <p>If there is an ongoing measurement it will be finished.</p> <p>The WiFi thread will be stopped and its associated socket will be closed in this node. Devices connection to this node will be closed.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def disconnect_drone_callback(self):\n    \"\"\"\n    Callback for when the user presses the \"Disconnect\" button.\n\n    If there is an ongoing measurement it will be finished.\n\n    The WiFi thread will be stopped and its associated socket will be closed in this node. Devices connection to this node will be closed.\n    \"\"\"\n\n    if hasattr(self, 'periodical_gimbal_follow_thread'):\n        if self.periodical_gimbal_follow_thread.isRunning():\n            self.stop_event_gimbal_follow_thread.set()\n\n    if hasattr(self, 'periodical_gps_display_thread'):\n        if self.periodical_gps_display_thread.isActive():\n            self.periodical_gps_display_thread.stop()\n\n    if self.stop_meas_togglePushButton.isChecked():\n        print(\"[DEBUG]: Before disconnecting, the ongoing measurement will be stopped\")\n        self.stop_meas_button_callback()\n    if self.finish_meas_togglePushButton.isChecked():\n        print(\"[DEBUG]: Before disconnecting, the ongoing measurement will be finished\")\n        self.finish_meas_button_callback()\n\n    self.myhelpera2g.socket_send_cmd(type_cmd='CLOSEDGUI')\n    self.myhelpera2g.HelperA2GStopCom(DISC_WHAT='ALL') # shutdowns the devices that where passed by parameters as True, when the class instance is created\n    del self.myhelpera2g\n\n    self.start_meas_togglePushButton.setEnabled(False)\n    self.stop_meas_togglePushButton.setEnabled(False)\n    self.finish_meas_togglePushButton.setEnabled(False)\n    self.connect_to_drone.setEnabled(True)\n    self.disconnect_from_drone.setEnabled(False)\n\n    self.setupDevicesAndMoreAction.setEnabled(True)\n    self.start_gnd_gimbal_fm_action.setEnabled(True)\n    self.stop_gnd_gimbal_fm_action.setEnabled(False)\n    self.start_drone_gimbal_fm_action.setEnabled(True)\n    self.stop_drone_gimbal_fm_action.setEnabled(False)        \n    self.start_gps_visualization_action.setEnabled(True)\n    self.stop_gps_visualization_action.setEnabled(False)\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.down_button_gimbal_drone_callback","title":"<code>down_button_gimbal_drone_callback()</code>","text":"<p>Callback for when the user presses the \"Left\" button from the Gimbal drone panel. </p> <p>Direction buttons (up, down, left, right) move the gimbal the direction they indicate, by the amount given in the \"Step\" textbox. The movement is relative to the angle before the button was pressed.</p> <p>If no value is provided in the \"Step\" textbox, the gimbal moves a value of 10 degrees in the direction indicated by this button.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def down_button_gimbal_drone_callback(self):\n    \"\"\"\n    Callback for when the user presses the \"Left\" button from the Gimbal drone panel. \n\n    Direction buttons (up, down, left, right) move the gimbal the direction they indicate, by the amount given in the \"Step\" textbox. The movement is relative to the angle before the button was pressed.\n\n    If no value is provided in the \"Step\" textbox, the gimbal moves a value of 10 degrees in the direction indicated by this button.\n    \"\"\"\n    if hasattr(self, 'myhelpera2g'):\n        movement_step = self.rx_step_manual_move_gimbal_text_edit.text()\n        if movement_step != '':\n            try:\n                tmp = int(float(movement_step))\n                incorrect_angle_value = self.checker_gimbal_input_range(tmp)\n                if tmp &lt; 0:\n                    tmp = abs(tmp)\n                    print(\"[DEBUG]: The movement step Textbox in the Gimbal Control Panel is always taken as positive. Direction is given by arrows.\")\n                if self.droneGimbalChoice == \"DJI Ronin RS2\":\n                    data = {'YAW': 0, 'PITCH': -tmp*10,'ROLL': 0, 'MODE': 0x00}\n                elif self.droneGimbalChoice == \"Gremsy H16\":\n                    data = {'YAW': 0, 'PITCH': -tmp,'ROLL': 0, 'MODE': 0x00}\n                self.myhelpera2g.socket_send_cmd(type_cmd='SETGIMBAL', data=data)\n                print(f\"[DEBUG]: gimbal moved -{movement_step} degs from application\")\n            except Exception as e:\n                    print(\"[DEBUG]: Error executing gimbal movement. Most probably wrong MOVEMENT STEP format, \", e)\n        else:\n            if self.droneGimbalChoice == \"DJI Ronin RS2\":\n                data = {'YAW': 0, 'PITCH': -100,'ROLL': 0, 'MODE': 0x00}\n            elif self.droneGimbalChoice == \"Gremsy H16\":\n                data = {'YAW': 0, 'PITCH': -10, 'ROLL': 0,'MODE': 0x00}\n            self.myhelpera2g.socket_send_cmd(type_cmd='SETGIMBAL', data=data)\n            print(\"[DEBUG]: gimbal moved from application by a predetermined angle of -10 deg, since no angle was specified\")\n    else:\n        print(\"[DEBUG]: No HelperA2GMeasurements class instance is available\")\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.down_button_gimbal_gnd_callback","title":"<code>down_button_gimbal_gnd_callback()</code>","text":"<p>Callback for when the user presses the <code>Down</code> button from the Gimbal GND panel. </p> <p>Direction buttons (up, down, left, right) move the gimbal the direction they indicate, by the amount given in the <code>Step</code> textbox. The movement is relative to the angle before the button was pressed.</p> <p>If no value is provided in the <code>Step</code> textbox, the gimbal moves a value of 10 degrees in the direction indicated by this button.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def down_button_gimbal_gnd_callback(self):\n    \"\"\"\n    Callback for when the user presses the ``Down`` button from the Gimbal GND panel. \n\n    Direction buttons (up, down, left, right) move the gimbal the direction they indicate, by the amount given in the ``Step`` textbox. The movement is relative to the angle before the button was pressed.\n\n    If no value is provided in the ``Step`` textbox, the gimbal moves a value of 10 degrees in the direction indicated by this button.\n    \"\"\"\n\n    if hasattr(self, 'myhelpera2g'):\n        if hasattr(self.myhelpera2g, 'myGimbal'):\n            movement_step = self.tx_step_manual_move_gimbal_text_edit.text()\n\n            if movement_step != '':\n                try:\n                    tmp = int(float(movement_step))\n                    incorrect_angle_value = self.checker_gimbal_input_range(tmp)\n                    if tmp &lt; 0:\n                        tmp = abs(tmp)\n                        print(\"[DEBUG]: The movement step Textbox in the Gimbal Control Panel is always taken as positive. Direction is given by arrows.\")\n                    self.myhelpera2g.myGimbal.setPosControl(yaw=0, roll=0, pitch=-tmp*10, ctrl_byte=0x00)\n                    print(f\"[DEBUG]: gimbal moved {movement_step} degs from application\")\n                except Exception as e:\n                    print(\"[DEBUG]: Error executing gimbal movement. Most probably wrong MOVEMENT STEP format, \", e)\n            else:\n                self.myhelpera2g.myGimbal.setPosControl(yaw=0, roll=0, pitch=-100, ctrl_byte=0x00)\n                print(\"[DEBUG]: gimbal moved from application by a predetermined angle of -10 deg, since no angle was specified\")\n\n        else:\n            print(\"[DEBUG]: No gimbal has been created at GND, so buttons will do nothing\")\n    else:\n        print(\"[DEBUG]: No HelperA2GMeasurements class instance is available\")\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.finish_meas_button_callback","title":"<code>finish_meas_button_callback()</code>","text":"<p>Callback for when the user presses the \"FINISH\" button. Sends a <code>FINISHDRONERFSOC</code> command to the drone, to stop its rfsoc thread.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def finish_meas_button_callback(self):\n    \"\"\"\n    Callback for when the user presses the \"FINISH\" button. Sends a ``FINISHDRONERFSOC`` command to the drone, to stop its rfsoc thread.\n    \"\"\"\n\n    self.myhelpera2g.socket_send_cmd(type_cmd='FINISHDRONERFSOC')\n    print(\"[DEBUG]: SENT REQUEST to FINISH measurement\")\n\n    datestr = datetime.datetime.now()\n    datestr = datestr.strftime('%Y-%m-%d-%H-%M-%S')\n\n    current_text = self.meas_description_text_edit.document().toPlainText()\n    if self.myhelpera2g.IsGimbal!=0:\n        if hasattr(self.myhelpera2g, 'myGimbal'):\n            current_text = current_text + f\"\\nYaw at pressing FINISH: {self.myhelpera2g.myGimbal.yaw}\" + '\\n' + f\"Pitch at pressing FINISH: {self.myhelpera2g.myGimbal.pitch}\"\n    with open('description_' + datestr + '.txt', 'a+') as file:\n        file.write(current_text)\n\n    print(\"[DEBUG]: Saved description file on GND node\")\n\n    self.start_meas_togglePushButton.setEnabled(True)\n    self.stop_meas_togglePushButton.setEnabled(False)\n    self.finish_meas_togglePushButton.setEnabled(False)\n\n    if hasattr(self, 'periodical_gimbal_follow_thread'):\n        if self.periodical_gimbal_follow_thread.isRunning():\n            self.stop_event_gimbal_follow_thread.set()\n    if hasattr(self, 'periodical_gps_display_thread'):\n        if self.periodical_gps_display_thread.isActive():\n                self.periodical_gps_display_thread.stop()\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.get_gnd_ip_node_address","title":"<code>get_gnd_ip_node_address()</code>","text":"<p>Gets the IP address ground's node WiFi interface.</p> <p>Caller function IS RESPONSIBLE for checking if there is a WiFi operating.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def get_gnd_ip_node_address(self):\n    \"\"\"\n    Gets the IP address ground's node WiFi interface.\n\n    Caller function IS RESPONSIBLE for checking if there is a WiFi operating. \n    \"\"\"\n\n    if platform.system() == \"Windows\":\n        ifconfig_info = subprocess.Popen([\"ipconfig\"], stdout=subprocess.PIPE)\n    else:\n        ifconfig_info = subprocess.Popen([\"ifconfig\"], stdout=subprocess.PIPE)\n    out, err = ifconfig_info.communicate()\n    stdout_str = out.decode()\n\n    pattern = r'inet\\s+\\d+.\\d+.\\d+.\\d+'        \n\n    try:\n        # This is how the IP address should appear, as the GND-DRONE connection is wireless through an AP\n        stdout_str_split = stdout_str.split('wlan0: ')\n\n        gnd_ip_addr = re.findall(pattern, stdout_str_split[-1])\n        gnd_ip_addr = gnd_ip_addr[0].split('inet ')\n        gnd_ip_addr = gnd_ip_addr[-1]\n    except Exception as e:\n        print(\"[DEBUG]: Error detecting the GND IP address \", e)\n    else:\n        self.GND_ADDRESS = gnd_ip_addr\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.init_constants","title":"<code>init_constants()</code>","text":"<p>Creates some class attributes. </p> <p>The <code>STATIC_DRONE_IP_ADDRESS</code> is to set a static IP address for the drone. This IP address must be assigned to the drone from the router configuration interface (this IP address was set for the drone on the Archer AX router)</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def init_constants(self):\n    \"\"\"\n    Creates some class attributes. \n\n    The ``STATIC_DRONE_IP_ADDRESS`` is to set a static IP address for the drone. This IP address must be assigned to the drone from the router configuration interface (this IP address was set for the drone on the Archer AX router)\n\n    \"\"\"\n    # Parameters of the GUI\n    self.debug_cnt_1 = 1\n    self.STATIC_DRONE_IP_ADDRESS = '192.168.0.157'\n    self.number_lines_log_terminal = 100\n    self.log_terminal_txt = \"\"\n    self.remote_drone_conn = None\n\n    self.SUCCESS_PING_DRONE = False\n    self.SUCCESS_SSH = False\n    self.SUCCESS_DRONE_FPGA = False\n    self.SUCCESS_DRONE_GPS = False\n    self.SUCCES_DRONE_GIMBAL = False\n    self.SUCCESS_GND_FPGA = False\n    self.SUCCESS_GND_GIMBAL = False\n    self.SUCCESS_GND_GPS = False\n\n    self.url_get_map = \"\"\"'http://127.0.0.1:8000/gps/get'\"\"\"\n    self.url_post_map = \"http://127.0.0.1:8000/gps/post/septentrio\"\n    self.url_put_map = \"http://127.0.0.1:8000/gps/update/septentrio\"\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.left_button_gimbal_drone_callback","title":"<code>left_button_gimbal_drone_callback()</code>","text":"<p>Callback for when the user presses the \"Left\" button from the Gimbal Drone panel. </p> <p>Direction buttons (up, down, left, right) move the gimbal the direction they indicate, by the amount given in the \"Step\" textbox. The movement is relative to the angle before the button was pressed.</p> <p>If no value is provided in the \"Step\" textbox, the gimbal moves a value of 10 degrees in the direction indicated by this button.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def left_button_gimbal_drone_callback(self):\n    \"\"\"\n    Callback for when the user presses the \"Left\" button from the Gimbal Drone panel. \n\n    Direction buttons (up, down, left, right) move the gimbal the direction they indicate, by the amount given in the \"Step\" textbox. The movement is relative to the angle before the button was pressed.\n\n    If no value is provided in the \"Step\" textbox, the gimbal moves a value of 10 degrees in the direction indicated by this button.\n    \"\"\"\n    if hasattr(self, 'myhelpera2g'):\n        movement_step = self.rx_step_manual_move_gimbal_text_edit.text()\n        if movement_step != '':\n            try:\n                tmp = int(float(movement_step))\n                incorrect_angle_value = self.checker_gimbal_input_range(tmp)\n                if tmp &lt; 0:\n                    tmp = abs(tmp)\n                    print(\"[DEBUG]: The movement step Textbox in the Gimbal Control Panel is always taken as positive. Direction is given by arrows.\")\n\n                if self.droneGimbalChoice == \"DJI Ronin RS2\":\n                    data = {'YAW': -tmp*10, 'PITCH': 0, 'ROLL': 0, 'MODE': 0x00}\n                elif self.droneGimbalChoice == \"Gremsy H16\":\n                    data = {'YAW': -tmp, 'PITCH': 0, 'ROLL': 0, 'MODE': 0x00}\n                self.myhelpera2g.socket_send_cmd(type_cmd='SETGIMBAL', data=data)\n                print(f\"[DEBUG]: gimbal moved -{movement_step} degs from application\")\n            except Exception as e:\n                    print(\"[DEBUG]: Error executing gimbal movement. Most probably wrong MOVEMENT STEP format, \", e)\n        else:\n            if self.droneGimbalChoice == \"DJI Ronin RS2\":\n                data = {'YAW': -100, 'PITCH': 0, 'ROLL': 0,'MODE': 0x00}\n            elif self.droneGimbalChoice == \"Gremsy H16\":\n                data = {'YAW': -10, 'PITCH': 0, 'ROLL': 0,'MODE': 0x00}\n            self.myhelpera2g.socket_send_cmd(type_cmd='SETGIMBAL', data=data)\n            print(\"[DEBUG]: gimbal moved from application by a predetermined angle of -10 deg, since no angle was specified\")\n    else:\n        print(\"[DEBUG]: No HelperA2GMeasurements class instance is available\")\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.left_button_gimbal_gnd_callback","title":"<code>left_button_gimbal_gnd_callback()</code>","text":"<p>Callback for when the user presses the <code>Left</code> button from the Gimbal GND panel. </p> <p>Direction buttons (up, down, left, right) move the gimbal the direction they indicate, by the amount given in the <code>Step</code> textbox. The movement is relative to the angle before the button was pressed.</p> <p>If no value is provided in the <code>Step</code> textbox, the gimbal moves a value of 10 degrees in the direction indicated by this button.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def left_button_gimbal_gnd_callback(self):\n    \"\"\"\n    Callback for when the user presses the ``Left`` button from the Gimbal GND panel. \n\n    Direction buttons (up, down, left, right) move the gimbal the direction they indicate, by the amount given in the ``Step`` textbox. The movement is relative to the angle before the button was pressed.\n\n    If no value is provided in the ``Step`` textbox, the gimbal moves a value of 10 degrees in the direction indicated by this button.\n    \"\"\"\n\n    if hasattr(self, 'myhelpera2g'):\n        if hasattr(self.myhelpera2g, 'myGimbal'):\n            movement_step = self.tx_step_manual_move_gimbal_text_edit.text()\n\n            if movement_step != '':\n                try:\n                    tmp = int(float(movement_step))\n                    incorrect_angle_value = self.checker_gimbal_input_range(tmp)\n                    if tmp &lt; 0:\n                        tmp = abs(tmp)\n                        print(\"[DEBUG]: The movement step Textbox in the Gimbal Control Panel is always taken as positive. Direction is given by arrows.\")\n                    self.myhelpera2g.myGimbal.setPosControl(yaw=-tmp*10, roll=0, pitch=0, ctrl_byte=0x00)\n                    print(f\"[DEBUG]: gimbal moved -{movement_step} degs from application\")\n                except Exception as e:\n                    print(\"[DEBUG]: Error executing gimbal movement. Most probably wrong MOVEMENT STEP format, \", e)\n            else:\n                self.myhelpera2g.myGimbal.setPosControl(yaw=-100, roll=0, pitch=0, ctrl_byte=0x00)\n                print(\"[DEBUG]: gimbal moved from application by a predetermined angle of -10 deg, since no angle was specified\")\n\n        else:\n            print(\"[DEBUG]: No gimbal has been created at GND, so buttons will do nothing\")\n    else:\n        print(\"[DEBUG]: No HelperA2GMeasurements class instance is available\")\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.move_button_gimbal_drone_callback","title":"<code>move_button_gimbal_drone_callback()</code>","text":"<p>Callback for when the user presses the \"Move\" button from the Gimbal Drone panel. The yaw and pitch QLineEdits control the amount of movement, and the absolute or relative QRadioButtons if the movement is absolute or relative. BOTH yaw and pitch inputs are required.</p> <p>Example:</p> <p>For a yaw absolute movement to -20 deg and a pitch to 97 deg, the user MUST select the absolute radio button and enter -20 in the yaw text box and enter 97 in the pitch text box.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def move_button_gimbal_drone_callback(self):\n    \"\"\"\n    Callback for when the user presses the \"Move\" button from the Gimbal Drone panel. The yaw and pitch QLineEdits control the amount of movement, and the absolute or relative QRadioButtons if the movement is absolute or relative. BOTH yaw and pitch inputs are required.\n\n    Example:\n\n    For a yaw absolute movement to -20 deg and a pitch to 97 deg, the user MUST select the absolute radio button and enter -20 in the yaw text box and enter 97 in the pitch text box.\n    \"\"\"\n    if hasattr(self, 'myhelpera2g'):\n        yaw = self.rx_yaw_value_text_edit.text()\n        pitch = self.rx_pitch_value_text_edit.text()\n\n        if yaw == '' or pitch == '':\n            print(\"[DEBUG]: No YAW or PITCH values provided. No gimbal movement will done.\")\n        else:\n            if self.rx_abs_radio_button.isChecked():\n                ctrl_byte = 0x01\n            if self.rx_rel_radio_button.isChecked():\n                ctrl_byte = 0x00\n            try:\n                yaw = int(float(yaw))\n                pitch = int(float(pitch))\n                incorrect_angle_value = self.checker_gimbal_input_range(yaw)\n                incorrect_angle_value = self.checker_gimbal_input_range(pitch)\n                if self.droneGimbalChoice == \"DJI Ronin RS2\":\n                    data = {'YAW': yaw*10, 'PITCH': pitch*10, 'ROLL': 0, 'MODE': ctrl_byte}\n                elif self.droneGimbalChoice == \"Gremsy H16\":\n                    data = {'YAW': yaw, 'PITCH': pitch, 'ROLL': 0, 'MODE': ctrl_byte}\n                self.myhelpera2g.socket_send_cmd(type_cmd='SETGIMBAL', data=data)\n                print(f\"[DEBUG]: gimbal moved {yaw} degs in YAW and {pitch} in PITCH from application\")\n            except Exception as e:\n                print(\"[DEBUG]: Error executing gimbal movement. Most probably wrong angle input, \", e)\n    else:\n        print(\"[DEBUG]: No HelperA2GMeasurements class instance is available\")\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.move_button_gimbal_gnd_callback","title":"<code>move_button_gimbal_gnd_callback()</code>","text":"<p>Callback for when the user presses the \"Move\" button from the Gimbal GND panel. The yaw and pitch QLineEdits control the amount of movement, and the absolute or relative QRadioButtons if the movement is absolute or relative. BOTH yaw and pitch inputs are required.</p> <p>Example:</p> <p>For a yaw absolute movement to -20 deg and a pitch to 97 deg, the user MUST select the absolute radio button and enter -20 in the yaw text box and enter 97 in the pitch text box.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def move_button_gimbal_gnd_callback(self):\n    \"\"\"\n    Callback for when the user presses the \"Move\" button from the Gimbal GND panel. The yaw and pitch QLineEdits control the amount of movement, and the absolute or relative QRadioButtons if the movement is absolute or relative. BOTH yaw and pitch inputs are required.\n\n    Example:\n\n    For a yaw absolute movement to -20 deg and a pitch to 97 deg, the user MUST select the absolute radio button and enter -20 in the yaw text box and enter 97 in the pitch text box.\n    \"\"\"\n\n    if hasattr(self, 'myhelpera2g'):\n        if hasattr(self.myhelpera2g, 'myGimbal'):\n            yaw = self.tx_yaw_value_text_edit.text()\n            pitch = self.tx_pitch_value_text_edit.text()\n\n            if yaw == '' or pitch == '':\n                print(\"[DEBUG]: No YAW or PITCH values provided. No gimbal movement will done.\")\n            else:\n                if self.tx_abs_radio_button.isChecked():\n                    ctrl_byte = 0x01\n                if self.tx_rel_radio_button.isChecked():\n                    ctrl_byte = 0x00\n\n                try:\n                    yaw = int(float(yaw))\n                    pitch = int(float(pitch))\n                    incorrect_angle_value = self.checker_gimbal_input_range(yaw)\n                    incorrect_angle_value = self.checker_gimbal_input_range(pitch)\n                    self.myhelpera2g.myGimbal.setPosControl(yaw=yaw*10, roll=0, pitch=pitch*10, ctrl_byte=ctrl_byte)\n                    print(f\"[DEBUG]: gimbal moved {yaw} degs in YAW and {pitch} in PITCH from application\")\n                except Exception as e:\n                    print(\"[DEBUG]: Error executing gimbal movement. Most probably wrong angle input, \", e)\n        else:\n            print(\"[DEBUG]: No gimbal has been created at GND, so buttons will do nothing\")\n    else:\n        print(\"[DEBUG]: No HelperA2GMeasurements class instance is available\")\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.periodical_gps_display_callback","title":"<code>periodical_gps_display_callback()</code>","text":"<p>Displays (periodically) GPS position of the drone node on the GPS panel. </p> <p>The period is controlled by the property \"update_vis_time_gps\" of this class.</p> <p>Uses the <code>show_air_moving</code> function of the class <code>GpsOnMap</code>, meaning that such method has to implement the functionality to display gps coordinates on a given input (PyQt5 panel).</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def periodical_gps_display_callback(self):\n    \"\"\"\n    Displays (periodically) GPS position of the drone node on the GPS panel. \n\n    The period is controlled by the property \"update_vis_time_gps\" of this class.\n\n    Uses the ``show_air_moving`` function of the class ``GpsOnMap``, meaning that such method has to implement the functionality to display gps coordinates on a given input (PyQt5 panel).\n    \"\"\"\n\n    # Display coords\n    if hasattr(self, 'myhelpera2g'):\n        '''\n        coords, head_info = self.myhelpera2g.mySeptentrioGPS.get_last_sbf_buffer_info(what='Both')\n\n        if coords['X'] == self.ERR_GPS_CODE_BUFF_NULL or self.ERR_GPS_CODE_SMALL_BUFF_SZ:\n            print(\"[DEBUG]: Error in received GPS coordinates from DRONE\")\n            print(\"[DEBUG]: Due to this error, DRONE location will not be seen\")\n        else:\n            lat_gnd_node, lon_gnd_node, height_node = geocentric2geodetic(coords['X'], coords['Y'], coords['Z'])\n        '''\n        if hasattr(self.myhelpera2g, 'last_drone_coords_requested'):\n            gps_drone_coords_json = {\"lat\": self.last_drone_coords_requested['LAT'], \"lon\": self.last_drone_coords_requested['LON']}\n            response = requests.put(self.url_put_map, json=gps_drone_coords_json)\n    else:# DEBUG: test showing something updating each self.update_vis_time\n        self.debug_cnt_1 = self.debug_cnt_1 + 1\n        alfa = np.random.rand()\n        point1 = [60.187372669712566, 24.96109446381862]\n        point2 = [60.18490587854025, 24.948227873431904]\n        point = np.array(point1)*alfa + (1-alfa)*np.array(point2)\n        point = point.tolist()\n        gps_drone_coords_json = {\"lat\": point[0], \"lon\": point[1]}\n        response = requests.put(self.url_put_map, json=gps_drone_coords_json)    \n        print(\"Periodical GPS\", self.debug_cnt_1)\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.periodical_pap_display_callback","title":"<code>periodical_pap_display_callback()</code>","text":"<p>Callback for display the PAP of the measured CIR in the PAP panel of the GUI.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def periodical_pap_display_callback(self):\n    \"\"\"\n    Callback for display the PAP of the measured CIR in the PAP panel of the GUI.\n    \"\"\"\n\n    if hasattr(self, 'myhelpera2g'):\n        if hasattr(self.myhelpera2g, 'PAP_TO_PLOT'):\n            if len(self.myhelpera2g.PAP_TO_PLOT) &gt; 0:\n                self.plot_widget.clear()\n                img = pg.ImageItem()\n                img.setImage(self.myhelpera2g.PAP_TO_PLOT)\n                self.plot_widget.addItem(img)\n                print(f\"[DEBUG]: Executed plot command at {self.myhelpera2g.ID}. PAP shape: {self.myhelpera2g.PAP_TO_PLOT.shape}\")\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.right_button_gimbal_drone_callback","title":"<code>right_button_gimbal_drone_callback()</code>","text":"<p>Callback for when the user presses the \"Left\" button from the Gimbal drone panel. </p> <p>Direction buttons (up, down, left, right) move the gimbal the direction they indicate, by the amount given in the \"Step\" textbox. The movement is relative to the angle before the button was pressed.</p> <p>If no value is provided in the \"Step\" textbox, the gimbal moves a value of 10 degrees in the direction indicated by this button.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def right_button_gimbal_drone_callback(self):\n    \"\"\"\n    Callback for when the user presses the \"Left\" button from the Gimbal drone panel. \n\n    Direction buttons (up, down, left, right) move the gimbal the direction they indicate, by the amount given in the \"Step\" textbox. The movement is relative to the angle before the button was pressed.\n\n    If no value is provided in the \"Step\" textbox, the gimbal moves a value of 10 degrees in the direction indicated by this button.\n    \"\"\"\n    if hasattr(self, 'myhelpera2g'):\n        movement_step = self.rx_step_manual_move_gimbal_text_edit.text()\n        if movement_step != '':\n            try:\n                tmp = int(float(movement_step))\n                incorrect_angle_value = self.checker_gimbal_input_range(tmp)\n                if tmp &lt; 0:\n                    tmp = abs(tmp)\n                    print(\"[DEBUG]: The movement step Textbox in the Gimbal Control Panel is always taken as positive. Direction is given by arrows.\")\n                if self.droneGimbalChoice == \"DJI Ronin RS2\":\n                    data = {'YAW': tmp*10, 'PITCH': 0,'ROLL': 0, 'MODE': 0x00}\n                elif self.droneGimbalChoice == \"Gremsy H16\":\n                    data = {'YAW': tmp, 'PITCH': 0,'ROLL': 0, 'MODE': 0x00}\n                self.myhelpera2g.socket_send_cmd(type_cmd='SETGIMBAL', data=data)\n                print(f\"[DEBUG]: gimbal moved {movement_step} degs from application\")\n            except Exception as e:\n                    print(\"[DEBUG]: Error executing gimbal movement. Most probably wrong MOVEMENT STEP format, \", e)\n        else:\n            if self.droneGimbalChoice == \"DJI Ronin RS2\":\n                data = {'YAW': 100, 'PITCH': 0,'ROLL': 0, 'MODE': 0x00}\n            elif self.droneGimbalChoice == \"Gremsy H16\":\n                data = {'YAW': 10, 'PITCH': 0,'ROLL': 0, 'MODE': 0x00}\n            self.myhelpera2g.socket_send_cmd(type_cmd='SETGIMBAL', data=data)\n            print(\"[DEBUG]: gimbal moved from application by a predetermined angle of -10 deg, since no angle was specified\")\n    else:\n        print(\"[DEBUG]: No HelperA2GMeasurements class instance is available\")\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.right_button_gimbal_gnd_callback","title":"<code>right_button_gimbal_gnd_callback()</code>","text":"<p>Callback for when the user presses the <code>Right</code> button from the Gimbal GND panel. </p> <p>Direction buttons (up, down, left, right) move the gimbal the direction they indicate, by the amount given in the <code>Step</code> textbox. The movement is relative to the angle before the button was pressed.</p> <p>If no value is provided in the <code>Step</code> textbox, the gimbal moves a value of 10 degrees in the direction indicated by this button.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def right_button_gimbal_gnd_callback(self):\n    \"\"\"\n    Callback for when the user presses the ``Right`` button from the Gimbal GND panel. \n\n    Direction buttons (up, down, left, right) move the gimbal the direction they indicate, by the amount given in the ``Step`` textbox. The movement is relative to the angle before the button was pressed.\n\n    If no value is provided in the ``Step`` textbox, the gimbal moves a value of 10 degrees in the direction indicated by this button.\n    \"\"\"        \n\n    if hasattr(self, 'myhelpera2g'):\n        if hasattr(self.myhelpera2g, 'myGimbal'):\n            movement_step = self.tx_step_manual_move_gimbal_text_edit.text()\n\n            if movement_step != '':\n                try:\n                    tmp = int(float(movement_step))\n                    incorrect_angle_value = self.checker_gimbal_input_range(tmp)\n                    if tmp &lt; 0:\n                        tmp = abs(tmp)\n                        print(\"[DEBUG]: The movement step Textbox in the Gimbal Control Panel is always taken as positive. Direction is given by arrows.\")\n                    self.myhelpera2g.myGimbal.setPosControl(yaw=tmp*10, roll=0, pitch=0, ctrl_byte=0x00)\n                    print(f\"[DEBUG]: gimbal moved {movement_step} degs from application\")\n                except Exception as e:\n                    print(\"[DEBUG]: Error executing gimbal movement. Most probably wrong MOVEMENT STEP format, \", e)\n            else:\n                self.myhelpera2g.myGimbal.setPosControl(yaw=100, roll=0, pitch=0, ctrl_byte=0x00)\n                print(\"[DEBUG]: gimbal moved from application by a predetermined angle of 10 deg, since no angle was specified\")\n\n        else:\n            print(\"[DEBUG]: No gimbal has been created at GND, so buttons will do nothing\")\n    else:\n        print(\"[DEBUG]: No HelperA2GMeasurements class instance is available\")\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.rx_follow_mode_radio_button_callback","title":"<code>rx_follow_mode_radio_button_callback()</code>","text":"<p>Callback for when the user presses the \"FOLLOW\" radio button in the drone gimbal panel and when it has selected the \"Gremsy H16\" gimbal in the Setup dialog.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def rx_follow_mode_radio_button_callback(self):\n    \"\"\"\n    Callback for when the user presses the \"FOLLOW\" radio button in the drone gimbal panel and when it has selected the \"Gremsy H16\" gimbal in the Setup dialog.\n    \"\"\"\n\n    if hasattr(self, 'myhelpera2g'):\n        try:\n            data = {'MODE': 'FOLLOW'}\n            self.myhelpera2g.socket_send_cmd(type_cmd='SETGIMBAL', data=data)\n            print(f\"[DEBUG]: gimbal mode set to {data['MODE']} from application\")\n        except Exception as e:\n            print(\"[DEBUG]: An error ocurred in the transmission of the Gremsy gimbal mode, \", e)\n    else:\n        print(\"[DEBUG]: No HelperA2GMeasurements class instance is available\")\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.rx_lock_mode_radio_button_callback","title":"<code>rx_lock_mode_radio_button_callback()</code>","text":"<p>Callback for when the user presses the \"LOCK\" radio button in the drone gimbal panel and when it has selected the \"Gremsy H16\" gimbal in the Setup dialog.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def rx_lock_mode_radio_button_callback(self):\n    \"\"\"\n    Callback for when the user presses the \"LOCK\" radio button in the drone gimbal panel and when it has selected the \"Gremsy H16\" gimbal in the Setup dialog.\n    \"\"\"\n\n    if hasattr(self, 'myhelpera2g'):\n        try:\n            data = {'MODE': 'LOCK'}\n            self.myhelpera2g.socket_send_cmd(type_cmd='SETGIMBAL', data=data)\n            print(f\"[DEBUG]: gimbal mode set to {data['MODE']} from application\")\n        except Exception as e:\n            print(\"[DEBUG]: An error ocurred in the transmission of the Gremsy gimbal mode, \", e)\n    else:\n        print(\"[DEBUG]: No HelperA2GMeasurements class instance is available\")\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.showCentralWidget","title":"<code>showCentralWidget()</code>","text":"<p>Creates and shows the panels of the main window according to grid layout defined in this function.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def showCentralWidget(self):\n    \"\"\"\n    Creates and shows the panels of the main window according to grid layout defined in this function.\n    \"\"\"\n\n    #self.original_stdout = sys.stdout\n    self.create_check_connections_panel()\n    #self.create_log_terminal()\n    self.create_Gimbal_GND_panel()\n    self.create_Gimbal_AIR_panel()\n    self.create_fpga_and_sivers_panel()\n    self.create_Planning_Measurements_panel()\n    self.create_GPS_visualization_panel()\n    self.create_pap_plot_panel()\n\n    mainLayout = QGridLayout()\n    mainLayout.addWidget(self.checkConnPanel, 0, 0, 1 , 4)\n    mainLayout.addWidget(self.gimbalTXPanel, 1, 0, 3, 1)\n    mainLayout.addWidget(self.gimbalRXPanel, 1, 1, 3, 1)\n    mainLayout.addWidget(self.fpgaAndSiversSettingsPanel, 1, 2, 3, 2)\n    mainLayout.addWidget(self.papPlotPanel, 4, 0, 7, 2)\n    mainLayout.addWidget(self.gps_vis_panel, 4, 2, 7, 2)\n    mainLayout.addWidget(self.planningMeasurementsPanel, 11, 0, 2, 2)\n    #mainLayout.addWidget(self.log_widget, 11, 2, 2, 2)\n    #self.write_to_log_terminal('Welcome to A2G Measurements Center!')\n\n    self.dummyWidget.setLayout(mainLayout)\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.showSetupMenu","title":"<code>showSetupMenu()</code>","text":"<p>Creates an instance of the SetupWindow class (a Setup dialog), and create attributes for this class with the values the user input in the Setup dialog.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def showSetupMenu(self):\n    \"\"\"\n    Creates an instance of the SetupWindow class (a Setup dialog), and create attributes for this class with the values the user input in the Setup dialog.\n    \"\"\"\n    setupWin = SetupWindow()\n    result = setupWin.exec_()\n\n    # Save the gps attitude offset for both nodes\n    self.gnd_gps_att_offset = setupWin.gnd_gps_att_offset_textEdit\n\n    self.droneGimbalChoice = setupWin.droneGimbalChoiceTDMenu.currentText()\n\n    if setupWin.fm_droneGimbal_TDMenu.currentText() == \"Only elevation\":\n        self.fm_drone_gimbal = {'FMODE': 0x01}\n    elif setupWin.fm_droneGimbal_TDMenu.currentText() == \"Only azimuth\":\n        self.fm_drone_gimbal = {'FMODE': 0x02}\n    elif setupWin.fm_droneGimbal_TDMenu.currentText() == \"Elevation and azimuth\":\n        self.fm_drone_gimbal = {'FMODE': 0x00}\n\n    if setupWin.fm_gndGimbal_TDMenu.currentText() == \"Only elevation\":\n        self.fm_gnd_gimbal = {'FMODE': 0x01}\n    elif setupWin.fm_gndGimbal_TDMenu.currentText() == \"Only azimuth\":\n        self.fm_gnd_gimbal = {'FMODE': 0x02}\n    elif setupWin.fm_gndGimbal_TDMenu.currentText() == \"Elevation and azimuth\":\n        self.fm_gnd_gimbal = {'FMODE': 0x00}\n\n    if setupWin.gnd_mobility_TDMenu.currentText() == \"Static\":\n        self.gnd_mobility = \"Static\"\n        try:\n            self.static_gnd_coords = [float(setupWin.gnd_lat_textEdit.text()), \n                                      float(setupWin.gnd_lon_textEdit.text()),\n                                      float(setupWin.gnd_alt_textEdit.text())] # lat, lon, altitude above sea level\n        except Exception as e:\n            print(\"[DEBUG]: Wrong input ground coords OR no input ground coords\")\n            print(\"[DEBUG]: Enter again the ground coordinates correctly\")\n            return\n    else: \n        self.gnd_mobility = \"Moving\"\n    if setupWin.drone_mobility_TDMenu.currentText() == \"Static\":\n        self.drone_mobility = \"Static\"\n        try:\n            self.static_drone_coords = [float(setupWin.drone_lat_textEdit.text()), \n                                        float(setupWin.drone_lon_textEdit.text()),\n                                        float(setupWin.drone_alt_textEdit.text())] # lat, lon\n        except Exception as e:\n            print(\"[DEBUG]: Wrong input drone coords OR no input drone coords\")\n            print(\"[DEBUG]: Enter again the drone coordinates correctly\")\n            return\n    else:\n        self.drone_mobility = \"Moving\"\n\n    # Remove a previous layout to set it again\n    if self.dummyWidget.layout() is not None:\n        del self.dummyWidget\n        self.setCentralWidget(None)\n        self.dummyWidget = QWidget()\n        self.setCentralWidget(self.dummyWidget)\n        self.init_constants()\n    self.showCentralWidget()\n\n    self.setupDevicesAndMoreAction.setDisabled(True)\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.start_GUI_threads","title":"<code>start_GUI_threads()</code>","text":"<p>Start GUI related threads. This threads are related only to the display of information on the GUI.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def start_GUI_threads(self):\n    \"\"\"\n    Start GUI related threads. This threads are related only to the display of information\n    on the GUI.\n\n    \"\"\"\n\n    print(\"[DEBUG]: Starting GUI threads...\")\n    # Although thus function should be called when a HelperA2GMeasurements class instance has been created, better to do a double check\n    if hasattr(self, 'myhelpera2g'):\n        print(\"[DEBUG]: Detected helper class at creating GUI threads\")\n        if self.gps_display_flag:      \n            print(\"[DEBUG]: GPS dispplay flag activated\")      \n            self.update_vis_time_gps = 1\n            #self.periodical_gps_display_thread = RepeatTimer(self.update_vis_time_gps, self.periodical_gps_display_callback)\n            self.stop_event_gps_display = threading.Event()\n            self.periodical_gps_display_thread = TimerThread(self.stop_event_gps_display, self.update_vis_time_gps)\n            self.periodical_gps_display_thread.update.connect(self.periodical_gps_display_callback)\n            self.periodical_gps_display_thread.start()\n\n        if self.rs2_fm_flag:\n            print(\"[DEBUG]: Gimbal RS2 FM Flag activated\")\n            self.update_time_gimbal_follow = 1\n            self.stop_event_gimbal_follow_thread = threading.Event()\n            self.periodical_gimbal_follow_thread = TimerThread(self.stop_event_gimbal_follow_thread, self.update_time_gimbal_follow)\n            self.periodical_gimbal_follow_thread.update.connect(lambda: self.myhelpera2g.socket_send_cmd(type_cmd='FOLLOWGIMBAL', data=self.fm_gnd_gimbal))\n            self.periodical_gimbal_follow_thread.start()\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.start_meas_button_callback","title":"<code>start_meas_button_callback()</code>","text":"<p>Callback for when the user presses the \"START\" button. Starts sending pilot signal from the TX Sivers.</p> <p>Sends the parameters to the RX sivers (RX RFSoC server) for it to be configured and start to listen incoming signals over the air.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def start_meas_button_callback(self):\n    \"\"\"\n    Callback for when the user presses the \"START\" button. Starts sending pilot signal from the TX Sivers.\n\n    Sends the parameters to the RX sivers (RX RFSoC server) for it to be configured and start to listen incoming signals over the air. \n    \"\"\"\n\n    tx_signal_values, rx_signal_values = self.convert_dB_to_valid_hex_sivers_register_values()\n\n    # Experiment starts\n    self.myhelpera2g.myrfsoc.transmit_signal(carrier_freq=float(self.rf_op_freq_text_edit.text()),\n                                            tx_bb_gain=tx_signal_values['tx_bb_gain'],\n                                            tx_bb_iq_gain=tx_signal_values['tx_bb_iq_gain'],\n                                            tx_bb_phase=tx_signal_values['tx_bb_phase'],\n                                            tx_bfrf_gain=tx_signal_values['tx_bfrf_gain'])\n\n    rx_signal_values['carrier_freq'] = float(self.rf_op_freq_text_edit.text())\n\n    self.myhelpera2g.socket_send_cmd(type_cmd='STARTDRONERFSOC', data=rx_signal_values)\n\n    self.start_meas_togglePushButton.setEnabled(False)\n    self.stop_meas_togglePushButton.setEnabled(True)\n    self.finish_meas_togglePushButton.setEnabled(False)\n    self.update_vis_time_pap = 0.5\n\n    #self.periodical_pap_display_thread = RepeatTimer(self.update_vis_time_pap, self.periodical_pap_display_callback)\n\n    self.stop_event_pap_display_thread = threading.Event()\n    self.periodical_pap_display_thread = TimerThread(self.stop_event_pap_display_thread, self.update_vis_time_pap)\n    self.periodical_pap_display_thread.update.connect(self.periodical_pap_display_callback)\n    self.periodical_pap_display_thread.start()\n    #self.periodical_pap_display_thread = QTimer()\n    #self.periodical_pap_display_thread.timeout.connect(self.periodical_pap_display_callback)\n    #self.periodical_pap_display_thread.start(1000)\n    print(f\"[DEBUG]: This {self.myhelpera2g.ID} started thread periodical_pap_display\")\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.start_thread_drone_gimbal_fm","title":"<code>start_thread_drone_gimbal_fm()</code>","text":"<p>Sets the <code>drone_fm_flag</code> flag in drone's HelperA2GMeasurements class instance, so that the drone periodically send a <code>FOLLOWGIMBAL</code> command to the ground node, for it (drone) node's gimbal to follow the location of the ground node.</p> <p>The periodical <code>FOLLOWGIMBAL</code> command is sent from the drone node main script (<code>drone_main.py</code>).</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def start_thread_drone_gimbal_fm(self):\n    \"\"\"\n    Sets the ``drone_fm_flag`` flag in drone's HelperA2GMeasurements class instance, so that the drone periodically send a ``FOLLOWGIMBAL`` command to the ground node, for it (drone) node's gimbal to follow the location of the ground node.\n\n    The periodical ``FOLLOWGIMBAL`` command is sent from the drone node main script (``drone_main.py``).\n    \"\"\"\n\n    if hasattr(self, 'myhelpera2g'):\n        if self.gnd_mobility == \"Moving\":\n            data = {'X': 0, 'Y': 0, 'Z': 0, 'FMODE': self.fm_drone_gimbal['FMODE'], 'MOBILITY': 0x00}\n        elif self.gnd_mobility == \"Static\":\n            x,y,z = geodetic2geocentric(self.static_gnd_coords[0], self.static_gnd_coords[1], self.static_gnd_coords[2])\n            data = {'X': x, 'Y': y, 'Z': z, 'FMODE': self.fm_drone_gimbal['FMODE'], 'MOBILITY': 0x01}\n        self.myhelpera2g.socket_send_cmd(type_cmd='SETREMOTEFMFLAG', data=data)\n\n    self.start_drone_gimbal_fm_action.setEnabled(False)\n    self.stop_drone_gimbal_fm_action.setEnabled(True)\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.start_thread_gnd_gimbal_fm","title":"<code>start_thread_gnd_gimbal_fm()</code>","text":"<p>Creates and starts a timer thread (periodical callback) to send periodically the <code>FOLLOWGIMBAL</code> command to the drone node, for (this) ground node gimbal to follow the drone node location.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def start_thread_gnd_gimbal_fm(self):\n    \"\"\"\n    Creates and starts a timer thread (periodical callback) to send periodically the ``FOLLOWGIMBAL`` command to the drone node, for (this) ground node gimbal to follow the drone node location. \n    \"\"\"\n\n    if hasattr(self, 'myhelpera2g'):\n        self.update_time_gimbal_follow = 1\n        self.stop_event_gimbal_follow_thread = threading.Event()\n        self.periodical_gimbal_follow_thread = TimerThread(self.stop_event_gimbal_follow_thread, self.update_time_gimbal_follow)\n\n        if self.drone_mobility == \"Moving\":\n            self.periodical_gimbal_follow_thread.update.connect(lambda: self.myhelpera2g.socket_send_cmd(type_cmd='FOLLOWGIMBAL', data=self.fm_gnd_gimbal))\n        elif self.drone_mobility == \"Static\":\n            x,y,z = geodetic2geocentric(self.static_drone_coords[0], self.static_drone_coords[1], self.static_drone_coords[2])\n            data = {'X': x, 'Y': y, 'Z': z, 'FMODE': self.fm_gnd_gimbal['FMODE']}\n            self.periodical_gimbal_follow_thread.update.connect(lambda: self.myhelpera2g.process_answer_get_gps(data=data))\n        self.periodical_gimbal_follow_thread.start()\n\n    self.start_gnd_gimbal_fm_action.setEnabled(False)\n    self.stop_gnd_gimbal_fm_action.setEnabled(True)\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.start_thread_gps_visualization","title":"<code>start_thread_gps_visualization()</code>","text":"<p>Creates and starts a timer thread (repeating callback) to display in the GPS panel updated gps coordinates of drone's location.</p> <p>NOTE: the callback <code>periodical_gps_display_callback</code> works as expected with synthetic gps coordinates. However, this function has not been tested with the actual gps and thus, minor bugs might appear</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def start_thread_gps_visualization(self):\n    \"\"\"\n    Creates and starts a timer thread (repeating callback) to display in the GPS panel updated gps coordinates of drone's location.\n\n    NOTE: *the callback ``periodical_gps_display_callback`` works as expected with synthetic gps coordinates. However, this function has not been tested with the actual gps and thus, minor bugs might appear*\n    \"\"\"\n    #if hasattr(self, 'myhelpera2g'):   \n    self.update_vis_time_gps = 1\n\n    self.periodical_gps_display_thread = QTimer(self)\n    self.periodical_gps_display_thread.timeout.connect(self.periodical_gps_display_callback)\n    self.periodical_gps_display_thread.start(1000*self.update_vis_time_gps)  \n\n    self.start_gps_visualization_action.setEnabled(False)\n    self.stop_gps_visualization_action.setEnabled(True)\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.stop_meas_button_callback","title":"<code>stop_meas_button_callback()</code>","text":"<p>Callback for when the user presses the \"STOP\" button. Sends a <code>STOPDRONERFSOC</code> command to the drone, to stop its rfsoc thread.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def stop_meas_button_callback(self):\n    \"\"\"\n    Callback for when the user presses the \"STOP\" button. Sends a ``STOPDRONERFSOC`` command to the drone, to stop its rfsoc thread.\n    \"\"\"\n\n    self.myhelpera2g.socket_send_cmd(type_cmd='STOPDRONERFSOC')\n    print(\"[DEBUG]: SENT REQUEST to STOP measurement\")\n    self.start_meas_togglePushButton.setEnabled(True)\n    self.stop_meas_togglePushButton.setEnabled(False)\n    self.finish_meas_togglePushButton.setEnabled(True)\n    self.stop_event_pap_display_thread.set()\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.stop_thread_drone_gimbal_fm","title":"<code>stop_thread_drone_gimbal_fm()</code>","text":"<p>Unsets <code>drone_fm_flag</code> in drone's HelperA2GMeasurements class instance, so that the drone's gimbal stops following ground node location.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def stop_thread_drone_gimbal_fm(self):\n    \"\"\"\n    Unsets ``drone_fm_flag`` in drone's HelperA2GMeasurements class instance, so that the drone's gimbal stops following ground node location.\n    \"\"\"\n    if hasattr(self, 'myhelpera2g'):\n        self.myhelpera2g.socket_send_cmd(type_cmd='SETREMOTESTOPFM')\n\n    self.start_drone_gimbal_fm_action.setEnabled(True)\n    self.stop_drone_gimbal_fm_action.setEnabled(False)\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.stop_thread_gnd_gimbal_fm","title":"<code>stop_thread_gnd_gimbal_fm()</code>","text":"<p>Stops the timer thread to send periodic <code>FOLLOWGIMBAL</code> commands to the drone node.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def stop_thread_gnd_gimbal_fm(self):\n    \"\"\"\n    Stops the timer thread to send periodic ``FOLLOWGIMBAL`` commands to the drone node.\n    \"\"\"\n\n    if hasattr(self, 'periodical_gimbal_follow_thread'):\n        if self.periodical_gimbal_follow_thread.isRunning():\n            self.stop_event_gimbal_follow_thread.set()\n\n    self.start_gnd_gimbal_fm_action.setEnabled(True)\n    self.stop_gnd_gimbal_fm_action.setEnabled(False)\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.stop_thread_gps_visualization","title":"<code>stop_thread_gps_visualization()</code>","text":"<p>Stops the timer thread responsible for display gps coordinates in the GPS panel.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def stop_thread_gps_visualization(self):\n    \"\"\"\n    Stops the timer thread responsible for display gps coordinates in the GPS panel.\n    \"\"\"\n    if self.periodical_gps_display_thread.isActive():\n        self.periodical_gps_display_thread.stop()\n\n    self.start_gps_visualization_action.setEnabled(True)\n    self.stop_gps_visualization_action.setEnabled(False)\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.up_button_gimbal_drone_callback","title":"<code>up_button_gimbal_drone_callback()</code>","text":"<p>Callback for when the user presses the \"Left\" button from the Gimbal drone panel. </p> <p>Direction buttons (up, down, left, right) move the gimbal the direction they indicate, by the amount given in the \"Step\" textbox. The movement is relative to the angle before the button was pressed.</p> <p>If no value is provided in the \"Step\" textbox, the gimbal moves a value of 10 degrees in the direction indicated by this button.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def up_button_gimbal_drone_callback(self):\n    \"\"\"\n    Callback for when the user presses the \"Left\" button from the Gimbal drone panel. \n\n    Direction buttons (up, down, left, right) move the gimbal the direction they indicate, by the amount given in the \"Step\" textbox. The movement is relative to the angle before the button was pressed.\n\n    If no value is provided in the \"Step\" textbox, the gimbal moves a value of 10 degrees in the direction indicated by this button.\n    \"\"\"\n    if hasattr(self, 'myhelpera2g'):\n        movement_step = self.rx_step_manual_move_gimbal_text_edit.text()\n        if movement_step != '':\n            try:\n                tmp = int(float(movement_step))\n                incorrect_angle_value = self.checker_gimbal_input_range(tmp)\n                if tmp &lt; 0:\n                    tmp = abs(tmp)\n                    print(\"[DEBUG]: The movement step Textbox in the Gimbal Control Panel is always taken as positive. Direction is given by arrows.\")\n                if self.droneGimbalChoice == \"DJI Ronin RS2\":\n                    data = {'YAW': 0, 'PITCH': tmp*10,'ROLL': 0, 'MODE': 0x00}\n                elif self.droneGimbalChoice == \"Gremsy H16\":    \n                    data = {'YAW': 0, 'PITCH': tmp,'ROLL': 0, 'MODE': 0x00}\n                self.myhelpera2g.socket_send_cmd(type_cmd='SETGIMBAL', data=data)\n                print(f\"[DEBUG]: gimbal moved {movement_step} degs from application\")\n            except Exception as e:\n                    print(\"[DEBUG]: Error executing gimbal movement. Most probably wrong MOVEMENT STEP format, \", e)\n        else:\n            if self.droneGimbalChoice == \"DJI Ronin RS2\":\n                data = {'YAW': 0, 'PITCH': 100, 'ROLL': 0,'MODE': 0x00}\n            elif self.droneGimbalChoice == \"Gremsy H16\":\n                data = {'YAW': 0, 'PITCH': 10, 'ROLL': 0,'MODE': 0x00}\n            self.myhelpera2g.socket_send_cmd(type_cmd='SETGIMBAL', data=data)\n            print(\"[DEBUG]: gimbal moved from application by a predetermined angle of 10 deg, since no angle was specified\")\n    else:\n        print(\"[DEBUG]: No HelperA2GMeasurements class instance is available\")\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.up_button_gimbal_gnd_callback","title":"<code>up_button_gimbal_gnd_callback()</code>","text":"<p>Callback for when the user presses the <code>Up</code> button from the Gimbal GND panel. </p> <p>Direction buttons (up, down, left, right) move the gimbal the direction they indicate, by the amount given in the <code>Step</code> textbox. The movement is relative to the angle before the button was pressed.</p> <p>If no value is provided in the <code>Step</code> textbox, the gimbal moves a value of 10 degrees in the direction indicated by this button.</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def up_button_gimbal_gnd_callback(self):\n    \"\"\"\n    Callback for when the user presses the ``Up`` button from the Gimbal GND panel. \n\n    Direction buttons (up, down, left, right) move the gimbal the direction they indicate, by the amount given in the ``Step`` textbox. The movement is relative to the angle before the button was pressed.\n\n    If no value is provided in the ``Step`` textbox, the gimbal moves a value of 10 degrees in the direction indicated by this button.\n    \"\"\"\n\n    if hasattr(self, 'myhelpera2g'):\n        if hasattr(self.myhelpera2g, 'myGimbal'):\n            movement_step = self.tx_step_manual_move_gimbal_text_edit.text()\n\n            if movement_step != '':\n                try:\n                    tmp = int(float(movement_step))\n                    incorrect_angle_value = self.checker_gimbal_input_range(tmp)\n                    if tmp &lt; 0:\n                        tmp = abs(tmp)\n                        print(\"[DEBUG]: The movement step Textbox in the Gimbal Control Panel is always taken as positive. Direction is given by arrows.\")\n                    self.myhelpera2g.myGimbal.setPosControl(yaw=0, roll=0, pitch=tmp*10, ctrl_byte=0x00)\n                    print(f\"[DEBUG]: gimbal moved -{movement_step} degs from application\")\n                except Exception as e:\n                    print(\"[DEBUG]: Error executing gimbal movement. Most probably wrong MOVEMENT STEP format, \", e)\n            else:\n                self.myhelpera2g.myGimbal.setPosControl(yaw=0, roll=0, pitch=100, ctrl_byte=0x00)\n                print(\"[DEBUG]: gimbal moved from application by a predetermined angle of 10 deg, since no angle was specified\")\n\n        else:\n            print(\"[DEBUG]: No gimbal has been created at GND, so buttons will do nothing\")\n    else:\n        print(\"[DEBUG]: No HelperA2GMeasurements class instance is available\")\n</code></pre>"},{"location":"GUIwidgetGallery/#GUI_A2G_MEAS.WidgetGallery.write_to_log_terminal","title":"<code>write_to_log_terminal(newLine)</code>","text":"<p>New line to be written into the log terminal. The number of new lines it can handle is controlled by the parameter number_lines_log_terminal.</p> <p>TO BE CHECKED: THE NUMBER OF MAX CHARACTERS FOR A LINE HAS TO BE CHECKED IN THE CODE</p> Source code in <code>GUI_A2G_MEAS.py</code> <pre><code>def write_to_log_terminal(self, newLine):\n    '''\n    New line to be written into the log terminal. The number of new lines it can handle is controlled\n    by the parameter number_lines_log_terminal.\n\n    TO BE CHECKED: THE NUMBER OF MAX CHARACTERS FOR A LINE HAS TO BE CHECKED IN THE CODE\n\n    '''\n\n    log_txt = self.log_terminal_txt.splitlines()\n\n    if len(log_txt) &lt; self.number_lines_log_terminal:\n        self.log_terminal_txt = self.log_terminal_txt + newLine + \"\\n\"\n    else:\n        for i in range(len(log_txt)-1, 0, -1):\n            log_txt[i] = log_txt[i-1] + \"\\n\"\n        log_txt[0] = newLine + \"\\n\"\n\n        log_txt = ''.join(log_txt) \n        self.log_terminal_txt = log_txt\n\n    self.log_widget.setPlainText(self.log_terminal_txt)\n</code></pre>"},{"location":"GettingStarted/","title":"Installations","text":"<p>r</p>"},{"location":"GettingStarted/#git","title":"Git","text":"<p>In the <code>.gitignore</code> file the <code>data</code> folder is added to avoid uploading the measured files, since there can be synch troubles due to their size.</p> <p>Measurement files (in the receiver node) will still be saved in the <code>data</code> but won't be uploaded to the Github of the project, as stated before.</p>"},{"location":"GimbalGremsyH16/","title":"Gremsy H16 gimbal","text":"<p>Python Class that works as the driver for the gimbal Gremsy H16.</p> <p>The gimbal should be connected to the host computer through an TTL2USB connection (check \"Manual A2GMeasurements\"). </p> <p>It creates a thread (called here a gimbal thread) to handle the communication between the gimbal and this host computer.</p> <p>Gimbal's rotational speed (both in yaw -azimuth-, and pitch -elevation-) depends on a value between [-100, 100] as this is the natural range of values in most Remote Controllers (i.e. FrSky X8R).</p> <p>Gmbal's rotational speed dependence on the RC controlling interval is neither linear, nor symmetrical:  1. Non-linear:  a change from 10 to 20 is not equivalent to a change from 20 to 30  2. Non-symmetrical: a change from 10 to 20 is not equivalent to a change from -10 to -20. A change from 10 to 20 (or -10 to -20) in yaw is not equivalent to a change from 10 to 20 (or -10 to -20) in pitch.</p> <p>Gimbal's angle (either yaw or pitch) depends on: 1) the RC controlling interval and 2) the time the given RC control value is hold. This dependence is measured as described in \"Manual A2GMeasurements\".</p> <p>Gimbal's angle can only be controlled by using the RC control value and the time the serial SBUS will hold that control value.</p> <p>This class relies on heavily on the <code>SBUSEncoder</code> class, as that is the class decoding the sbus protocol from Gremsy. </p> <p>This class is meant to be equivalent to <code>GimbalRS2</code>. Mainly by implementing the <code>setPosControl</code> for this gimbal.</p> Source code in <code>a2gmeasurements.py</code> <pre><code>class GimbalGremsyH16:\n    \"\"\"\n    Python Class that works as the driver for the gimbal Gremsy H16.\n\n    The gimbal should be connected to the host computer through an TTL2USB connection (check \"Manual A2GMeasurements\"). \n\n    It creates a thread (called here a gimbal thread) to handle the communication between the gimbal and this host computer.\n\n    Gimbal's rotational speed (both in yaw -azimuth-, and pitch -elevation-) depends on a value between [-100, 100] as this is the natural range of values in most Remote Controllers (i.e. FrSky X8R).\n\n    Gmbal's rotational speed dependence on the RC controlling interval is neither linear, nor symmetrical:\n     1. Non-linear:  a change from 10 to 20 is not equivalent to a change from 20 to 30\n     2. Non-symmetrical: a change from 10 to 20 is not equivalent to a change from -10 to -20. A change from 10 to 20 (or -10 to -20) in yaw is not equivalent to a change from 10 to 20 (or -10 to -20) in pitch.\n\n    Gimbal's angle (either yaw or pitch) depends on: 1) the RC controlling interval and 2) the time the given RC control value is hold. This dependence is measured as described in \"Manual A2GMeasurements\".\n\n    Gimbal's angle can only be controlled by using the *RC control value* and the *time* the serial SBUS will hold that control value.\n\n    This class relies on heavily on the ``SBUSEncoder`` class, as that is the class decoding the sbus protocol from Gremsy. \n\n    This class is meant to be equivalent to ``GimbalRS2``. Mainly by implementing the ``setPosControl`` for this gimbal.\n    \"\"\"\n\n    def __init__(self, speed_time_azimuth_table=None, speed_time_elevation_table=None):\n        \"\"\"\n        Constructor for the class. \n\n        Loads the measured angle (yaw and pitch, each one separately) dependence on RC control value and time. Replace ``load_measured_data_august_2023`` or reimplement it if newer/better measurements of this dependence are available. \n\n        Args:\n            speed_time_azimuth_table (numpy.ndarray, optional): array with whose 3 columns are: 1. RC control value (equivalent to speed). 2. Time holding the RC value. 3. Measured azimuth (yaw). Defaults to None.\n            speed_time_elevation_table (numpy.ndarray, optional): array with whose 3 columns are: 1. RC control value (equivalent to speed). 2. Time holding the RC value. 3. Measured elevation (pitch). Defaults to None.\n        \"\"\"\n\n        self.cnt_imu_readings = 0\n\n        if speed_time_azimuth_table is not None:\n            self.speed_time_azimuth_table = speed_time_azimuth_table\n            self.speed_time_elevation_table = speed_time_elevation_table\n        else:\n            #self.load_measured_data_july_2023()\n            self.load_measured_data_august_2023()\n\n        # Assume linear fit:\n        # For a longer range of speeds than the used in the default data, it is very likely that the fit won't be linear\n        self.fit_model_to_gimbal_angular_data(model='gp')    \n        self.start_imu_thread()\n\n    def define_home_position(self):\n        \"\"\"\n        Defines the center of the coordinated system (yaw, pitch). To do so, it checks if the gimbal is moving (in both azimuth and elevation) and if not, read the angles provided by the IMU and set them as the home position. Due to this operation, this function **must** be called in ``__init__`` or before any ``setPosControl`` call.\n\n        As the gimbal controller from the manufacturer can't be accesed, imu readings are not available. An external IMU is required and any cheap raspberry pi pico is capable of providing decent IMU support. Potential magnetic interferences between the IMU readings of the raspberry pi pico and the motors of the gimbal have not been researched.\n\n        **NOTE**: this function *requires to be further tested*, if the Gremsy gimbal is to be used again as part of the channel sounder system. The reason is that when checking if the gimbal is moving, a good tolerated error (tol_err = abs(angle_now - angle_before)) must be set.\n        \"\"\"\n        print(\"[DEBUG]: Defining HOME for Gremsy... This might take a second\")\n\n        start_time = time.time()\n        yaw_before = 1000 # Set it high for first iteration\n        pitch_before = 1000 # Set it high for first iteration\n        cnt = self.cnt_imu_readings\n        DONT_STOP = True\n        tol_err = 2\n        while(DONT_STOP):\n            if cnt != self.cnt_imu_readings:\n                yaw = self.last_imu_reading['YAW']\n                pitch = self.last_imu_reading['PITCH']\n\n                if np.abs(yaw - yaw_before) &lt;= tol_err:\n                    CONDITION_YAW_SATISFIED = True\n                else:\n                    CONDITION_YAW_SATISFIED = False\n\n                if np.abs(pitch - pitch_before) &lt;= tol_err:\n                    CONDITION_PITCH_SATISFIED = True\n                else:\n                    CONDITION_PITCH_SATISFIED = False\n\n                if CONDITION_YAW_SATISFIED and CONDITION_PITCH_SATISFIED:\n                    break        \n\n                yaw_before = yaw\n                pitch_before = pitch\n                cnt = self.cnt_imu_readings\n\n        self.home_position = {'YAW': yaw, 'PITCH': pitch}\n        print(f\"TIME SPENT DEFINE HOME POSITION: {time.time() - start_time}\")\n\n    def start_imu_thread(self, COM_PORT='COM21'):\n        \"\"\"\n        Connects to the IMU and creates a new thread (the imu thread) to read the angle data from the IMU.\n\n        :param COM_PORT: , defaults to 'COM21'\n        :type COM_PORT: str, optional\n\n        Args:\n            COM_PORT (str, optional): port where the IMU is connected. If this host computer's OS is Windows it would be ``COM#``, if it is Linux it would be ``/dev/ttyUSB#``. Defaults to ``COM21``.\n        \"\"\"\n\n        try:\n            self.imu_serial = serial.Serial(COM_PORT, 9600)\n            print(\"[DEBUG]: Connected to IMU\")\n        except Exception as e:\n            print(\"[DEBUG]: Exception when connecting to IMU: \", e)\n        else:\n            try:\n                self.event_stop_thread_imu = threading.Event()                \n                self.thread_read_imu = threading.Thread(target=self.receive_imu_data, args=(self.event_stop_thread_imu,))\n                self.thread_read_imu.start()\n                print(f\"[DEBUG]: READ IMU THREAD STARTED\")\n            except Exception as e:\n                print(\"[DEBUG]: Exception when starting READ IMU thread\")\n        #for (this_port, desc, verbose) in sorted(comports()):\n        #    print(f\"PORT: {this_port}, DESC: {desc}, verbose: {verbose}\")\n\n    def receive_imu_data(self, stop_event):\n        \"\"\"\n        Callback function for the imu thread. Read the yaw, pitch, roll angles and stores them in the attribute ``last_imu_reading`` of this class.\n\n        Args:\n            stop_event (threading.Event): when this is set, this function won't do anything.\n        \"\"\"\n\n        while not stop_event.is_set():\n            data = self.imu_serial.readline().decode('utf-8').strip()\n            data = data.split(',')\n\n            self.last_imu_reading = {'YAW': float(data[0]), 'PITCH': float(data[1]), 'ROLL': float(data[2])}\n            self.cnt_imu_readings = self.cnt_imu_readings + 1\n\n            if self.cnt_imu_readings &gt; 1e12:\n                self.cnt_imu_readings = 0\n\n        #print(f\"YAW: {data[0]}, PITCH: {data[1]}, ROLL: {data[2]}\")\n\n    def stop_thread_imu(self):\n        \"\"\"\n        Stops the imu thread and closed the serial port where the IMU is connected.\n        \"\"\"\n\n        if self.thread_read_imu.is_alive():\n            self.event_stop_thread_imu.set()\n\n        self.imu_serial.close()\n\n    def fit_model_to_gimbal_angular_data(self, model='linear'):\n        \"\"\"\n        Fits a model to the measured angle (yaw, pitch) dependence on time and speed (RC control value). There are two models: a linear model and a gaussian regressor.\n\n        The linear model is suitable specific range of \"speeds\" and time, since the non-linear dependence can be linearized. However, this *range must be defined*.\n\n        For the gaussian regressor, *more training samples (RC control value, time, angle) over the full range are required* to avoid overfitting and bad predicting behaviour.\n\n        There is either a linear or gp model for the RC control positive values and another one for the RC control negative values.\n\n        Args:\n            model (str, optional): either ``linear`` or ``gp``. Defaults to ``linear``.\n        \"\"\"\n\n        # Define the kernel for Gaussian Process Regressor\n        kernel = 1.0 * RBF(length_scale=1.0, length_scale_bounds=(1e-2, 1e2)) + WhiteKernel(noise_level=1e-5, noise_level_bounds=(1e-10, 1e-3))\n\n        is_positive_azimuth = self.speed_time_azimuth_table &gt; 0\n        is_positive_elevation = self.speed_time_elevation_table &gt; 0\n\n        X = self.speed_time_azimuth_table[is_positive_azimuth[:, 0], 0:2]\n        y = np.rad2deg(self.speed_time_azimuth_table[is_positive_azimuth[:, 0], 2])\n        if model =='linear':\n            self.az_speed_pos_regresor = LinearRegression().fit(X, y)\n        elif model == 'gp':\n            self.az_speed_pos_regresor = GaussianProcessRegressor(kernel=kernel, n_restarts_optimizer=10, random_state=42).fit(X, y)\n        self.score_az_speed_pos_regresor = self.az_speed_pos_regresor.score(X, y)\n        print(\"[DEBUG]: POSITIVE SPEEDS (LEFT), AZIMUTH, R^2 Score Linear Reg: \", self.score_az_speed_pos_regresor)\n\n        X = self.speed_time_azimuth_table[~is_positive_azimuth[:, 0], 0:2]\n        y = np.rad2deg(self.speed_time_azimuth_table[~is_positive_azimuth[:, 0], 2])\n        if model == 'linear':\n            self.az_speed_neg_regresor = LinearRegression().fit(X, y)\n        elif model == 'gp':\n            self.az_speed_neg_regresor = GaussianProcessRegressor(kernel=kernel, n_restarts_optimizer=10, random_state=42).fit(X, y)\n        self.score_az_speed_neg_regresor = self.az_speed_neg_regresor.score(X, y)\n        print(\"[DEBUG]: NEGATIVE SPEEDS (RIGHT), AZIMUTH, R^2 Score Linear Reg: \", self.score_az_speed_neg_regresor)\n\n        X = self.speed_time_elevation_table[~is_positive_elevation[:, 0], 0:2]\n        y = np.rad2deg(self.speed_time_elevation_table[~is_positive_elevation[:, 0], 2])\n        if model == 'linear':\n            self.el_speed_neg_regresor = LinearRegression().fit(X, y)\n        elif model == 'gp':\n            self.el_speed_neg_regresor = GaussianProcessRegressor(kernel=kernel, n_restarts_optimizer=10, random_state=42).fit(X, y).fit(X, y)\n        self.score_el_speed_neg_regresor = self.el_speed_neg_regresor.score(X, y)\n        print(\"[DEBUG]: NEGATIVE SPEEDS (DOWN), ELEVATION, R^2 Score Linear Reg: \", self.score_el_speed_neg_regresor)\n\n        X = self.speed_time_elevation_table[is_positive_elevation[:, 0], 0:2]\n        y = np.rad2deg(self.speed_time_elevation_table[is_positive_elevation[:, 0], 2])\n        if model == 'linear':\n            self.el_speed_pos_regresor = LinearRegression().fit(X, y)\n        elif model == 'gp':\n            self.el_speed_pos_regresor = GaussianProcessRegressor(kernel=kernel, n_restarts_optimizer=10, random_state=42).fit(X, y).fit(X, y)\n        self.score_el_speed_pos_regresor = self.el_speed_pos_regresor.score(X, y)\n        print(\"[DEBUG]: POSITIVE SPEEDS (UP), ELEVATION, R^2 Score Linear Reg: \", self.score_el_speed_neg_regresor)\n\n    def setPosControlGPModel(self, yaw=0, pitch=0):\n        \"\"\"\n        Finds the RC control value and time giving the desired yaw (or pitch, or both separately) for the gaussian regressor. \n\n        Uses an iterative approach to find the RC control value and time to hold it by smartly searching in the grid composed by the RC control values and the times to hold it. The initial value of for the \"speed\" (RC control value) influences the convergence of the iterative method.\n\n        NOTE FOR DEVELOPERS: *this function requires*:\n         1. a better grid of measured \"speed\", time, angle. With the actual training samples, the prediction does not give physical consistent results (i.e. the time it takes to move 60 degrees at speed 20 is smaller than the one it takes to move 60 degrees at a lower speed). This is because the grid is coarse and not equally sampled.\n         2. this function should guarantee that the returned time is always positive. Negative times does not make physical sense. Furthermore, it should also guarantee that the time is above a certain threshold (i.e. 2 seconds), during which the gimbal will accelerate until reaching the desired speed. In a realistic gimbal, the acceleration of the gimbal is not infinite. On the contrary, gimbal's speed vs time dependence follows usually a trapezoidal curve, which means that there is some time required (the threshold) for the gimbal to reach the plateau of the trapezoid (desired speed).\n         3. the caller of this function (``setPosControl``) to handle when an exeception is raised.\n\n        Args:\n            yaw (int, optional): desired yaw angle to set in the interval [-180,180]. Defaults to 0.\n            pitch (int, optional): desired pitch angle to set. Defaults to 0.\n\n        Raises:\n            Exception: when the optimization local function ``find_feature_values_for_angle`` does not converge.\n\n        Returns:\n            speed_yaw (float): required RC control value to set yaw.\n            time_yaw (float): required time to set yaw. \n            speed_pitch (float): required RC control value to set pitch\n            time_pitch (float): required time to set pitch.\n        \"\"\"\n\n        start_time = time.time()\n\n        # Define a function to find the corresponding X values for the desired Y\n        def find_feature_values_for_angle(model, desired_angle, suggested_speed):           \n            # Define a function to minimize (difference between predicted and desired Y)\n            def objective_function(x):\n                #x = np.atleast_2d(x)\n                y = np.array([[suggested_speed, x]])\n                return np.abs(model.predict(y) - desired_angle)\n\n            # Initialize with a guess for speed and time\n            initial_guess = 3\n\n            # Use an optimization method to find the feature values that result in the desired yaw angle\n            result = minimize_scalar(objective_function, bounds=(0, 50), method='bounded')\n            #result = minimize(objective_function, initial_guess, method='Nelder-Mead')\n\n            if result.success:\n                return result.x\n            else:\n                raise Exception(\"Optimization did not converge.\")\n\n        total_time = time.time() - start_time\n\n        # Find the corresponding feature values (speed and time) for the desired angle\n        if yaw &gt; 0.0 and yaw &lt; 10:\n            speed_yaw = 10.0\n            time_yaw = find_feature_values_for_angle(self.az_speed_pos_regresor, yaw, speed_yaw)\n        elif yaw &gt;= 10.0 and yaw &lt; 60:\n            speed_yaw = 13.0\n            time_yaw = find_feature_values_for_angle(self.az_speed_neg_regresor, yaw, speed_yaw)\n        elif yaw &gt;= 60:\n            speed_yaw = 15.0\n            time_yaw = find_feature_values_for_angle(self.az_speed_neg_regresor, yaw, speed_yaw)\n        if yaw &lt; 0.0 and yaw &gt; -10:\n            speed_yaw = -3.0\n            time_yaw = find_feature_values_for_angle(self.az_speed_pos_regresor, yaw, speed_yaw)\n        elif yaw &lt;= -10.0 and yaw &gt; -60:\n            speed_yaw = -7.0\n            time_yaw = find_feature_values_for_angle(self.az_speed_neg_regresor, yaw, speed_yaw)\n        elif yaw &lt;= -60:\n            speed_yaw = -10.0\n            time_yaw = find_feature_values_for_angle(self.az_speed_neg_regresor, yaw, speed_yaw)\n        elif yaw == 0.0:\n            speed_yaw = 0\n            time_yaw = 0\n        if pitch &gt; 0.0 and pitch &lt; 10.0:\n            speed_pitch = 5.0\n            time_pitch = find_feature_values_for_angle(self.el_speed_pos_regresor, pitch, speed_pitch)\n        elif pitch &gt;=10 and pitch &lt; 60:\n            speed_pitch = 8.0\n            time_pitch = find_feature_values_for_angle(self.el_speed_pos_regresor, pitch, speed_pitch)\n        elif pitch &gt;= 60:\n            speed_pitch = 10.0\n            time_pitch = find_feature_values_for_angle(self.el_speed_pos_regresor, pitch, speed_pitch)\n        elif pitch &lt; 0.0 and pitch &gt; -10:\n            speed_pitch = -5.0\n            time_pitch = find_feature_values_for_angle(self.el_speed_neg_regresor, pitch, speed_pitch)\n        elif pitch &lt;-10 and pitch &gt; -60:\n            speed_pitch = -8.0\n            time_pitch = find_feature_values_for_angle(self.el_speed_neg_regresor, pitch, speed_pitch)\n        elif pitch &lt;= -60:\n            speed_pitch = -10.0\n            time_pitch = find_feature_values_for_angle(self.el_speed_neg_regresor, pitch, speed_pitch)\n        elif pitch == 0.0:\n            speed_pitch = 0\n            time_pitch = 0\n\n        #print(f\"[DEBUG]: Time it took to find the speed and time corresponding to the DESIRED ANGLE: {total_time}\")\n\n        return speed_yaw, time_yaw, speed_pitch, time_pitch\n\n    def load_measured_drifts(self):\n        \"\"\"\n        Loads measured drift angles from the experiment described on \"Manual A2GMeasurements\".        \n        \"\"\" \n        drift_with_low_speed_counter = [[137, self.gremsy_angle(2, 1.97, 0.10)],\n                                        [144, self.gremsy_angle(1.97, 1.94, 0.10)],\n                                        [145, self.gremsy_angle(1.94, 1.927, 0.10)],\n                                        [156, self.gremsy_angle(1.927, 1.911, 0.10)],\n                                        [164, self.gremsy_angle(1.911, 1.898, 0.10)],\n                                        [148, self.gremsy_angle(1.898, 1.892, 0.10)],\n                                        [164, self.gremsy_angle(1.892, 1.89, 0.10)],\n                                        [176, self.gremsy_angle(1.89, 1.894, 0.10)],\n                                        [185, self.gremsy_angle(1.894, 1.9, 0.10)],\n                                        [159, self.gremsy_angle(1.9, 1.914, 0.10)],\n                                        [159, self.gremsy_angle(1.914, 1.932, 0.10)],\n                                        [146, self.gremsy_angle(1.932, 1.954, 0.10)]]\n\n        drift_without_low_speed_counter = [[28.91, self.gremsy_angle(2, 1.971, 0.10)],\n                                           [28.43, self.gremsy_angle(1.971, 1.95, 0.10)],\n                                           [28.46, self.gremsy_angle(1.95, 1.923, 0.10)],\n                                           [30.14, self.gremsy_angle(1.923, 1.9, 0.10)],\n                                           [29.76, self.gremsy_angle(1.9, 1.888, 0.10)],\n                                           [29.36, self.gremsy_angle(1.888, 1.884, 0.10)],\n                                           [31.41, self.gremsy_angle(1.884, 1.872, 0.10)],\n                                           [31.3, self.gremsy_angle(1.872, 1.881, 0.10)],\n                                           [28.77, self.gremsy_angle(1.881, 1.89, 0.10)],\n                                           [31.56, self.gremsy_angle(1.89, 1.912, 0.10)],\n                                           [29.15, self.gremsy_angle(1.912, 1.935, 0.10)]]\n\n        self.drift_with_low_speed_counter = drift_with_low_speed_counter\n        self.drift_without_low_speed_counter = drift_without_low_speed_counter\n        self.avg_drift_with_low_speed_counter = np.array(drift_with_low_speed_counter).mean(axis=0) # 2D array \n        self.avg_drift_without_low_speed_counter = np.array(drift_without_low_speed_counter).mean(axis=0) # 2D array\n\n    def load_measured_data_july_2023(self):\n        \"\"\"\n        Loads a set of measured data extracted from the experiment described on \"Manual A2GMeasurements\". \n\n        This table contains as columns the speed [-100, 100], time [s], and the azimuth angle computed from the 3 distances (a_{i}, a_{i+1}, b_{i}) described in \"Manual A2GMeasurements\".\n\n        NOTE FOR DEVELOPERS: *the experiment described in* \"Manual A2GMeasurements\" *was done before acquiring the external IMU. With the use of the external IMU a much easier measurement of the yaw and pitch can be done using (and extending) the ``receive_imu_data`` function of this class*.\n        \"\"\"        \n        speed_time_azimuth_table = [[15, 6, self.gremsy_angle(1.903, 1.949, 0.87)], \n                        [15, 7, self.gremsy_angle(1.955, 1.926, 1)],\n                        [15, 8, self.gremsy_angle(2.071, 1.897, 1.19)],\n                        [15, 9, self.gremsy_angle(2.023, 1.949, 1.315)],\n                        [16, 5, self.gremsy_angle(1.879, 2.078, 0.875)],\n                        [16, 6, self.gremsy_angle(1.883, 2.069, 1.025)],\n                        [16, 7, self.gremsy_angle(1.897, 2.219, 1.26)],\n                        [14, 7, self.gremsy_angle(1.886, 1.994, 0.86)],\n                        [14, 8, self.gremsy_angle(1.881, 2.069, 1)],\n                        [14, 9, self.gremsy_angle(1.888, 2.086, 1.134)],\n                        [-14, 4, self.gremsy_angle(1.922, 2.047, 1.255)],\n                        [-14, 5, self.gremsy_angle(1.961, 2.117, 1.59)],\n                        [-14, 6, self.gremsy_angle(2.106, 2.089, 1.93)],\n                        [-13, 4, self.gremsy_angle(2.034, 1.909, 1.165)],\n                        [-13, 5, self.gremsy_angle(2.025, 1.985, 1.44)],\n                        [-13, 6, self.gremsy_angle(2.183, 1.98, 1.79)]]\n        self.speed_time_azimuth_table = np.array(speed_time_azimuth_table)\n\n        speed_time_elevation_table = [[-5, 1, self.gremsy_angle(1.884, 1.882, 0.1)],\n                                            [-5, 2, self.gremsy_angle(1.881, 1.889, 0.175)],\n                                            [-5, 3, self.gremsy_angle(1.89, 1.934, 0.272)],\n                                            [-5, 4, self.gremsy_angle(1.889, 1.891, 0.345)]]\n        self.speed_time_elevation_table = np.array(speed_time_elevation_table)        \n\n    def load_measured_data_august_2023(self):\n        \"\"\"\n        Loads a second set of measured data extracted from the experiment described on \"Manual A2GMeasurements\".\n\n        This table contains as columns the speed [-100, 100], time [s], and the angle (azimuth, elevation) computed from the 3 distances (a_{i}, a_{i+1}, b_{i}) described in \"Manual A2GMeasurements\".\n\n        NOTE FOR DEVELOPERS: *the experiment described in* \"Manual A2GMeasurements\" *was done before acquiring the external IMU. With the use of the external IMU a much easier measurement of the yaw and pitch can be done using (and extending) the ``receive_imu_data`` function of this class*.\n        \"\"\"        \n        speed_time_azimuth_table = [[15, 6, self.gremsy_angle(1.903, 1.949, 0.87)], \n                        [15, 7, self.gremsy_angle(1.955, 1.926, 1)],\n                        [15, 8, self.gremsy_angle(2.071, 1.897, 1.19)],\n                        [15, 9, self.gremsy_angle(2.023, 1.949, 1.315)],\n                        [16, 5, self.gremsy_angle(1.879, 2.078, 0.875)],\n                        [16, 6, self.gremsy_angle(1.883, 2.069, 1.025)],\n                        [16, 7, self.gremsy_angle(1.897, 2.219, 1.26)],\n                        [14, 7, self.gremsy_angle(1.886, 1.994, 0.86)],\n                        [14, 8, self.gremsy_angle(1.881, 2.069, 1)],\n                        [14, 9, self.gremsy_angle(1.888, 2.086, 1.134)],\n                        [-14, 4, self.gremsy_angle(1.922, 2.047, 1.255)],\n                        [-14, 5, self.gremsy_angle(1.961, 2.117, 1.59)],\n                        [-14, 6, self.gremsy_angle(2.106, 2.089, 1.93)],\n                        [-13, 4, self.gremsy_angle(2.034, 1.909, 1.165)],\n                        [-13, 5, self.gremsy_angle(2.025, 1.985, 1.44)],\n                        [-13, 6, self.gremsy_angle(2.183, 1.98, 1.79)],\n                        [-15, 4, self.gremsy_angle(2.38, 1.574, 1.666)],\n                        [-15, 5, self.gremsy_angle(2.183, 1.538, 1.836)],\n                        [-15, 6, self.gremsy_angle(2.183, 1.546, 2.111)],\n                        [-16, 4, self.gremsy_angle(2.183, 1.558, 1.648)],\n                        [-16, 5, self.gremsy_angle(2.183, 1.537, 1.934)],\n                        [-16, 6, self.gremsy_angle(2.183, 1.562, 2.215)],\n                        [-17, 4, self.gremsy_angle(2.183, 1.55, 1.71)],\n                        [-17, 5, self.gremsy_angle(2.183, 1.54, 2.103)],\n                        [-17, 6, self.gremsy_angle(2.183, 1.586, 2.327)],\n                        [-18, 4, self.gremsy_angle(2.183, 1.541, 1.799)],\n                        [-18, 5, self.gremsy_angle(2.183, 1.623, 2.109)],\n                        [-18, 6, self.gremsy_angle(2.183, 1.623, 2.463)],\n                        [-19, 4, self.gremsy_angle(2.183, 1.537, 1.885)],\n                        [-19, 5, self.gremsy_angle(2.183, 1.563, 2.215)],\n                        [-19, 6, self.gremsy_angle(2.183, 1.663, 2.582)],\n                        [-20, 4, self.gremsy_angle(2.183, 1.537, 1.952)],\n                        [-20, 5, self.gremsy_angle(2.183, 1.585, 2.321)],\n                        [-20, 6, self.gremsy_angle(2.183, 1.718, 2.72)]]\n        self.speed_time_azimuth_table = np.array(speed_time_azimuth_table)\n\n        speed_time_elevation_table = [[10, 3, self.gremsy_angle(1.526, 1.529, 0.07)],\n                                        [10, 4, self.gremsy_angle(1.526, 1.531, 0.096)],\n                                        [10, 5, self.gremsy_angle(1.526, 1.532, 0.11)],\n                                        [10, 6, self.gremsy_angle(1.526, 1.533, 0.122)],\n                                        [10, 7, self.gremsy_angle(1.526, 1.537, 0.16)],\n                                        [10, 8, self.gremsy_angle(1.526, 1.540, 0.183)],\n                                        [11, 3, self.gremsy_angle(1.526, 1.543, 0.124)],\n                                        [11, 4, self.gremsy_angle(1.526, 1.548, 0.163)],\n                                        [11, 5, self.gremsy_angle(1.526, 1.542, 0.199)],\n                                        [11, 6, self.gremsy_angle(1.526, 1.554, 0.239)],\n                                        [11, 7, self.gremsy_angle(1.526, 1.548, 0.279)],\n                                        [12, 3, self.gremsy_angle(1.526, 1.538, 0.168)],\n                                        [12, 4, self.gremsy_angle(1.526, 1.545, 0.227)],\n                                        [12, 5, self.gremsy_angle(1.526, 1.555, 0.283)],\n                                        [12, 6, self.gremsy_angle(1.526, 1.568, 0.343)],\n                                        [12, 7, self.gremsy_angle(1.526, 1.580, 0.4)],\n                                        [13, 3, self.gremsy_angle(1.526, 1.548, 0.244)],\n                                        [13, 4, self.gremsy_angle(1.526, 1.56, 0.311)],\n                                        [13, 5, self.gremsy_angle(1.526, 1.578, 0.395)],\n                                        [13, 6, self.gremsy_angle(1.526, 1.598, 0.448)],\n                                        [13, 7, self.gremsy_angle(1.526, 1.656, 0.64)],\n                                        [14, 2, self.gremsy_angle(1.526, 1.542, 0.184)],\n                                        [14, 3, self.gremsy_angle(1.526, 1.558, 0.286)],\n                                        [14, 4, self.gremsy_angle(1.526, 1.578, 0.378)],\n                                        [14, 5, self.gremsy_angle(1.526, 1.603, 0.474)],\n                                        [14, 6, self.gremsy_angle(1.526, 1.635, 0.574)],\n                                        [15, 1, self.gremsy_angle(1.526, 1.531, 0.11)],\n                                        [15, 2, self.gremsy_angle(1.526, 1.542, 0.209)],\n                                        [15, 3, self.gremsy_angle(1.526, 1.565, 0.334)],\n                                        [15, 4, self.gremsy_angle(1.526, 1.594, 0.448)],\n                                        [15, 5, self.gremsy_angle(1.526, 1.63, 0.567)],\n                                        [16, 1, self.gremsy_angle(1.526, 1.533, 0.125)],\n                                        [16, 2, self.gremsy_angle(1.526, 1.549, 0.253)],\n                                        [16, 3, self.gremsy_angle(1.526, 1.575, 0.378)],\n                                        [16, 4, self.gremsy_angle(1.526, 1.614, 0.519)],\n                                        [16, 5, self.gremsy_angle(1.526, 1.666, 0.665)],\n                                        [17, 1, self.gremsy_angle(1.526, 1.535, 0.147)],\n                                        [17, 2, self.gremsy_angle(1.526, 1.557, 0.291)],\n                                        [17, 3, self.gremsy_angle(1.526, 1.59, 0.435)],\n                                        [17, 4, self.gremsy_angle(1.526, 1.642, 0.6)],\n                                        [17, 5, self.gremsy_angle(1.526, 1.708, 0.766)],\n                                        [18, 1, self.gremsy_angle(1.526, 1.537, 0.164)],\n                                        [18, 2, self.gremsy_angle(1.526, 1.563, 0.328)],\n                                        [18, 3, self.gremsy_angle(1.526, 1.608, 0.502)],\n                                        [18, 4, self.gremsy_angle(1.526, 1.676, 0.693)],\n                                        [18, 5, self.gremsy_angle(1.526, 1.761, 0.884)],\n                                        [19, 0.5, self.gremsy_angle(1.526, 1.529, 0.088)],\n                                        [19, 1, self.gremsy_angle(1.526, 1.538, 0.176)],\n                                        [19, 2, self.gremsy_angle(1.526, 1.571, 0.363)],\n                                        [19, 3, self.gremsy_angle(1.526, 1.626, 0.558)],\n                                        [19, 4, self.gremsy_angle(1.526, 1.707, 0.766)],\n                                        [20, 0.5, self.gremsy_angle(1.526, 1.53, 0.1)],\n                                        [20, 1, self.gremsy_angle(1.526, 1.541, 0.2)],\n                                        [20, 2, self.gremsy_angle(1.526, 1.579, 0.395)],\n                                        [20, 3, self.gremsy_angle(1.526, 1.648, 0.616)],\n                                        [20, 4, self.gremsy_angle(1.526, 1.742, 0.845)],\n                                        [-5, 3, self.gremsy_angle(1.769, 1.652, 0.268)],\n                                        [-5, 6, self.gremsy_angle(1.769, 1.58, 0.5)],\n                                        [-5, 7, self.gremsy_angle(1.769, 1.562, 0.575)],\n                                        [-5, 8, self.gremsy_angle(1.769, 1.548, 0.648)],\n                                        [-5, 10, self.gremsy_angle(1.769, 1.534, 0.758)],\n                                        [-6, 3, self.gremsy_angle(1.769, 1.632, 0.324)],\n                                        [-6, 6, self.gremsy_angle(1.769, 1.556, 0.608)],\n                                        [-6, 8, self.gremsy_angle(1.769, 1.531, 0.785)],\n                                        [-6, 10, self.gremsy_angle(1.769, 1.527, 0.958)],\n                                        [-7, 3, self.gremsy_angle(1.769, 1.713, 0.385)],\n                                        [-7, 6, self.gremsy_angle(1.769, 1.534, 0.717)],\n                                        [-7, 8, self.gremsy_angle(1.769, 1.526, 0.925)],\n                                        [-7, 10, self.gremsy_angle(1.769, 1.541, 1.135)],\n                                        [-8, 3, self.gremsy_angle(1.769, 1.599, 0.433)],\n                                        [-8, 6, self.gremsy_angle(1.769, 1.53, 0.983)],\n                                        [-8, 8, self.gremsy_angle(1.769, 1.533, 1.058)],\n                                        [-8, 10, self.gremsy_angle(1.769, 1.574, 1.309)],\n                                        [-9, 3, self.gremsy_angle(1.769, 1.581, 0.496)],\n                                        [-9, 6, self.gremsy_angle(1.769, 1.527, 0.934)],\n                                        [-9, 8, self.gremsy_angle(1.769, 1.554, 1.214)],\n                                        [-9, 9, self.gremsy_angle(1.769, 1.588, 1.364)],\n                                        [-10, 2, self.gremsy_angle(1.769, 1.612, 0.387)],\n                                        [-10, 5, self.gremsy_angle(1.769, 1.527, 0.883)],\n                                        [-10, 7, self.gremsy_angle(1.769, 1.551, 1.197)],\n                                        [-10, 8, self.gremsy_angle(1.769, 1.588, 1.364)],\n                                        [-11, 2, self.gremsy_angle(1.769, 1.601, 0.42)],\n                                        [-11, 5, self.gremsy_angle(1.769, 1.527, 0.96)],\n                                        [-11, 6, self.gremsy_angle(1.769, 1.541, 1.136)],\n                                        [-11, 7, self.gremsy_angle(1.769, 1.577, 1.322)],\n                                        [-12, 2, self.gremsy_angle(1.769, 1.588, 0.467)],\n                                        [-12, 5, self.gremsy_angle(1.769, 1.532, 1.048)],\n                                        [-12, 6, self.gremsy_angle(1.769, 1.559, 1.247)],\n                                        [-12, 7, self.gremsy_angle(1.769, 1.611, 1.446)],\n                                        [-13, 2, self.gremsy_angle(1.769, 1.579, 0.502)],\n                                        [-13, 5, self.gremsy_angle(1.769, 1.542, 1.144)],\n                                        [-13, 6, self.gremsy_angle(1.769, 1.588, 1.363)],\n                                        [-13, 7, self.gremsy_angle(1.769, 1.672, 1.611)],\n                                        [-14, 2, self.gremsy_angle(1.769, 1.572, 0.534)],\n                                        [-14, 5, self.gremsy_angle(1.769, 1.558, 1.231)],\n                                        [-14, 6, self.gremsy_angle(1.769, 1.624, 1.483)],\n                                        [-14, 7, self.gremsy_angle(1.769, 1.672, 1.752)],\n                                        [-15, 2, self.gremsy_angle(1.769, 1.565, 0.559)],\n                                        [-15, 4, self.gremsy_angle(1.769, 1.534, 1.069)],\n                                        [-15, 5, self.gremsy_angle(1.769, 1.58, 1.328)],\n                                        [-15, 6, self.gremsy_angle(1.769, 1.666, 1.6)],\n                                        [-16, 2, self.gremsy_angle(1.769, 1.558, 0.601)],\n                                        [-16, 4, self.gremsy_angle(1.769, 1.541, 1.136)],\n                                        [-16, 5, self.gremsy_angle(1.769, 1.604, 1.42)],\n                                        [-16, 6, self.gremsy_angle(1.769, 1.722, 1.73)],\n                                        [-17, 2, self.gremsy_angle(1.769, 1.55, 0.641)],\n                                        [-17, 4, self.gremsy_angle(1.769, 1.554, 1.212)],\n                                        [-17, 5, self.gremsy_angle(1.769, 1.634, 1.512)],\n                                        [-17, 6, self.gremsy_angle(1.769, 1.74, 1.771)],\n                                        [-18, 1, self.gremsy_angle(1.769, 1.623, 0.355)],\n                                        [-18, 3, self.gremsy_angle(1.769, 1.528, 0.98)],\n                                        [-18, 4, self.gremsy_angle(1.769, 1.568, 1.284)],\n                                        [-18, 5, self.gremsy_angle(1.769, 1.677, 1.625)],\n                                        [-19, 1, self.gremsy_angle(1.769, 1.615, 0.38)],\n                                        [-19, 3, self.gremsy_angle(1.769, 1.531, 1.031)],\n                                        [-19, 4, self.gremsy_angle(1.769, 1.591, 1.374)],\n                                        [-19, 5, self.gremsy_angle(1.769, 1.726, 1.774)],\n                                        [-20, 1, self.gremsy_angle(1.769, 1.609, 0.401)],\n                                        [-20, 3, self.gremsy_angle(1.769, 1.536, 1.086)],\n                                        [-20, 4, self.gremsy_angle(1.769, 1.613, 1.451)],\n                                        [-20, 5, self.gremsy_angle(1.769, 1.737, 1.764)]]\n        self.speed_time_elevation_table = np.array(speed_time_elevation_table)\n\n    def gremsy_angle(self, a_i, a_ip, b_i):\n        \"\"\"\n        Computes the angle between the sides of the triangle given by a_i and  a_i+1. The opposite side to the angle computed is the one defined by b_i. \n\n        A definition of this distances can be found in \"Manual A2GMeasurements\".\n\n        NOTE FOR DEVELOPERS: *the experiment described in * \"Manual A2GMeasurements\" *was done before acquiring the external IMU. With the use of the external IMU a much easier measurement of the yaw and pitch can be done using (and extending) the ``receive_imu_data`` function of this class*.\n\n        Args:\n            a_i (float): defined in \"Manual A2GMeasurements\".\n            a_ip (float): defined in \"Manual A2GMeasurements\".\n            b_i (float): defined in \"Manual A2GMeasurements\".\n\n        Returns:\n            Radians (float): mentioned angle in radians.\n        \"\"\"\n\n        tmp = (a_i**2 + a_ip**2 - b_i**2)/(2*a_i*a_ip)\n        return np.arccos(tmp)\n\n    def plot_linear_reg_on_near_domain(self, loaded='august'):\n        \"\"\"\n        Generates a figure with 3 subplots with measured values (default measured values or new values measured for more (speed, time) tuples given as a parameter to the class) and with linear regression model applied to the measured values.\n\n        1. 3D Scatter Plot of (speed, time, angle) for speed &gt; 0 and angle -&gt; azimuth \n        2. 3D Scatter Plot of (speed, time, angle) for speed &lt; 0 and angle -&gt; azimuth \n        3. 3D Scatter Plot of (speed, time, angle) for speed &lt; 0 and angle -&gt; elevation\n\n        If ``loaded`` is august then the figure has 4 subplots, with the 4th being\n        4. 3D Scatter Plot of (speed, time, angle) for speed &gt; 0 and angle -&gt; elevation\n\n        Args:\n            loaded (str, optional): which table loaded: the one from ``load_measured_data_july_2023`` or the one from ``load_measured_data_august_2023``. Defaults to ``august``.\n        \"\"\"\n\n        is_positive_azimuth = self.speed_time_azimuth_table &gt; 0\n        is_positive_elevation = self.speed_time_elevation_table &gt; 0       \n\n        # We are going to use multiple if - else statements of the same kind just to maintain some readibility of the code\n        if loaded == 'august':\n            fig = make_subplots(rows=2, cols=2, specs=[[{\"type\": \"scene\"}, {\"type\": \"scene\"}], [{\"type\": \"scene\"}, {\"type\": \"scene\"}]],\n                                subplot_titles=(\"Pos. Speed - Azimuth\", \"Neg. Speed - Azimuth\", \"Neg. Speed - Elevation\", \"Pos. Speed - Elevation\"))\n        else:\n            fig = make_subplots(rows=1, cols=3, specs=[[{\"type\": \"scene\"}, {\"type\": \"scene\"}, {\"type\": \"scene\"}]],\n                                subplot_titles=(\"Pos. Speed - Azimuth\", \"Neg. Speed - Azimuth\", \"Neg. Speed - Elevation\"))\n\n        X, Y = np.meshgrid(np.linspace(10, 20, num=11), np.linspace(5, 9, num=5))\n        XY = np.c_[X.flatten(), Y.flatten()]\n        Z = self.az_speed_pos_regresor.predict(XY)        \n\n        fig.add_trace(go.Scatter3d(mode='markers', x=XY[:, 0], y=XY[:, 1], z=Z, marker=dict(color='blue', size=5,), name='Extrapolated', showlegend=True), row=1, col=1)\n        fig.add_trace(go.Scatter3d(mode='markers', x=self.speed_time_azimuth_table[is_positive_azimuth[:, 0], 0], y=self.speed_time_azimuth_table[is_positive_azimuth[:, 0], 1],\n                z=np.rad2deg(self.speed_time_azimuth_table[is_positive_azimuth[:, 0], 2]), marker=dict(color='red', size=3,), name='Measured', showlegend=True), row=1, col=1)\n\n        X, Y = np.meshgrid(np.linspace(-20, -10, num=11), np.linspace(4, 6, num=3))    \n        XY = np.c_[X.flatten(), Y.flatten()]\n        Z = self.az_speed_neg_regresor.predict(XY)\n\n        fig.add_trace(go.Scatter3d(mode='markers', x=XY[:, 0], y=XY[:, 1], z=Z, marker=dict(color='blue', size=5,), name='Extrapolated', showlegend=True), row=1, col=2)\n        fig.add_trace(go.Scatter3d(mode='markers', x=self.speed_time_azimuth_table[~is_positive_azimuth[:, 0], 0], y=self.speed_time_azimuth_table[~is_positive_azimuth[:, 0], 1],\n                z=np.rad2deg(self.speed_time_azimuth_table[~is_positive_azimuth[:, 0], 2]), marker=dict(color='red', size=3,), name='Measured', showlegend=True), row=1, col=2)\n\n        if loaded == 'august':\n            X, Y = np.meshgrid(np.linspace(-20, -5, num=16), np.linspace(1, 10, num=10))\n            nrow = 2\n            ncol = 1\n        else:\n            X, Y = np.meshgrid(np.linspace(-10, -5, num=6), np.linspace(1, 4, num=4))\n            nrow = 1\n            ncol = 3\n        XY = np.c_[X.flatten(), Y.flatten()]\n        Z = self.el_speed_neg_regresor.predict(XY)\n\n        fig.add_trace(go.Scatter3d(mode='markers', x=XY[:, 0], y=XY[:, 1], z=Z, marker=dict(color='blue', size=5,), name='Extrapolated', showlegend=True), row=nrow, col=ncol)\n        fig.add_trace(go.Scatter3d(mode='markers', x=self.speed_time_elevation_table[~is_positive_elevation[:, 0], 0], y=self.speed_time_elevation_table[~is_positive_elevation[:, 0], 1],\n                z=np.rad2deg(self.speed_time_elevation_table[~is_positive_elevation[:, 0], 2]), marker=dict(color='red', size=3,), name='Measured', showlegend=True), row=nrow, col=ncol)\n\n        if loaded == 'august':\n            X, Y = np.meshgrid(np.linspace(10, 20, num=11), np.linspace(0, 9, num=10))\n            XY = np.c_[X.flatten(), Y.flatten()]\n            Z = self.el_speed_pos_regresor.predict(XY)\n\n            fig.add_trace(go.Scatter3d(mode='markers', x=XY[:, 0], y=XY[:, 1], z=Z, marker=dict(color='blue', size=5,), name='Extrapolated', showlegend=True), row=2, col=2)\n            fig.add_trace(go.Scatter3d(mode='markers', x=self.speed_time_elevation_table[is_positive_elevation[:, 0], 0], y=self.speed_time_elevation_table[is_positive_elevation[:, 0], 1],\n                    z=np.rad2deg(self.speed_time_elevation_table[is_positive_elevation[:, 0], 2]), marker=dict(color='red', size=3,), name='Measured', showlegend=True), row=2, col=2)\n\n        fig.update_scenes(xaxis=dict(backgroundcolor=\"rgba(0, 0, 0,0)\", gridcolor=\"rgba(1, 1, 1, 0.1)\", showbackground=True, zerolinecolor=\"black\",title='Speed',),\n                        yaxis=dict(backgroundcolor=\"rgba(0, 0, 0,0)\", gridcolor=\"rgba(1, 1, 1, 0.1)\", showbackground=True, zerolinecolor=\"black\", title='Time [s]', ),\n                        zaxis=dict(backgroundcolor=\"rgba(0, 0, 0,0)\", gridcolor=\"rgba(1, 1, 1, 0.1)\", showbackground=True, zerolinecolor=\"black\", title='Angle [s]'),\n                        row=1, col=1,)\n        fig.update_scenes(xaxis=dict(backgroundcolor=\"rgba(0, 0, 0,0)\", gridcolor=\"rgba(1, 1, 1, 0.1)\", showbackground=True, zerolinecolor=\"black\",title='Speed',),\n                        yaxis=dict(backgroundcolor=\"rgba(0, 0, 0,0)\", gridcolor=\"rgba(1, 1, 1, 0.1)\", showbackground=True, zerolinecolor=\"black\", title='Time [s]', ),\n                        zaxis=dict(backgroundcolor=\"rgba(0, 0, 0,0)\", gridcolor=\"rgba(1, 1, 1, 0.1)\", showbackground=True, zerolinecolor=\"black\", title='Angle [s]'),\n                        row=1, col=2,)\n        fig.update_scenes(xaxis=dict(backgroundcolor=\"rgba(0, 0, 0,0)\", gridcolor=\"rgba(1, 1, 1, 0.1)\", showbackground=True, zerolinecolor=\"black\",title='Speed',),\n                        yaxis=dict(backgroundcolor=\"rgba(0, 0, 0,0)\", gridcolor=\"rgba(1, 1, 1, 0.1)\", showbackground=True, zerolinecolor=\"black\", title='Time [s]', ),\n                        zaxis=dict(backgroundcolor=\"rgba(0, 0, 0,0)\", gridcolor=\"rgba(1, 1, 1, 0.1)\", showbackground=True, zerolinecolor=\"black\", title='Angle [s]'),\n                        row=1, col=3,)\n\n        fig.update_layout(autosize=False, width=1400, height=800, margin=dict(l=50, r=50, t=50, b=50),)\n        fig.show()\n\n    def start_thread_gimbal(self):\n        \"\"\"\n        Creates an instance of the ``SBUSEncoder`` class responsible for encoding the actual serial signal used by sbus protocol to set an RC control value.\n\n        By creating such instance, the gremsy gimbal thread is created and started.\n        \"\"\"\n\n        self.sbus = SBUSEncoder()\n        self.sbus.start_sbus(serial_interface='COM20', period_packet=0.015)\n\n        self.define_home_position()\n\n    def setPosControl(self, yaw, pitch, roll=0, mode=0x00, model='linear'):\n        \"\"\"\n        Moves Gremsy H16 gimbal by the input angle. This function works as the equivalent to the ``setPosControl`` function of the class ``GimbalRS2``. If movement is desired in both yaw and pitch, the gimbal will move first in either axis (i.e. yaw) and after finishing the that movement, it will move in the other axis (i.e. pitch).\n\n        If the linear model is used: this function sets an RC control value (\"speed\") and finds the corresponding time, given the angle desired to be set.\n\n        If the gp model is used: this function calls ``setPosControlGPModel`` to get the RC control value and time, corresponding to the input angle.\n\n        For a more accurate gimbal angle movement: \n\n        1. Provide a finer and equally sampled grid of RC control value, time with its corresponding measured angle.\n        2. Modify ``fit_model_to_gimbal_angular_data`` to tune parameters of the gp model (if gp model is chosen).\n        3. Modify  ``setPosControlGPModel`` (if gp model is chosen) if a better logic for getting RC control values and times from a given angle is available.\n\n        Args:\n            yaw (float): yaw angle (in degrees) to be set. Valid range between [-180, 180].\n            pitch (float): pitch angle (in degrees) to be set. Valid range between [-90, 90].\n            roll (int, optional): roll angle (in degrees) to be set. Roll angle is not used because desired movement of the gimbal only requires yaw and pitch angles. Defaults to 0.\n            mode (hexadecimal, optional): to be implemented. The idea is to have two modes as in the GimbalRS2 class: ``relative`` and ``absolute``. Defaults to 0x00.\n            model (str, optional): ``linear`` or ``gp`` model for the angle dependence on the RC control value and the time to hold it. For the ``gp`` model, the functionality must be implemented. Defaults to 'linear'.\n        \"\"\"\n\n        if model == 'linear':\n            # Choose speed for yaw movement\n            if yaw &gt; 0:\n                speed_yaw = -11\n\n                # Linear regresion model for angle dependence. If different, change this line\n                time_yaw_2_move = (yaw - self.az_speed_neg_regresor.coef_[0]*speed_yaw - self.az_speed_neg_regresor.intercept_)/self.az_speed_neg_regresor.coef_[1]\n            elif yaw &lt; 0:\n                speed_yaw = 15\n\n                # Linear regresion model for angle dependence. If different, change this line\n                time_yaw_2_move = (np.abs(yaw) - self.az_speed_pos_regresor.coef_[0]*speed_yaw - self.az_speed_pos_regresor.intercept_)/self.az_speed_pos_regresor.coef_[1]\n            elif yaw == 0:\n                time_yaw_2_move = 0\n\n            # Choose speed for pitch movement\n            if pitch &gt; 0:\n                #print(\"[DEBUG]: Only negative pitch values are allowed\")\n                speed_pitch = 10\n                time_pitch_2_move = (pitch - self.el_speed_pos_regresor.coef_[0]*speed_pitch - self.el_speed_pos_regresor.intercept_)/self.el_speed_pos_regresor.coef_[1]\n                #return\n            elif pitch &lt; 0:\n                speed_pitch = -5\n                time_pitch_2_move = (np.abs(pitch) - self.el_speed_neg_regresor.coef_[0]*speed_pitch - self.el_speed_neg_regresor.intercept_)/self.el_speed_neg_regresor.coef_[1]\n            elif pitch == 0:\n                time_pitch_2_move = 0\n\n        elif model == 'gp':\n            if yaw == 0:\n                yaw = None\n            else:\n                yaw = float(yaw)\n            if pitch == 0:\n                pitch = None\n            else:\n                pitch = float(pitch)\n\n            speed_yaw, time_yaw_2_move, speed_pitch, time_pitch_2_move = self.setPosControlGPModel(yaw=yaw, pitch=yaw)\n\n        if (time_yaw_2_move &gt; 0) and (time_pitch_2_move &gt; 0):\n            print(\"[DEBUG]: Gremsy H16 moves in yaw first: TIME to complete movement: \", time_yaw_2_move)\n            self.sbus.move_gimbal(0, speed_yaw, time_yaw_2_move)\n            print(\"[DEBUG]: Gremsy H16 moves in elevation second: TIME to complete movement: \", time_pitch_2_move)\n            self.sbus.move_gimbal(speed_pitch, 0, time_pitch_2_move)\n        elif (time_yaw_2_move &gt; 0) and (time_pitch_2_move &lt;= 0):\n            print(\"[DEBUG]: Gremsy H16 moves in yaw: TIME to complete movement: \", time_yaw_2_move)\n            self.sbus.move_gimbal(0, speed_yaw, time_yaw_2_move)\n        elif (time_yaw_2_move &lt;= 0) and (time_pitch_2_move &gt; 0):\n            print(\"[DEBUG]: Gremsy H16 moves in elevation: TIME to complete movement: \", time_pitch_2_move)\n            self.sbus.move_gimbal(speed_pitch, 0, time_pitch_2_move)\n        elif (time_yaw_2_move &lt;= 0) and (time_pitch_2_move &lt;= 0):\n            print(\"[DEBUG]: Gremsy H16 will not move\")\n            return\n\n    def stop_thread_gimbal(self):\n        \"\"\"\n        Stops the imu thread and the ``SBUSEncoder`` gremsy gimbal thread.\n        \"\"\"\n        self.stop_thread_imu()\n        self.sbus.stop_updating()\n\n    def control_power_motors(self, power='on'):\n        \"\"\"\n        Turns gremsy gimbal motors on or off. This function is a wrapper of ``turn_on_motors`` an ``turn_off_motors`` of the ``SBUSEncoder`` class.\n\n        Args:\n            power (str, optional): ``on`` to power the motors, or ``off`` to shut them down. Defaults to 'on'.\n        \"\"\"\n\n        if power == 'on':\n            self.sbus.turn_on_motors()\n        elif power == 'off':\n            self.sbus.turn_off_motors()\n\n    def change_gimbal_mode(self, mode='LOCK'):\n        \"\"\"\n        Changes Gremsy gimbal mode. Available modes are: 'Lock' and 'Follow' (and motors off). Brief description of the modes is on the manual of the gimbal provided by the manufacturer.\n\n        Args:\n            mode (str, optional): either ``LOCK`` or ``FOLLOW``. Check the manual of the Gremsy H16 gimbal to understand its modes. Defaults to ``LOCK``.\n        \"\"\"\n\n        self.sbus.change_mode(mode=mode)\n        self.sbus.MODE = mode\n</code></pre>"},{"location":"GimbalGremsyH16/#a2gmeasurements.GimbalGremsyH16.__init__","title":"<code>__init__(speed_time_azimuth_table=None, speed_time_elevation_table=None)</code>","text":"<p>Constructor for the class. </p> <p>Loads the measured angle (yaw and pitch, each one separately) dependence on RC control value and time. Replace <code>load_measured_data_august_2023</code> or reimplement it if newer/better measurements of this dependence are available. </p> <p>Parameters:</p> Name Type Description Default <code>speed_time_azimuth_table</code> <code>ndarray</code> <p>array with whose 3 columns are: 1. RC control value (equivalent to speed). 2. Time holding the RC value. 3. Measured azimuth (yaw). Defaults to None.</p> <code>None</code> <code>speed_time_elevation_table</code> <code>ndarray</code> <p>array with whose 3 columns are: 1. RC control value (equivalent to speed). 2. Time holding the RC value. 3. Measured elevation (pitch). Defaults to None.</p> <code>None</code> Source code in <code>a2gmeasurements.py</code> <pre><code>def __init__(self, speed_time_azimuth_table=None, speed_time_elevation_table=None):\n    \"\"\"\n    Constructor for the class. \n\n    Loads the measured angle (yaw and pitch, each one separately) dependence on RC control value and time. Replace ``load_measured_data_august_2023`` or reimplement it if newer/better measurements of this dependence are available. \n\n    Args:\n        speed_time_azimuth_table (numpy.ndarray, optional): array with whose 3 columns are: 1. RC control value (equivalent to speed). 2. Time holding the RC value. 3. Measured azimuth (yaw). Defaults to None.\n        speed_time_elevation_table (numpy.ndarray, optional): array with whose 3 columns are: 1. RC control value (equivalent to speed). 2. Time holding the RC value. 3. Measured elevation (pitch). Defaults to None.\n    \"\"\"\n\n    self.cnt_imu_readings = 0\n\n    if speed_time_azimuth_table is not None:\n        self.speed_time_azimuth_table = speed_time_azimuth_table\n        self.speed_time_elevation_table = speed_time_elevation_table\n    else:\n        #self.load_measured_data_july_2023()\n        self.load_measured_data_august_2023()\n\n    # Assume linear fit:\n    # For a longer range of speeds than the used in the default data, it is very likely that the fit won't be linear\n    self.fit_model_to_gimbal_angular_data(model='gp')    \n    self.start_imu_thread()\n</code></pre>"},{"location":"GimbalGremsyH16/#a2gmeasurements.GimbalGremsyH16.change_gimbal_mode","title":"<code>change_gimbal_mode(mode='LOCK')</code>","text":"<p>Changes Gremsy gimbal mode. Available modes are: 'Lock' and 'Follow' (and motors off). Brief description of the modes is on the manual of the gimbal provided by the manufacturer.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>str</code> <p>either <code>LOCK</code> or <code>FOLLOW</code>. Check the manual of the Gremsy H16 gimbal to understand its modes. Defaults to <code>LOCK</code>.</p> <code>'LOCK'</code> Source code in <code>a2gmeasurements.py</code> <pre><code>def change_gimbal_mode(self, mode='LOCK'):\n    \"\"\"\n    Changes Gremsy gimbal mode. Available modes are: 'Lock' and 'Follow' (and motors off). Brief description of the modes is on the manual of the gimbal provided by the manufacturer.\n\n    Args:\n        mode (str, optional): either ``LOCK`` or ``FOLLOW``. Check the manual of the Gremsy H16 gimbal to understand its modes. Defaults to ``LOCK``.\n    \"\"\"\n\n    self.sbus.change_mode(mode=mode)\n    self.sbus.MODE = mode\n</code></pre>"},{"location":"GimbalGremsyH16/#a2gmeasurements.GimbalGremsyH16.control_power_motors","title":"<code>control_power_motors(power='on')</code>","text":"<p>Turns gremsy gimbal motors on or off. This function is a wrapper of <code>turn_on_motors</code> an <code>turn_off_motors</code> of the <code>SBUSEncoder</code> class.</p> <p>Parameters:</p> Name Type Description Default <code>power</code> <code>str</code> <p><code>on</code> to power the motors, or <code>off</code> to shut them down. Defaults to 'on'.</p> <code>'on'</code> Source code in <code>a2gmeasurements.py</code> <pre><code>def control_power_motors(self, power='on'):\n    \"\"\"\n    Turns gremsy gimbal motors on or off. This function is a wrapper of ``turn_on_motors`` an ``turn_off_motors`` of the ``SBUSEncoder`` class.\n\n    Args:\n        power (str, optional): ``on`` to power the motors, or ``off`` to shut them down. Defaults to 'on'.\n    \"\"\"\n\n    if power == 'on':\n        self.sbus.turn_on_motors()\n    elif power == 'off':\n        self.sbus.turn_off_motors()\n</code></pre>"},{"location":"GimbalGremsyH16/#a2gmeasurements.GimbalGremsyH16.define_home_position","title":"<code>define_home_position()</code>","text":"<p>Defines the center of the coordinated system (yaw, pitch). To do so, it checks if the gimbal is moving (in both azimuth and elevation) and if not, read the angles provided by the IMU and set them as the home position. Due to this operation, this function must be called in <code>__init__</code> or before any <code>setPosControl</code> call.</p> <p>As the gimbal controller from the manufacturer can't be accesed, imu readings are not available. An external IMU is required and any cheap raspberry pi pico is capable of providing decent IMU support. Potential magnetic interferences between the IMU readings of the raspberry pi pico and the motors of the gimbal have not been researched.</p> <p>NOTE: this function requires to be further tested, if the Gremsy gimbal is to be used again as part of the channel sounder system. The reason is that when checking if the gimbal is moving, a good tolerated error (tol_err = abs(angle_now - angle_before)) must be set.</p> Source code in <code>a2gmeasurements.py</code> <pre><code>def define_home_position(self):\n    \"\"\"\n    Defines the center of the coordinated system (yaw, pitch). To do so, it checks if the gimbal is moving (in both azimuth and elevation) and if not, read the angles provided by the IMU and set them as the home position. Due to this operation, this function **must** be called in ``__init__`` or before any ``setPosControl`` call.\n\n    As the gimbal controller from the manufacturer can't be accesed, imu readings are not available. An external IMU is required and any cheap raspberry pi pico is capable of providing decent IMU support. Potential magnetic interferences between the IMU readings of the raspberry pi pico and the motors of the gimbal have not been researched.\n\n    **NOTE**: this function *requires to be further tested*, if the Gremsy gimbal is to be used again as part of the channel sounder system. The reason is that when checking if the gimbal is moving, a good tolerated error (tol_err = abs(angle_now - angle_before)) must be set.\n    \"\"\"\n    print(\"[DEBUG]: Defining HOME for Gremsy... This might take a second\")\n\n    start_time = time.time()\n    yaw_before = 1000 # Set it high for first iteration\n    pitch_before = 1000 # Set it high for first iteration\n    cnt = self.cnt_imu_readings\n    DONT_STOP = True\n    tol_err = 2\n    while(DONT_STOP):\n        if cnt != self.cnt_imu_readings:\n            yaw = self.last_imu_reading['YAW']\n            pitch = self.last_imu_reading['PITCH']\n\n            if np.abs(yaw - yaw_before) &lt;= tol_err:\n                CONDITION_YAW_SATISFIED = True\n            else:\n                CONDITION_YAW_SATISFIED = False\n\n            if np.abs(pitch - pitch_before) &lt;= tol_err:\n                CONDITION_PITCH_SATISFIED = True\n            else:\n                CONDITION_PITCH_SATISFIED = False\n\n            if CONDITION_YAW_SATISFIED and CONDITION_PITCH_SATISFIED:\n                break        \n\n            yaw_before = yaw\n            pitch_before = pitch\n            cnt = self.cnt_imu_readings\n\n    self.home_position = {'YAW': yaw, 'PITCH': pitch}\n    print(f\"TIME SPENT DEFINE HOME POSITION: {time.time() - start_time}\")\n</code></pre>"},{"location":"GimbalGremsyH16/#a2gmeasurements.GimbalGremsyH16.fit_model_to_gimbal_angular_data","title":"<code>fit_model_to_gimbal_angular_data(model='linear')</code>","text":"<p>Fits a model to the measured angle (yaw, pitch) dependence on time and speed (RC control value). There are two models: a linear model and a gaussian regressor.</p> <p>The linear model is suitable specific range of \"speeds\" and time, since the non-linear dependence can be linearized. However, this range must be defined.</p> <p>For the gaussian regressor, more training samples (RC control value, time, angle) over the full range are required to avoid overfitting and bad predicting behaviour.</p> <p>There is either a linear or gp model for the RC control positive values and another one for the RC control negative values.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>either <code>linear</code> or <code>gp</code>. Defaults to <code>linear</code>.</p> <code>'linear'</code> Source code in <code>a2gmeasurements.py</code> <pre><code>def fit_model_to_gimbal_angular_data(self, model='linear'):\n    \"\"\"\n    Fits a model to the measured angle (yaw, pitch) dependence on time and speed (RC control value). There are two models: a linear model and a gaussian regressor.\n\n    The linear model is suitable specific range of \"speeds\" and time, since the non-linear dependence can be linearized. However, this *range must be defined*.\n\n    For the gaussian regressor, *more training samples (RC control value, time, angle) over the full range are required* to avoid overfitting and bad predicting behaviour.\n\n    There is either a linear or gp model for the RC control positive values and another one for the RC control negative values.\n\n    Args:\n        model (str, optional): either ``linear`` or ``gp``. Defaults to ``linear``.\n    \"\"\"\n\n    # Define the kernel for Gaussian Process Regressor\n    kernel = 1.0 * RBF(length_scale=1.0, length_scale_bounds=(1e-2, 1e2)) + WhiteKernel(noise_level=1e-5, noise_level_bounds=(1e-10, 1e-3))\n\n    is_positive_azimuth = self.speed_time_azimuth_table &gt; 0\n    is_positive_elevation = self.speed_time_elevation_table &gt; 0\n\n    X = self.speed_time_azimuth_table[is_positive_azimuth[:, 0], 0:2]\n    y = np.rad2deg(self.speed_time_azimuth_table[is_positive_azimuth[:, 0], 2])\n    if model =='linear':\n        self.az_speed_pos_regresor = LinearRegression().fit(X, y)\n    elif model == 'gp':\n        self.az_speed_pos_regresor = GaussianProcessRegressor(kernel=kernel, n_restarts_optimizer=10, random_state=42).fit(X, y)\n    self.score_az_speed_pos_regresor = self.az_speed_pos_regresor.score(X, y)\n    print(\"[DEBUG]: POSITIVE SPEEDS (LEFT), AZIMUTH, R^2 Score Linear Reg: \", self.score_az_speed_pos_regresor)\n\n    X = self.speed_time_azimuth_table[~is_positive_azimuth[:, 0], 0:2]\n    y = np.rad2deg(self.speed_time_azimuth_table[~is_positive_azimuth[:, 0], 2])\n    if model == 'linear':\n        self.az_speed_neg_regresor = LinearRegression().fit(X, y)\n    elif model == 'gp':\n        self.az_speed_neg_regresor = GaussianProcessRegressor(kernel=kernel, n_restarts_optimizer=10, random_state=42).fit(X, y)\n    self.score_az_speed_neg_regresor = self.az_speed_neg_regresor.score(X, y)\n    print(\"[DEBUG]: NEGATIVE SPEEDS (RIGHT), AZIMUTH, R^2 Score Linear Reg: \", self.score_az_speed_neg_regresor)\n\n    X = self.speed_time_elevation_table[~is_positive_elevation[:, 0], 0:2]\n    y = np.rad2deg(self.speed_time_elevation_table[~is_positive_elevation[:, 0], 2])\n    if model == 'linear':\n        self.el_speed_neg_regresor = LinearRegression().fit(X, y)\n    elif model == 'gp':\n        self.el_speed_neg_regresor = GaussianProcessRegressor(kernel=kernel, n_restarts_optimizer=10, random_state=42).fit(X, y).fit(X, y)\n    self.score_el_speed_neg_regresor = self.el_speed_neg_regresor.score(X, y)\n    print(\"[DEBUG]: NEGATIVE SPEEDS (DOWN), ELEVATION, R^2 Score Linear Reg: \", self.score_el_speed_neg_regresor)\n\n    X = self.speed_time_elevation_table[is_positive_elevation[:, 0], 0:2]\n    y = np.rad2deg(self.speed_time_elevation_table[is_positive_elevation[:, 0], 2])\n    if model == 'linear':\n        self.el_speed_pos_regresor = LinearRegression().fit(X, y)\n    elif model == 'gp':\n        self.el_speed_pos_regresor = GaussianProcessRegressor(kernel=kernel, n_restarts_optimizer=10, random_state=42).fit(X, y).fit(X, y)\n    self.score_el_speed_pos_regresor = self.el_speed_pos_regresor.score(X, y)\n    print(\"[DEBUG]: POSITIVE SPEEDS (UP), ELEVATION, R^2 Score Linear Reg: \", self.score_el_speed_neg_regresor)\n</code></pre>"},{"location":"GimbalGremsyH16/#a2gmeasurements.GimbalGremsyH16.gremsy_angle","title":"<code>gremsy_angle(a_i, a_ip, b_i)</code>","text":"<p>Computes the angle between the sides of the triangle given by a_i and  a_i+1. The opposite side to the angle computed is the one defined by b_i. </p> <p>A definition of this distances can be found in \"Manual A2GMeasurements\".</p> <p>NOTE FOR DEVELOPERS: the experiment described in * \"Manual A2GMeasurements\" was done before acquiring the external IMU. With the use of the external IMU a much easier measurement of the yaw and pitch can be done using (and extending) the <code>receive_imu_data</code> function of this class*.</p> <p>Parameters:</p> Name Type Description Default <code>a_i</code> <code>float</code> <p>defined in \"Manual A2GMeasurements\".</p> required <code>a_ip</code> <code>float</code> <p>defined in \"Manual A2GMeasurements\".</p> required <code>b_i</code> <code>float</code> <p>defined in \"Manual A2GMeasurements\".</p> required <p>Returns:</p> Name Type Description <code>Radians</code> <code>float</code> <p>mentioned angle in radians.</p> Source code in <code>a2gmeasurements.py</code> <pre><code>def gremsy_angle(self, a_i, a_ip, b_i):\n    \"\"\"\n    Computes the angle between the sides of the triangle given by a_i and  a_i+1. The opposite side to the angle computed is the one defined by b_i. \n\n    A definition of this distances can be found in \"Manual A2GMeasurements\".\n\n    NOTE FOR DEVELOPERS: *the experiment described in * \"Manual A2GMeasurements\" *was done before acquiring the external IMU. With the use of the external IMU a much easier measurement of the yaw and pitch can be done using (and extending) the ``receive_imu_data`` function of this class*.\n\n    Args:\n        a_i (float): defined in \"Manual A2GMeasurements\".\n        a_ip (float): defined in \"Manual A2GMeasurements\".\n        b_i (float): defined in \"Manual A2GMeasurements\".\n\n    Returns:\n        Radians (float): mentioned angle in radians.\n    \"\"\"\n\n    tmp = (a_i**2 + a_ip**2 - b_i**2)/(2*a_i*a_ip)\n    return np.arccos(tmp)\n</code></pre>"},{"location":"GimbalGremsyH16/#a2gmeasurements.GimbalGremsyH16.load_measured_data_august_2023","title":"<code>load_measured_data_august_2023()</code>","text":"<p>Loads a second set of measured data extracted from the experiment described on \"Manual A2GMeasurements\".</p> <p>This table contains as columns the speed [-100, 100], time [s], and the angle (azimuth, elevation) computed from the 3 distances (a_{i}, a_{i+1}, b_{i}) described in \"Manual A2GMeasurements\".</p> <p>NOTE FOR DEVELOPERS: the experiment described in \"Manual A2GMeasurements\" was done before acquiring the external IMU. With the use of the external IMU a much easier measurement of the yaw and pitch can be done using (and extending) the <code>receive_imu_data</code> function of this class.</p> Source code in <code>a2gmeasurements.py</code> <pre><code>def load_measured_data_august_2023(self):\n    \"\"\"\n    Loads a second set of measured data extracted from the experiment described on \"Manual A2GMeasurements\".\n\n    This table contains as columns the speed [-100, 100], time [s], and the angle (azimuth, elevation) computed from the 3 distances (a_{i}, a_{i+1}, b_{i}) described in \"Manual A2GMeasurements\".\n\n    NOTE FOR DEVELOPERS: *the experiment described in* \"Manual A2GMeasurements\" *was done before acquiring the external IMU. With the use of the external IMU a much easier measurement of the yaw and pitch can be done using (and extending) the ``receive_imu_data`` function of this class*.\n    \"\"\"        \n    speed_time_azimuth_table = [[15, 6, self.gremsy_angle(1.903, 1.949, 0.87)], \n                    [15, 7, self.gremsy_angle(1.955, 1.926, 1)],\n                    [15, 8, self.gremsy_angle(2.071, 1.897, 1.19)],\n                    [15, 9, self.gremsy_angle(2.023, 1.949, 1.315)],\n                    [16, 5, self.gremsy_angle(1.879, 2.078, 0.875)],\n                    [16, 6, self.gremsy_angle(1.883, 2.069, 1.025)],\n                    [16, 7, self.gremsy_angle(1.897, 2.219, 1.26)],\n                    [14, 7, self.gremsy_angle(1.886, 1.994, 0.86)],\n                    [14, 8, self.gremsy_angle(1.881, 2.069, 1)],\n                    [14, 9, self.gremsy_angle(1.888, 2.086, 1.134)],\n                    [-14, 4, self.gremsy_angle(1.922, 2.047, 1.255)],\n                    [-14, 5, self.gremsy_angle(1.961, 2.117, 1.59)],\n                    [-14, 6, self.gremsy_angle(2.106, 2.089, 1.93)],\n                    [-13, 4, self.gremsy_angle(2.034, 1.909, 1.165)],\n                    [-13, 5, self.gremsy_angle(2.025, 1.985, 1.44)],\n                    [-13, 6, self.gremsy_angle(2.183, 1.98, 1.79)],\n                    [-15, 4, self.gremsy_angle(2.38, 1.574, 1.666)],\n                    [-15, 5, self.gremsy_angle(2.183, 1.538, 1.836)],\n                    [-15, 6, self.gremsy_angle(2.183, 1.546, 2.111)],\n                    [-16, 4, self.gremsy_angle(2.183, 1.558, 1.648)],\n                    [-16, 5, self.gremsy_angle(2.183, 1.537, 1.934)],\n                    [-16, 6, self.gremsy_angle(2.183, 1.562, 2.215)],\n                    [-17, 4, self.gremsy_angle(2.183, 1.55, 1.71)],\n                    [-17, 5, self.gremsy_angle(2.183, 1.54, 2.103)],\n                    [-17, 6, self.gremsy_angle(2.183, 1.586, 2.327)],\n                    [-18, 4, self.gremsy_angle(2.183, 1.541, 1.799)],\n                    [-18, 5, self.gremsy_angle(2.183, 1.623, 2.109)],\n                    [-18, 6, self.gremsy_angle(2.183, 1.623, 2.463)],\n                    [-19, 4, self.gremsy_angle(2.183, 1.537, 1.885)],\n                    [-19, 5, self.gremsy_angle(2.183, 1.563, 2.215)],\n                    [-19, 6, self.gremsy_angle(2.183, 1.663, 2.582)],\n                    [-20, 4, self.gremsy_angle(2.183, 1.537, 1.952)],\n                    [-20, 5, self.gremsy_angle(2.183, 1.585, 2.321)],\n                    [-20, 6, self.gremsy_angle(2.183, 1.718, 2.72)]]\n    self.speed_time_azimuth_table = np.array(speed_time_azimuth_table)\n\n    speed_time_elevation_table = [[10, 3, self.gremsy_angle(1.526, 1.529, 0.07)],\n                                    [10, 4, self.gremsy_angle(1.526, 1.531, 0.096)],\n                                    [10, 5, self.gremsy_angle(1.526, 1.532, 0.11)],\n                                    [10, 6, self.gremsy_angle(1.526, 1.533, 0.122)],\n                                    [10, 7, self.gremsy_angle(1.526, 1.537, 0.16)],\n                                    [10, 8, self.gremsy_angle(1.526, 1.540, 0.183)],\n                                    [11, 3, self.gremsy_angle(1.526, 1.543, 0.124)],\n                                    [11, 4, self.gremsy_angle(1.526, 1.548, 0.163)],\n                                    [11, 5, self.gremsy_angle(1.526, 1.542, 0.199)],\n                                    [11, 6, self.gremsy_angle(1.526, 1.554, 0.239)],\n                                    [11, 7, self.gremsy_angle(1.526, 1.548, 0.279)],\n                                    [12, 3, self.gremsy_angle(1.526, 1.538, 0.168)],\n                                    [12, 4, self.gremsy_angle(1.526, 1.545, 0.227)],\n                                    [12, 5, self.gremsy_angle(1.526, 1.555, 0.283)],\n                                    [12, 6, self.gremsy_angle(1.526, 1.568, 0.343)],\n                                    [12, 7, self.gremsy_angle(1.526, 1.580, 0.4)],\n                                    [13, 3, self.gremsy_angle(1.526, 1.548, 0.244)],\n                                    [13, 4, self.gremsy_angle(1.526, 1.56, 0.311)],\n                                    [13, 5, self.gremsy_angle(1.526, 1.578, 0.395)],\n                                    [13, 6, self.gremsy_angle(1.526, 1.598, 0.448)],\n                                    [13, 7, self.gremsy_angle(1.526, 1.656, 0.64)],\n                                    [14, 2, self.gremsy_angle(1.526, 1.542, 0.184)],\n                                    [14, 3, self.gremsy_angle(1.526, 1.558, 0.286)],\n                                    [14, 4, self.gremsy_angle(1.526, 1.578, 0.378)],\n                                    [14, 5, self.gremsy_angle(1.526, 1.603, 0.474)],\n                                    [14, 6, self.gremsy_angle(1.526, 1.635, 0.574)],\n                                    [15, 1, self.gremsy_angle(1.526, 1.531, 0.11)],\n                                    [15, 2, self.gremsy_angle(1.526, 1.542, 0.209)],\n                                    [15, 3, self.gremsy_angle(1.526, 1.565, 0.334)],\n                                    [15, 4, self.gremsy_angle(1.526, 1.594, 0.448)],\n                                    [15, 5, self.gremsy_angle(1.526, 1.63, 0.567)],\n                                    [16, 1, self.gremsy_angle(1.526, 1.533, 0.125)],\n                                    [16, 2, self.gremsy_angle(1.526, 1.549, 0.253)],\n                                    [16, 3, self.gremsy_angle(1.526, 1.575, 0.378)],\n                                    [16, 4, self.gremsy_angle(1.526, 1.614, 0.519)],\n                                    [16, 5, self.gremsy_angle(1.526, 1.666, 0.665)],\n                                    [17, 1, self.gremsy_angle(1.526, 1.535, 0.147)],\n                                    [17, 2, self.gremsy_angle(1.526, 1.557, 0.291)],\n                                    [17, 3, self.gremsy_angle(1.526, 1.59, 0.435)],\n                                    [17, 4, self.gremsy_angle(1.526, 1.642, 0.6)],\n                                    [17, 5, self.gremsy_angle(1.526, 1.708, 0.766)],\n                                    [18, 1, self.gremsy_angle(1.526, 1.537, 0.164)],\n                                    [18, 2, self.gremsy_angle(1.526, 1.563, 0.328)],\n                                    [18, 3, self.gremsy_angle(1.526, 1.608, 0.502)],\n                                    [18, 4, self.gremsy_angle(1.526, 1.676, 0.693)],\n                                    [18, 5, self.gremsy_angle(1.526, 1.761, 0.884)],\n                                    [19, 0.5, self.gremsy_angle(1.526, 1.529, 0.088)],\n                                    [19, 1, self.gremsy_angle(1.526, 1.538, 0.176)],\n                                    [19, 2, self.gremsy_angle(1.526, 1.571, 0.363)],\n                                    [19, 3, self.gremsy_angle(1.526, 1.626, 0.558)],\n                                    [19, 4, self.gremsy_angle(1.526, 1.707, 0.766)],\n                                    [20, 0.5, self.gremsy_angle(1.526, 1.53, 0.1)],\n                                    [20, 1, self.gremsy_angle(1.526, 1.541, 0.2)],\n                                    [20, 2, self.gremsy_angle(1.526, 1.579, 0.395)],\n                                    [20, 3, self.gremsy_angle(1.526, 1.648, 0.616)],\n                                    [20, 4, self.gremsy_angle(1.526, 1.742, 0.845)],\n                                    [-5, 3, self.gremsy_angle(1.769, 1.652, 0.268)],\n                                    [-5, 6, self.gremsy_angle(1.769, 1.58, 0.5)],\n                                    [-5, 7, self.gremsy_angle(1.769, 1.562, 0.575)],\n                                    [-5, 8, self.gremsy_angle(1.769, 1.548, 0.648)],\n                                    [-5, 10, self.gremsy_angle(1.769, 1.534, 0.758)],\n                                    [-6, 3, self.gremsy_angle(1.769, 1.632, 0.324)],\n                                    [-6, 6, self.gremsy_angle(1.769, 1.556, 0.608)],\n                                    [-6, 8, self.gremsy_angle(1.769, 1.531, 0.785)],\n                                    [-6, 10, self.gremsy_angle(1.769, 1.527, 0.958)],\n                                    [-7, 3, self.gremsy_angle(1.769, 1.713, 0.385)],\n                                    [-7, 6, self.gremsy_angle(1.769, 1.534, 0.717)],\n                                    [-7, 8, self.gremsy_angle(1.769, 1.526, 0.925)],\n                                    [-7, 10, self.gremsy_angle(1.769, 1.541, 1.135)],\n                                    [-8, 3, self.gremsy_angle(1.769, 1.599, 0.433)],\n                                    [-8, 6, self.gremsy_angle(1.769, 1.53, 0.983)],\n                                    [-8, 8, self.gremsy_angle(1.769, 1.533, 1.058)],\n                                    [-8, 10, self.gremsy_angle(1.769, 1.574, 1.309)],\n                                    [-9, 3, self.gremsy_angle(1.769, 1.581, 0.496)],\n                                    [-9, 6, self.gremsy_angle(1.769, 1.527, 0.934)],\n                                    [-9, 8, self.gremsy_angle(1.769, 1.554, 1.214)],\n                                    [-9, 9, self.gremsy_angle(1.769, 1.588, 1.364)],\n                                    [-10, 2, self.gremsy_angle(1.769, 1.612, 0.387)],\n                                    [-10, 5, self.gremsy_angle(1.769, 1.527, 0.883)],\n                                    [-10, 7, self.gremsy_angle(1.769, 1.551, 1.197)],\n                                    [-10, 8, self.gremsy_angle(1.769, 1.588, 1.364)],\n                                    [-11, 2, self.gremsy_angle(1.769, 1.601, 0.42)],\n                                    [-11, 5, self.gremsy_angle(1.769, 1.527, 0.96)],\n                                    [-11, 6, self.gremsy_angle(1.769, 1.541, 1.136)],\n                                    [-11, 7, self.gremsy_angle(1.769, 1.577, 1.322)],\n                                    [-12, 2, self.gremsy_angle(1.769, 1.588, 0.467)],\n                                    [-12, 5, self.gremsy_angle(1.769, 1.532, 1.048)],\n                                    [-12, 6, self.gremsy_angle(1.769, 1.559, 1.247)],\n                                    [-12, 7, self.gremsy_angle(1.769, 1.611, 1.446)],\n                                    [-13, 2, self.gremsy_angle(1.769, 1.579, 0.502)],\n                                    [-13, 5, self.gremsy_angle(1.769, 1.542, 1.144)],\n                                    [-13, 6, self.gremsy_angle(1.769, 1.588, 1.363)],\n                                    [-13, 7, self.gremsy_angle(1.769, 1.672, 1.611)],\n                                    [-14, 2, self.gremsy_angle(1.769, 1.572, 0.534)],\n                                    [-14, 5, self.gremsy_angle(1.769, 1.558, 1.231)],\n                                    [-14, 6, self.gremsy_angle(1.769, 1.624, 1.483)],\n                                    [-14, 7, self.gremsy_angle(1.769, 1.672, 1.752)],\n                                    [-15, 2, self.gremsy_angle(1.769, 1.565, 0.559)],\n                                    [-15, 4, self.gremsy_angle(1.769, 1.534, 1.069)],\n                                    [-15, 5, self.gremsy_angle(1.769, 1.58, 1.328)],\n                                    [-15, 6, self.gremsy_angle(1.769, 1.666, 1.6)],\n                                    [-16, 2, self.gremsy_angle(1.769, 1.558, 0.601)],\n                                    [-16, 4, self.gremsy_angle(1.769, 1.541, 1.136)],\n                                    [-16, 5, self.gremsy_angle(1.769, 1.604, 1.42)],\n                                    [-16, 6, self.gremsy_angle(1.769, 1.722, 1.73)],\n                                    [-17, 2, self.gremsy_angle(1.769, 1.55, 0.641)],\n                                    [-17, 4, self.gremsy_angle(1.769, 1.554, 1.212)],\n                                    [-17, 5, self.gremsy_angle(1.769, 1.634, 1.512)],\n                                    [-17, 6, self.gremsy_angle(1.769, 1.74, 1.771)],\n                                    [-18, 1, self.gremsy_angle(1.769, 1.623, 0.355)],\n                                    [-18, 3, self.gremsy_angle(1.769, 1.528, 0.98)],\n                                    [-18, 4, self.gremsy_angle(1.769, 1.568, 1.284)],\n                                    [-18, 5, self.gremsy_angle(1.769, 1.677, 1.625)],\n                                    [-19, 1, self.gremsy_angle(1.769, 1.615, 0.38)],\n                                    [-19, 3, self.gremsy_angle(1.769, 1.531, 1.031)],\n                                    [-19, 4, self.gremsy_angle(1.769, 1.591, 1.374)],\n                                    [-19, 5, self.gremsy_angle(1.769, 1.726, 1.774)],\n                                    [-20, 1, self.gremsy_angle(1.769, 1.609, 0.401)],\n                                    [-20, 3, self.gremsy_angle(1.769, 1.536, 1.086)],\n                                    [-20, 4, self.gremsy_angle(1.769, 1.613, 1.451)],\n                                    [-20, 5, self.gremsy_angle(1.769, 1.737, 1.764)]]\n    self.speed_time_elevation_table = np.array(speed_time_elevation_table)\n</code></pre>"},{"location":"GimbalGremsyH16/#a2gmeasurements.GimbalGremsyH16.load_measured_data_july_2023","title":"<code>load_measured_data_july_2023()</code>","text":"<p>Loads a set of measured data extracted from the experiment described on \"Manual A2GMeasurements\". </p> <p>This table contains as columns the speed [-100, 100], time [s], and the azimuth angle computed from the 3 distances (a_{i}, a_{i+1}, b_{i}) described in \"Manual A2GMeasurements\".</p> <p>NOTE FOR DEVELOPERS: the experiment described in \"Manual A2GMeasurements\" was done before acquiring the external IMU. With the use of the external IMU a much easier measurement of the yaw and pitch can be done using (and extending) the <code>receive_imu_data</code> function of this class.</p> Source code in <code>a2gmeasurements.py</code> <pre><code>def load_measured_data_july_2023(self):\n    \"\"\"\n    Loads a set of measured data extracted from the experiment described on \"Manual A2GMeasurements\". \n\n    This table contains as columns the speed [-100, 100], time [s], and the azimuth angle computed from the 3 distances (a_{i}, a_{i+1}, b_{i}) described in \"Manual A2GMeasurements\".\n\n    NOTE FOR DEVELOPERS: *the experiment described in* \"Manual A2GMeasurements\" *was done before acquiring the external IMU. With the use of the external IMU a much easier measurement of the yaw and pitch can be done using (and extending) the ``receive_imu_data`` function of this class*.\n    \"\"\"        \n    speed_time_azimuth_table = [[15, 6, self.gremsy_angle(1.903, 1.949, 0.87)], \n                    [15, 7, self.gremsy_angle(1.955, 1.926, 1)],\n                    [15, 8, self.gremsy_angle(2.071, 1.897, 1.19)],\n                    [15, 9, self.gremsy_angle(2.023, 1.949, 1.315)],\n                    [16, 5, self.gremsy_angle(1.879, 2.078, 0.875)],\n                    [16, 6, self.gremsy_angle(1.883, 2.069, 1.025)],\n                    [16, 7, self.gremsy_angle(1.897, 2.219, 1.26)],\n                    [14, 7, self.gremsy_angle(1.886, 1.994, 0.86)],\n                    [14, 8, self.gremsy_angle(1.881, 2.069, 1)],\n                    [14, 9, self.gremsy_angle(1.888, 2.086, 1.134)],\n                    [-14, 4, self.gremsy_angle(1.922, 2.047, 1.255)],\n                    [-14, 5, self.gremsy_angle(1.961, 2.117, 1.59)],\n                    [-14, 6, self.gremsy_angle(2.106, 2.089, 1.93)],\n                    [-13, 4, self.gremsy_angle(2.034, 1.909, 1.165)],\n                    [-13, 5, self.gremsy_angle(2.025, 1.985, 1.44)],\n                    [-13, 6, self.gremsy_angle(2.183, 1.98, 1.79)]]\n    self.speed_time_azimuth_table = np.array(speed_time_azimuth_table)\n\n    speed_time_elevation_table = [[-5, 1, self.gremsy_angle(1.884, 1.882, 0.1)],\n                                        [-5, 2, self.gremsy_angle(1.881, 1.889, 0.175)],\n                                        [-5, 3, self.gremsy_angle(1.89, 1.934, 0.272)],\n                                        [-5, 4, self.gremsy_angle(1.889, 1.891, 0.345)]]\n    self.speed_time_elevation_table = np.array(speed_time_elevation_table)        \n</code></pre>"},{"location":"GimbalGremsyH16/#a2gmeasurements.GimbalGremsyH16.load_measured_drifts","title":"<code>load_measured_drifts()</code>","text":"<p>Loads measured drift angles from the experiment described on \"Manual A2GMeasurements\".</p> Source code in <code>a2gmeasurements.py</code> <pre><code>def load_measured_drifts(self):\n    \"\"\"\n    Loads measured drift angles from the experiment described on \"Manual A2GMeasurements\".        \n    \"\"\" \n    drift_with_low_speed_counter = [[137, self.gremsy_angle(2, 1.97, 0.10)],\n                                    [144, self.gremsy_angle(1.97, 1.94, 0.10)],\n                                    [145, self.gremsy_angle(1.94, 1.927, 0.10)],\n                                    [156, self.gremsy_angle(1.927, 1.911, 0.10)],\n                                    [164, self.gremsy_angle(1.911, 1.898, 0.10)],\n                                    [148, self.gremsy_angle(1.898, 1.892, 0.10)],\n                                    [164, self.gremsy_angle(1.892, 1.89, 0.10)],\n                                    [176, self.gremsy_angle(1.89, 1.894, 0.10)],\n                                    [185, self.gremsy_angle(1.894, 1.9, 0.10)],\n                                    [159, self.gremsy_angle(1.9, 1.914, 0.10)],\n                                    [159, self.gremsy_angle(1.914, 1.932, 0.10)],\n                                    [146, self.gremsy_angle(1.932, 1.954, 0.10)]]\n\n    drift_without_low_speed_counter = [[28.91, self.gremsy_angle(2, 1.971, 0.10)],\n                                       [28.43, self.gremsy_angle(1.971, 1.95, 0.10)],\n                                       [28.46, self.gremsy_angle(1.95, 1.923, 0.10)],\n                                       [30.14, self.gremsy_angle(1.923, 1.9, 0.10)],\n                                       [29.76, self.gremsy_angle(1.9, 1.888, 0.10)],\n                                       [29.36, self.gremsy_angle(1.888, 1.884, 0.10)],\n                                       [31.41, self.gremsy_angle(1.884, 1.872, 0.10)],\n                                       [31.3, self.gremsy_angle(1.872, 1.881, 0.10)],\n                                       [28.77, self.gremsy_angle(1.881, 1.89, 0.10)],\n                                       [31.56, self.gremsy_angle(1.89, 1.912, 0.10)],\n                                       [29.15, self.gremsy_angle(1.912, 1.935, 0.10)]]\n\n    self.drift_with_low_speed_counter = drift_with_low_speed_counter\n    self.drift_without_low_speed_counter = drift_without_low_speed_counter\n    self.avg_drift_with_low_speed_counter = np.array(drift_with_low_speed_counter).mean(axis=0) # 2D array \n    self.avg_drift_without_low_speed_counter = np.array(drift_without_low_speed_counter).mean(axis=0) # 2D array\n</code></pre>"},{"location":"GimbalGremsyH16/#a2gmeasurements.GimbalGremsyH16.plot_linear_reg_on_near_domain","title":"<code>plot_linear_reg_on_near_domain(loaded='august')</code>","text":"<p>Generates a figure with 3 subplots with measured values (default measured values or new values measured for more (speed, time) tuples given as a parameter to the class) and with linear regression model applied to the measured values.</p> <ol> <li>3D Scatter Plot of (speed, time, angle) for speed &gt; 0 and angle -&gt; azimuth </li> <li>3D Scatter Plot of (speed, time, angle) for speed &lt; 0 and angle -&gt; azimuth </li> <li>3D Scatter Plot of (speed, time, angle) for speed &lt; 0 and angle -&gt; elevation</li> </ol> <p>If <code>loaded</code> is august then the figure has 4 subplots, with the 4th being 4. 3D Scatter Plot of (speed, time, angle) for speed &gt; 0 and angle -&gt; elevation</p> <p>Parameters:</p> Name Type Description Default <code>loaded</code> <code>str</code> <p>which table loaded: the one from <code>load_measured_data_july_2023</code> or the one from <code>load_measured_data_august_2023</code>. Defaults to <code>august</code>.</p> <code>'august'</code> Source code in <code>a2gmeasurements.py</code> <pre><code>def plot_linear_reg_on_near_domain(self, loaded='august'):\n    \"\"\"\n    Generates a figure with 3 subplots with measured values (default measured values or new values measured for more (speed, time) tuples given as a parameter to the class) and with linear regression model applied to the measured values.\n\n    1. 3D Scatter Plot of (speed, time, angle) for speed &gt; 0 and angle -&gt; azimuth \n    2. 3D Scatter Plot of (speed, time, angle) for speed &lt; 0 and angle -&gt; azimuth \n    3. 3D Scatter Plot of (speed, time, angle) for speed &lt; 0 and angle -&gt; elevation\n\n    If ``loaded`` is august then the figure has 4 subplots, with the 4th being\n    4. 3D Scatter Plot of (speed, time, angle) for speed &gt; 0 and angle -&gt; elevation\n\n    Args:\n        loaded (str, optional): which table loaded: the one from ``load_measured_data_july_2023`` or the one from ``load_measured_data_august_2023``. Defaults to ``august``.\n    \"\"\"\n\n    is_positive_azimuth = self.speed_time_azimuth_table &gt; 0\n    is_positive_elevation = self.speed_time_elevation_table &gt; 0       \n\n    # We are going to use multiple if - else statements of the same kind just to maintain some readibility of the code\n    if loaded == 'august':\n        fig = make_subplots(rows=2, cols=2, specs=[[{\"type\": \"scene\"}, {\"type\": \"scene\"}], [{\"type\": \"scene\"}, {\"type\": \"scene\"}]],\n                            subplot_titles=(\"Pos. Speed - Azimuth\", \"Neg. Speed - Azimuth\", \"Neg. Speed - Elevation\", \"Pos. Speed - Elevation\"))\n    else:\n        fig = make_subplots(rows=1, cols=3, specs=[[{\"type\": \"scene\"}, {\"type\": \"scene\"}, {\"type\": \"scene\"}]],\n                            subplot_titles=(\"Pos. Speed - Azimuth\", \"Neg. Speed - Azimuth\", \"Neg. Speed - Elevation\"))\n\n    X, Y = np.meshgrid(np.linspace(10, 20, num=11), np.linspace(5, 9, num=5))\n    XY = np.c_[X.flatten(), Y.flatten()]\n    Z = self.az_speed_pos_regresor.predict(XY)        \n\n    fig.add_trace(go.Scatter3d(mode='markers', x=XY[:, 0], y=XY[:, 1], z=Z, marker=dict(color='blue', size=5,), name='Extrapolated', showlegend=True), row=1, col=1)\n    fig.add_trace(go.Scatter3d(mode='markers', x=self.speed_time_azimuth_table[is_positive_azimuth[:, 0], 0], y=self.speed_time_azimuth_table[is_positive_azimuth[:, 0], 1],\n            z=np.rad2deg(self.speed_time_azimuth_table[is_positive_azimuth[:, 0], 2]), marker=dict(color='red', size=3,), name='Measured', showlegend=True), row=1, col=1)\n\n    X, Y = np.meshgrid(np.linspace(-20, -10, num=11), np.linspace(4, 6, num=3))    \n    XY = np.c_[X.flatten(), Y.flatten()]\n    Z = self.az_speed_neg_regresor.predict(XY)\n\n    fig.add_trace(go.Scatter3d(mode='markers', x=XY[:, 0], y=XY[:, 1], z=Z, marker=dict(color='blue', size=5,), name='Extrapolated', showlegend=True), row=1, col=2)\n    fig.add_trace(go.Scatter3d(mode='markers', x=self.speed_time_azimuth_table[~is_positive_azimuth[:, 0], 0], y=self.speed_time_azimuth_table[~is_positive_azimuth[:, 0], 1],\n            z=np.rad2deg(self.speed_time_azimuth_table[~is_positive_azimuth[:, 0], 2]), marker=dict(color='red', size=3,), name='Measured', showlegend=True), row=1, col=2)\n\n    if loaded == 'august':\n        X, Y = np.meshgrid(np.linspace(-20, -5, num=16), np.linspace(1, 10, num=10))\n        nrow = 2\n        ncol = 1\n    else:\n        X, Y = np.meshgrid(np.linspace(-10, -5, num=6), np.linspace(1, 4, num=4))\n        nrow = 1\n        ncol = 3\n    XY = np.c_[X.flatten(), Y.flatten()]\n    Z = self.el_speed_neg_regresor.predict(XY)\n\n    fig.add_trace(go.Scatter3d(mode='markers', x=XY[:, 0], y=XY[:, 1], z=Z, marker=dict(color='blue', size=5,), name='Extrapolated', showlegend=True), row=nrow, col=ncol)\n    fig.add_trace(go.Scatter3d(mode='markers', x=self.speed_time_elevation_table[~is_positive_elevation[:, 0], 0], y=self.speed_time_elevation_table[~is_positive_elevation[:, 0], 1],\n            z=np.rad2deg(self.speed_time_elevation_table[~is_positive_elevation[:, 0], 2]), marker=dict(color='red', size=3,), name='Measured', showlegend=True), row=nrow, col=ncol)\n\n    if loaded == 'august':\n        X, Y = np.meshgrid(np.linspace(10, 20, num=11), np.linspace(0, 9, num=10))\n        XY = np.c_[X.flatten(), Y.flatten()]\n        Z = self.el_speed_pos_regresor.predict(XY)\n\n        fig.add_trace(go.Scatter3d(mode='markers', x=XY[:, 0], y=XY[:, 1], z=Z, marker=dict(color='blue', size=5,), name='Extrapolated', showlegend=True), row=2, col=2)\n        fig.add_trace(go.Scatter3d(mode='markers', x=self.speed_time_elevation_table[is_positive_elevation[:, 0], 0], y=self.speed_time_elevation_table[is_positive_elevation[:, 0], 1],\n                z=np.rad2deg(self.speed_time_elevation_table[is_positive_elevation[:, 0], 2]), marker=dict(color='red', size=3,), name='Measured', showlegend=True), row=2, col=2)\n\n    fig.update_scenes(xaxis=dict(backgroundcolor=\"rgba(0, 0, 0,0)\", gridcolor=\"rgba(1, 1, 1, 0.1)\", showbackground=True, zerolinecolor=\"black\",title='Speed',),\n                    yaxis=dict(backgroundcolor=\"rgba(0, 0, 0,0)\", gridcolor=\"rgba(1, 1, 1, 0.1)\", showbackground=True, zerolinecolor=\"black\", title='Time [s]', ),\n                    zaxis=dict(backgroundcolor=\"rgba(0, 0, 0,0)\", gridcolor=\"rgba(1, 1, 1, 0.1)\", showbackground=True, zerolinecolor=\"black\", title='Angle [s]'),\n                    row=1, col=1,)\n    fig.update_scenes(xaxis=dict(backgroundcolor=\"rgba(0, 0, 0,0)\", gridcolor=\"rgba(1, 1, 1, 0.1)\", showbackground=True, zerolinecolor=\"black\",title='Speed',),\n                    yaxis=dict(backgroundcolor=\"rgba(0, 0, 0,0)\", gridcolor=\"rgba(1, 1, 1, 0.1)\", showbackground=True, zerolinecolor=\"black\", title='Time [s]', ),\n                    zaxis=dict(backgroundcolor=\"rgba(0, 0, 0,0)\", gridcolor=\"rgba(1, 1, 1, 0.1)\", showbackground=True, zerolinecolor=\"black\", title='Angle [s]'),\n                    row=1, col=2,)\n    fig.update_scenes(xaxis=dict(backgroundcolor=\"rgba(0, 0, 0,0)\", gridcolor=\"rgba(1, 1, 1, 0.1)\", showbackground=True, zerolinecolor=\"black\",title='Speed',),\n                    yaxis=dict(backgroundcolor=\"rgba(0, 0, 0,0)\", gridcolor=\"rgba(1, 1, 1, 0.1)\", showbackground=True, zerolinecolor=\"black\", title='Time [s]', ),\n                    zaxis=dict(backgroundcolor=\"rgba(0, 0, 0,0)\", gridcolor=\"rgba(1, 1, 1, 0.1)\", showbackground=True, zerolinecolor=\"black\", title='Angle [s]'),\n                    row=1, col=3,)\n\n    fig.update_layout(autosize=False, width=1400, height=800, margin=dict(l=50, r=50, t=50, b=50),)\n    fig.show()\n</code></pre>"},{"location":"GimbalGremsyH16/#a2gmeasurements.GimbalGremsyH16.receive_imu_data","title":"<code>receive_imu_data(stop_event)</code>","text":"<p>Callback function for the imu thread. Read the yaw, pitch, roll angles and stores them in the attribute <code>last_imu_reading</code> of this class.</p> <p>Parameters:</p> Name Type Description Default <code>stop_event</code> <code>Event</code> <p>when this is set, this function won't do anything.</p> required Source code in <code>a2gmeasurements.py</code> <pre><code>def receive_imu_data(self, stop_event):\n    \"\"\"\n    Callback function for the imu thread. Read the yaw, pitch, roll angles and stores them in the attribute ``last_imu_reading`` of this class.\n\n    Args:\n        stop_event (threading.Event): when this is set, this function won't do anything.\n    \"\"\"\n\n    while not stop_event.is_set():\n        data = self.imu_serial.readline().decode('utf-8').strip()\n        data = data.split(',')\n\n        self.last_imu_reading = {'YAW': float(data[0]), 'PITCH': float(data[1]), 'ROLL': float(data[2])}\n        self.cnt_imu_readings = self.cnt_imu_readings + 1\n\n        if self.cnt_imu_readings &gt; 1e12:\n            self.cnt_imu_readings = 0\n</code></pre>"},{"location":"GimbalGremsyH16/#a2gmeasurements.GimbalGremsyH16.setPosControl","title":"<code>setPosControl(yaw, pitch, roll=0, mode=0, model='linear')</code>","text":"<p>Moves Gremsy H16 gimbal by the input angle. This function works as the equivalent to the <code>setPosControl</code> function of the class <code>GimbalRS2</code>. If movement is desired in both yaw and pitch, the gimbal will move first in either axis (i.e. yaw) and after finishing the that movement, it will move in the other axis (i.e. pitch).</p> <p>If the linear model is used: this function sets an RC control value (\"speed\") and finds the corresponding time, given the angle desired to be set.</p> <p>If the gp model is used: this function calls <code>setPosControlGPModel</code> to get the RC control value and time, corresponding to the input angle.</p> <p>For a more accurate gimbal angle movement: </p> <ol> <li>Provide a finer and equally sampled grid of RC control value, time with its corresponding measured angle.</li> <li>Modify <code>fit_model_to_gimbal_angular_data</code> to tune parameters of the gp model (if gp model is chosen).</li> <li>Modify  <code>setPosControlGPModel</code> (if gp model is chosen) if a better logic for getting RC control values and times from a given angle is available.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>yaw</code> <code>float</code> <p>yaw angle (in degrees) to be set. Valid range between [-180, 180].</p> required <code>pitch</code> <code>float</code> <p>pitch angle (in degrees) to be set. Valid range between [-90, 90].</p> required <code>roll</code> <code>int</code> <p>roll angle (in degrees) to be set. Roll angle is not used because desired movement of the gimbal only requires yaw and pitch angles. Defaults to 0.</p> <code>0</code> <code>mode</code> <code>hexadecimal</code> <p>to be implemented. The idea is to have two modes as in the GimbalRS2 class: <code>relative</code> and <code>absolute</code>. Defaults to 0x00.</p> <code>0</code> <code>model</code> <code>str</code> <p><code>linear</code> or <code>gp</code> model for the angle dependence on the RC control value and the time to hold it. For the <code>gp</code> model, the functionality must be implemented. Defaults to 'linear'.</p> <code>'linear'</code> Source code in <code>a2gmeasurements.py</code> <pre><code>def setPosControl(self, yaw, pitch, roll=0, mode=0x00, model='linear'):\n    \"\"\"\n    Moves Gremsy H16 gimbal by the input angle. This function works as the equivalent to the ``setPosControl`` function of the class ``GimbalRS2``. If movement is desired in both yaw and pitch, the gimbal will move first in either axis (i.e. yaw) and after finishing the that movement, it will move in the other axis (i.e. pitch).\n\n    If the linear model is used: this function sets an RC control value (\"speed\") and finds the corresponding time, given the angle desired to be set.\n\n    If the gp model is used: this function calls ``setPosControlGPModel`` to get the RC control value and time, corresponding to the input angle.\n\n    For a more accurate gimbal angle movement: \n\n    1. Provide a finer and equally sampled grid of RC control value, time with its corresponding measured angle.\n    2. Modify ``fit_model_to_gimbal_angular_data`` to tune parameters of the gp model (if gp model is chosen).\n    3. Modify  ``setPosControlGPModel`` (if gp model is chosen) if a better logic for getting RC control values and times from a given angle is available.\n\n    Args:\n        yaw (float): yaw angle (in degrees) to be set. Valid range between [-180, 180].\n        pitch (float): pitch angle (in degrees) to be set. Valid range between [-90, 90].\n        roll (int, optional): roll angle (in degrees) to be set. Roll angle is not used because desired movement of the gimbal only requires yaw and pitch angles. Defaults to 0.\n        mode (hexadecimal, optional): to be implemented. The idea is to have two modes as in the GimbalRS2 class: ``relative`` and ``absolute``. Defaults to 0x00.\n        model (str, optional): ``linear`` or ``gp`` model for the angle dependence on the RC control value and the time to hold it. For the ``gp`` model, the functionality must be implemented. Defaults to 'linear'.\n    \"\"\"\n\n    if model == 'linear':\n        # Choose speed for yaw movement\n        if yaw &gt; 0:\n            speed_yaw = -11\n\n            # Linear regresion model for angle dependence. If different, change this line\n            time_yaw_2_move = (yaw - self.az_speed_neg_regresor.coef_[0]*speed_yaw - self.az_speed_neg_regresor.intercept_)/self.az_speed_neg_regresor.coef_[1]\n        elif yaw &lt; 0:\n            speed_yaw = 15\n\n            # Linear regresion model for angle dependence. If different, change this line\n            time_yaw_2_move = (np.abs(yaw) - self.az_speed_pos_regresor.coef_[0]*speed_yaw - self.az_speed_pos_regresor.intercept_)/self.az_speed_pos_regresor.coef_[1]\n        elif yaw == 0:\n            time_yaw_2_move = 0\n\n        # Choose speed for pitch movement\n        if pitch &gt; 0:\n            #print(\"[DEBUG]: Only negative pitch values are allowed\")\n            speed_pitch = 10\n            time_pitch_2_move = (pitch - self.el_speed_pos_regresor.coef_[0]*speed_pitch - self.el_speed_pos_regresor.intercept_)/self.el_speed_pos_regresor.coef_[1]\n            #return\n        elif pitch &lt; 0:\n            speed_pitch = -5\n            time_pitch_2_move = (np.abs(pitch) - self.el_speed_neg_regresor.coef_[0]*speed_pitch - self.el_speed_neg_regresor.intercept_)/self.el_speed_neg_regresor.coef_[1]\n        elif pitch == 0:\n            time_pitch_2_move = 0\n\n    elif model == 'gp':\n        if yaw == 0:\n            yaw = None\n        else:\n            yaw = float(yaw)\n        if pitch == 0:\n            pitch = None\n        else:\n            pitch = float(pitch)\n\n        speed_yaw, time_yaw_2_move, speed_pitch, time_pitch_2_move = self.setPosControlGPModel(yaw=yaw, pitch=yaw)\n\n    if (time_yaw_2_move &gt; 0) and (time_pitch_2_move &gt; 0):\n        print(\"[DEBUG]: Gremsy H16 moves in yaw first: TIME to complete movement: \", time_yaw_2_move)\n        self.sbus.move_gimbal(0, speed_yaw, time_yaw_2_move)\n        print(\"[DEBUG]: Gremsy H16 moves in elevation second: TIME to complete movement: \", time_pitch_2_move)\n        self.sbus.move_gimbal(speed_pitch, 0, time_pitch_2_move)\n    elif (time_yaw_2_move &gt; 0) and (time_pitch_2_move &lt;= 0):\n        print(\"[DEBUG]: Gremsy H16 moves in yaw: TIME to complete movement: \", time_yaw_2_move)\n        self.sbus.move_gimbal(0, speed_yaw, time_yaw_2_move)\n    elif (time_yaw_2_move &lt;= 0) and (time_pitch_2_move &gt; 0):\n        print(\"[DEBUG]: Gremsy H16 moves in elevation: TIME to complete movement: \", time_pitch_2_move)\n        self.sbus.move_gimbal(speed_pitch, 0, time_pitch_2_move)\n    elif (time_yaw_2_move &lt;= 0) and (time_pitch_2_move &lt;= 0):\n        print(\"[DEBUG]: Gremsy H16 will not move\")\n        return\n</code></pre>"},{"location":"GimbalGremsyH16/#a2gmeasurements.GimbalGremsyH16.setPosControlGPModel","title":"<code>setPosControlGPModel(yaw=0, pitch=0)</code>","text":"<p>Finds the RC control value and time giving the desired yaw (or pitch, or both separately) for the gaussian regressor. </p> <p>Uses an iterative approach to find the RC control value and time to hold it by smartly searching in the grid composed by the RC control values and the times to hold it. The initial value of for the \"speed\" (RC control value) influences the convergence of the iterative method.</p> this function requires: <ol> <li>a better grid of measured \"speed\", time, angle. With the actual training samples, the prediction does not give physical consistent results (i.e. the time it takes to move 60 degrees at speed 20 is smaller than the one it takes to move 60 degrees at a lower speed). This is because the grid is coarse and not equally sampled.</li> <li>this function should guarantee that the returned time is always positive. Negative times does not make physical sense. Furthermore, it should also guarantee that the time is above a certain threshold (i.e. 2 seconds), during which the gimbal will accelerate until reaching the desired speed. In a realistic gimbal, the acceleration of the gimbal is not infinite. On the contrary, gimbal's speed vs time dependence follows usually a trapezoidal curve, which means that there is some time required (the threshold) for the gimbal to reach the plateau of the trapezoid (desired speed).</li> <li>the caller of this function (<code>setPosControl</code>) to handle when an exeception is raised.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>yaw</code> <code>int</code> <p>desired yaw angle to set in the interval [-180,180]. Defaults to 0.</p> <code>0</code> <code>pitch</code> <code>int</code> <p>desired pitch angle to set. Defaults to 0.</p> <code>0</code> <p>Raises:</p> Type Description <code>Exception</code> <p>when the optimization local function <code>find_feature_values_for_angle</code> does not converge.</p> <p>Returns:</p> Name Type Description <code>speed_yaw</code> <code>float</code> <p>required RC control value to set yaw.</p> <code>time_yaw</code> <code>float</code> <p>required time to set yaw. </p> <code>speed_pitch</code> <code>float</code> <p>required RC control value to set pitch</p> <code>time_pitch</code> <code>float</code> <p>required time to set pitch.</p> Source code in <code>a2gmeasurements.py</code> <pre><code>def setPosControlGPModel(self, yaw=0, pitch=0):\n    \"\"\"\n    Finds the RC control value and time giving the desired yaw (or pitch, or both separately) for the gaussian regressor. \n\n    Uses an iterative approach to find the RC control value and time to hold it by smartly searching in the grid composed by the RC control values and the times to hold it. The initial value of for the \"speed\" (RC control value) influences the convergence of the iterative method.\n\n    NOTE FOR DEVELOPERS: *this function requires*:\n     1. a better grid of measured \"speed\", time, angle. With the actual training samples, the prediction does not give physical consistent results (i.e. the time it takes to move 60 degrees at speed 20 is smaller than the one it takes to move 60 degrees at a lower speed). This is because the grid is coarse and not equally sampled.\n     2. this function should guarantee that the returned time is always positive. Negative times does not make physical sense. Furthermore, it should also guarantee that the time is above a certain threshold (i.e. 2 seconds), during which the gimbal will accelerate until reaching the desired speed. In a realistic gimbal, the acceleration of the gimbal is not infinite. On the contrary, gimbal's speed vs time dependence follows usually a trapezoidal curve, which means that there is some time required (the threshold) for the gimbal to reach the plateau of the trapezoid (desired speed).\n     3. the caller of this function (``setPosControl``) to handle when an exeception is raised.\n\n    Args:\n        yaw (int, optional): desired yaw angle to set in the interval [-180,180]. Defaults to 0.\n        pitch (int, optional): desired pitch angle to set. Defaults to 0.\n\n    Raises:\n        Exception: when the optimization local function ``find_feature_values_for_angle`` does not converge.\n\n    Returns:\n        speed_yaw (float): required RC control value to set yaw.\n        time_yaw (float): required time to set yaw. \n        speed_pitch (float): required RC control value to set pitch\n        time_pitch (float): required time to set pitch.\n    \"\"\"\n\n    start_time = time.time()\n\n    # Define a function to find the corresponding X values for the desired Y\n    def find_feature_values_for_angle(model, desired_angle, suggested_speed):           \n        # Define a function to minimize (difference between predicted and desired Y)\n        def objective_function(x):\n            #x = np.atleast_2d(x)\n            y = np.array([[suggested_speed, x]])\n            return np.abs(model.predict(y) - desired_angle)\n\n        # Initialize with a guess for speed and time\n        initial_guess = 3\n\n        # Use an optimization method to find the feature values that result in the desired yaw angle\n        result = minimize_scalar(objective_function, bounds=(0, 50), method='bounded')\n        #result = minimize(objective_function, initial_guess, method='Nelder-Mead')\n\n        if result.success:\n            return result.x\n        else:\n            raise Exception(\"Optimization did not converge.\")\n\n    total_time = time.time() - start_time\n\n    # Find the corresponding feature values (speed and time) for the desired angle\n    if yaw &gt; 0.0 and yaw &lt; 10:\n        speed_yaw = 10.0\n        time_yaw = find_feature_values_for_angle(self.az_speed_pos_regresor, yaw, speed_yaw)\n    elif yaw &gt;= 10.0 and yaw &lt; 60:\n        speed_yaw = 13.0\n        time_yaw = find_feature_values_for_angle(self.az_speed_neg_regresor, yaw, speed_yaw)\n    elif yaw &gt;= 60:\n        speed_yaw = 15.0\n        time_yaw = find_feature_values_for_angle(self.az_speed_neg_regresor, yaw, speed_yaw)\n    if yaw &lt; 0.0 and yaw &gt; -10:\n        speed_yaw = -3.0\n        time_yaw = find_feature_values_for_angle(self.az_speed_pos_regresor, yaw, speed_yaw)\n    elif yaw &lt;= -10.0 and yaw &gt; -60:\n        speed_yaw = -7.0\n        time_yaw = find_feature_values_for_angle(self.az_speed_neg_regresor, yaw, speed_yaw)\n    elif yaw &lt;= -60:\n        speed_yaw = -10.0\n        time_yaw = find_feature_values_for_angle(self.az_speed_neg_regresor, yaw, speed_yaw)\n    elif yaw == 0.0:\n        speed_yaw = 0\n        time_yaw = 0\n    if pitch &gt; 0.0 and pitch &lt; 10.0:\n        speed_pitch = 5.0\n        time_pitch = find_feature_values_for_angle(self.el_speed_pos_regresor, pitch, speed_pitch)\n    elif pitch &gt;=10 and pitch &lt; 60:\n        speed_pitch = 8.0\n        time_pitch = find_feature_values_for_angle(self.el_speed_pos_regresor, pitch, speed_pitch)\n    elif pitch &gt;= 60:\n        speed_pitch = 10.0\n        time_pitch = find_feature_values_for_angle(self.el_speed_pos_regresor, pitch, speed_pitch)\n    elif pitch &lt; 0.0 and pitch &gt; -10:\n        speed_pitch = -5.0\n        time_pitch = find_feature_values_for_angle(self.el_speed_neg_regresor, pitch, speed_pitch)\n    elif pitch &lt;-10 and pitch &gt; -60:\n        speed_pitch = -8.0\n        time_pitch = find_feature_values_for_angle(self.el_speed_neg_regresor, pitch, speed_pitch)\n    elif pitch &lt;= -60:\n        speed_pitch = -10.0\n        time_pitch = find_feature_values_for_angle(self.el_speed_neg_regresor, pitch, speed_pitch)\n    elif pitch == 0.0:\n        speed_pitch = 0\n        time_pitch = 0\n\n    #print(f\"[DEBUG]: Time it took to find the speed and time corresponding to the DESIRED ANGLE: {total_time}\")\n\n    return speed_yaw, time_yaw, speed_pitch, time_pitch\n</code></pre>"},{"location":"GimbalGremsyH16/#a2gmeasurements.GimbalGremsyH16.start_imu_thread","title":"<code>start_imu_thread(COM_PORT='COM21')</code>","text":"<p>Connects to the IMU and creates a new thread (the imu thread) to read the angle data from the IMU.</p> <p>:param COM_PORT: , defaults to 'COM21' :type COM_PORT: str, optional</p> <p>Parameters:</p> Name Type Description Default <code>COM_PORT</code> <code>str</code> <p>port where the IMU is connected. If this host computer's OS is Windows it would be <code>COM#</code>, if it is Linux it would be <code>/dev/ttyUSB#</code>. Defaults to <code>COM21</code>.</p> <code>'COM21'</code> Source code in <code>a2gmeasurements.py</code> <pre><code>def start_imu_thread(self, COM_PORT='COM21'):\n    \"\"\"\n    Connects to the IMU and creates a new thread (the imu thread) to read the angle data from the IMU.\n\n    :param COM_PORT: , defaults to 'COM21'\n    :type COM_PORT: str, optional\n\n    Args:\n        COM_PORT (str, optional): port where the IMU is connected. If this host computer's OS is Windows it would be ``COM#``, if it is Linux it would be ``/dev/ttyUSB#``. Defaults to ``COM21``.\n    \"\"\"\n\n    try:\n        self.imu_serial = serial.Serial(COM_PORT, 9600)\n        print(\"[DEBUG]: Connected to IMU\")\n    except Exception as e:\n        print(\"[DEBUG]: Exception when connecting to IMU: \", e)\n    else:\n        try:\n            self.event_stop_thread_imu = threading.Event()                \n            self.thread_read_imu = threading.Thread(target=self.receive_imu_data, args=(self.event_stop_thread_imu,))\n            self.thread_read_imu.start()\n            print(f\"[DEBUG]: READ IMU THREAD STARTED\")\n        except Exception as e:\n            print(\"[DEBUG]: Exception when starting READ IMU thread\")\n</code></pre>"},{"location":"GimbalGremsyH16/#a2gmeasurements.GimbalGremsyH16.start_thread_gimbal","title":"<code>start_thread_gimbal()</code>","text":"<p>Creates an instance of the <code>SBUSEncoder</code> class responsible for encoding the actual serial signal used by sbus protocol to set an RC control value.</p> <p>By creating such instance, the gremsy gimbal thread is created and started.</p> Source code in <code>a2gmeasurements.py</code> <pre><code>def start_thread_gimbal(self):\n    \"\"\"\n    Creates an instance of the ``SBUSEncoder`` class responsible for encoding the actual serial signal used by sbus protocol to set an RC control value.\n\n    By creating such instance, the gremsy gimbal thread is created and started.\n    \"\"\"\n\n    self.sbus = SBUSEncoder()\n    self.sbus.start_sbus(serial_interface='COM20', period_packet=0.015)\n\n    self.define_home_position()\n</code></pre>"},{"location":"GimbalGremsyH16/#a2gmeasurements.GimbalGremsyH16.stop_thread_gimbal","title":"<code>stop_thread_gimbal()</code>","text":"<p>Stops the imu thread and the <code>SBUSEncoder</code> gremsy gimbal thread.</p> Source code in <code>a2gmeasurements.py</code> <pre><code>def stop_thread_gimbal(self):\n    \"\"\"\n    Stops the imu thread and the ``SBUSEncoder`` gremsy gimbal thread.\n    \"\"\"\n    self.stop_thread_imu()\n    self.sbus.stop_updating()\n</code></pre>"},{"location":"GimbalGremsyH16/#a2gmeasurements.GimbalGremsyH16.stop_thread_imu","title":"<code>stop_thread_imu()</code>","text":"<p>Stops the imu thread and closed the serial port where the IMU is connected.</p> Source code in <code>a2gmeasurements.py</code> <pre><code>def stop_thread_imu(self):\n    \"\"\"\n    Stops the imu thread and closed the serial port where the IMU is connected.\n    \"\"\"\n\n    if self.thread_read_imu.is_alive():\n        self.event_stop_thread_imu.set()\n\n    self.imu_serial.close()\n</code></pre>"},{"location":"GimbalRS2/","title":"GimbalRS2 module","text":"<p>             Bases: <code>object</code></p> <p>Python Class that works as the driver for the gimbal DJI RS2.</p> <p>The gimbal should be connected to the host computer through an USB-to-PCAN bridge (PCAN System). </p> <p>It creates a thread (called here a gimbal thread) to handle the communication between the gimbal and this host computer.</p> <p>More info on \"Manual A2GMeasurements\".</p> <p>Gimbal control modified and extended from (based as well on DJI R SDK demo software):</p> <p>DJI ROS CONTROLLER</p> Source code in <code>a2gmeasurements.py</code> <pre><code>class GimbalRS2(object):\n    \"\"\"\n    Python Class that works as the driver for the gimbal DJI RS2.\n\n    The gimbal should be connected to the host computer through an USB-to-PCAN bridge (PCAN System). \n\n    It creates a thread (called here a gimbal thread) to handle the communication between the gimbal and this host computer.\n\n    More info on \"Manual A2GMeasurements\".\n\n    Gimbal control modified and extended from (based as well on DJI R SDK demo software):\n\n    [DJI ROS CONTROLLER](https://github.com/ceinem/dji_rs2_ros_controller)\n    \"\"\"   \n\n    def __init__(self, speed_yaw=40, speed_pitch=40, speed_roll=40, DBG_LVL_1=False, DBG_LVL_0=False):\n        \"\"\"\n        Initialize properties of the class, like the DJI SDK frame header, sequence number and others.\n\n        Args:\n            speed_yaw (int, optional): speed of yaw axis in deg/s. Defaults to 40.\n            speed_pitch (int, optional): speed of pitch axis in deg/s. Defaults to 40.\n            speed_roll (int, optional): speed of roll axis in deg/s. Defaults to 40.\n            DBG_LVL_1 (bool, optional): level of verbose to show at the command line (beta). This shows less verbose than the 0 level. Defaults to False.\n            DBG_LVL_0 (bool, optional): level of verbose to show at the command line (beta). Defaults to False.\n        \"\"\"      \n\n        self.header = 0xAA\n        self.enc = 0x00\n        self.res1 = 0x00\n        self.res2 = 0x00\n        self.res3 = 0x00\n        self.seq = 0x0002\n\n        self.send_id = 0x223\n        self.recv_id = 0x222\n\n        self.MAX_CAN_FRAME_LEN = 8\n\n        self.can_recv_msg_buffer = []\n        self.can_recv_msg_len_buffer = []\n        self.can_recv_buffer_len = 10\n\n        self.roll = 0.0\n        self.pitch = 0.0\n        self.yaw = 0.0\n\n        self.SPEED_YAW =  speed_yaw # deg/s\n        self.SPEED_PITCH =  speed_pitch # deg/s\n        self.SPEED_ROLL =  speed_roll # deg/s\n\n        self.MAIN_LOOP_STOP = True\n        self.keyboard_set_flag = False\n        self.keyboard_buff = []\n\n        self.cntBytes = 0\n        self.TIME_POS_REQ = 0.01\n        self.DBG_LVL_0 = DBG_LVL_0\n        self.DBG_LVL_1 = DBG_LVL_1\n\n        self.TIME2MOVE_180_DEG_YAW = 180/speed_yaw\n        self.TIME2MOVE_180_DEG_YAW = 180/speed_pitch\n        self.TIME2MOVE_180_DEG_YAW = 180/speed_roll\n\n    def seq_num(self):\n        \"\"\"\n        Updates the sequence number of the gimbal data.\n\n        Returns:\n            seq_str (str): number in hexadecimal split by a ``:``.\n        \"\"\"\n\n        if self.seq &gt;= 0xFFFD:\n            self.seq = 0x0002\n        self.seq += 1\n        # Seq_Init_Data = 0x1122\n        seq_str = \"%04x\" % self.seq\n        return seq_str[2:] + \":\" + seq_str[0:2]\n\n    def can_buffer_to_full_frame(self):\n        \"\"\"\n        Parse the full DJI R frame message from the can buffer.\n\n        Its fields are explained in the DJI R SDK Protocol and User Interface.\n\n        Returns:\n            full_msg_frames (list): a full message frame\n        \"\"\"\n\n        full_msg_frames = []\n        full_frame_counter = 0\n        for i in range(len(self.can_recv_msg_buffer)):\n            msg = self.can_recv_msg_buffer[i]\n            length = self.can_recv_msg_len_buffer[i]\n            msg = msg[:length]\n            cmd_data = ':'.join(msg)\n            # print(\"len: \" + str(length) + \" - \" +\n            #       str(msg) + \" -&gt; \" + cmd_data)\n            if msg[0] == \"AA\":\n                full_msg_frames.append(msg)\n                full_frame_counter += 1\n            if msg[0] != \"AA\" and (full_frame_counter &gt; 0):\n                # full_msg_frames[-1] += \":\"\n                for byte in msg:\n                    full_msg_frames[-1].append(byte)\n        return full_msg_frames\n\n    def validate_api_call(self, data_frame):\n        \"\"\"\n        CRC error check.\n\n        Args:\n            data_frame (list): DJI RS2 frame message\n\n        Returns:\n            validated (bool): passed or not the crc check\n        \"\"\"\n\n        validated = False\n        check_sum = ':'.join(data_frame[-4:])\n        data = ':'.join(data_frame[:-4])\n        # # print(len(hex_data))\n        # # print(data)\n        if len(data_frame) &gt;= 8:\n            crc_obj = Checksum()\n            if check_sum == crc_obj.calc_crc32(data):\n                #         # print(\"Approved Message: \" + str(hex_data))\n                header = ':'.join(data_frame[:10])\n                header_check_sum = ':'.join(data_frame[10:12])\n                if header_check_sum == crc_obj.calc_crc16(header):\n                    validated = True\n        return validated\n\n    def parse_position_response(self, data_frame):\n        \"\"\"\n        Retrieve the position from the full DJI frame message.\n\n        Args:\n            data_frame (list): DJI RS2 frame message\n        \"\"\"\n\n        pos_data = data_frame[16:-4]\n        yaw = int(\n            '0x' + pos_data[1] + pos_data[0], base=16)\n        roll = int(\n            '0x' + pos_data[3] + pos_data[2], base=16)\n        pitch = int(\n            '0x' + pos_data[5] + pos_data[4], base=16)\n        if yaw &gt; 1800:\n            yaw -= 65538\n        if roll &gt; 1800:\n            roll -= 65538\n        if pitch &gt; 1800:\n            pitch -= 65538\n\n        # Radians\n        #self.yaw = yaw * 0.1 * np.pi / 180\n        #self.roll = roll * 0.1 * np.pi / 180\n        #self.pitch = pitch * 0.1 * np.pi / 180\n\n        # Degrees\n        self.yaw = yaw * 0.1 \n        self.roll = roll * 0.1\n        self.pitch = pitch * 0.1\n\n        output = \"Pitch: \" + \\\n            str(self.pitch) + \", Yaw: \" + \\\n            str(self.yaw) + \", Roll: \" + str(self.roll)\n\n        print(output + '\\n')\n\n    def can_callback(self, data):\n        \"\"\"\n        Callback for the thread in charge of checking the USB-to-CAN input (receive).\n\n        Args:\n            data (list): DJI RS2 frame message\n        \"\"\"\n\n        str_data = ['{:02X}'.format(i) for i in data.data]\n\n        self.can_recv_msg_buffer.append(str_data)\n        self.can_recv_msg_len_buffer.append(data.dlc)\n\n        if len(self.can_recv_msg_buffer) &gt; self.can_recv_buffer_len:\n            self.can_recv_msg_buffer.pop(0)\n            self.can_recv_msg_len_buffer.pop(0)\n\n        full_msg_frames = self.can_buffer_to_full_frame()\n\n        for hex_data in full_msg_frames:\n            if self.validate_api_call(hex_data):\n                request_data = \":\".join(hex_data[12:14])\n                if request_data == \"0E:02\":\n                    # This is response data to a get position request\n                    if self.DBG_LVL_1:\n                        print('\\nResponse received to request_current_position on gimbal RS2')\n                    self.parse_position_response(hex_data)\n                elif request_data == \"0E:00\":\n                    # Parse response to control handheld gimbal position\n                    1\n                elif request_data == \"0E:01\":\n                    # Parse response to Control handheld gimbal speed\n                    print('\\nObtained a response to setSpeedControl')\n                elif request_data == \"0E:03\":\n                    # Parse response to Set handheld gimbal limit angle\n                    1\n                elif request_data == \"0E:04\":\n                    # Parse response to Obtain handheld gimbal limit angle\n                    1\n                elif request_data == \"0E:05\":\n                    # Parse response to Set handheld gimbal motor stifness\n                    1\n                elif request_data == \"0E:06\":\n                    # Parse response to Obtain handheld gimbal limit angle\n                    1\n                elif request_data == \"0E:07\":\n                    # Parse response to Set information push of handheld gimbal parameters\n                    1\n                elif request_data == \"0E:08\":\n                    # Parse response to Push handheld gimbal parameters\n                    1\n                elif request_data == \"0E:09\":\n                    # Parse response to Obtain module version number\n                    1\n                elif request_data == \"0E:0A\":\n                    # Parse response to Push joystick control comand\n                    1\n                elif request_data == \"0E:0B\":\n                    # Parse response to Obtain handheld gimbal user parameters\n                    1\n                elif request_data == \"0E:0C\":\n                    # Parse response to Set handheld gimbal user parameters\n                    1\n                elif request_data == \"0E:0D\":\n                    # Parse response to Set handheld gimbal operation mode\n                    1\n                elif request_data == \"0E:0E\":\n                    # Parse response to Set gimbal Recenter, Selfie, amd Follow modes\n                    1\n                elif request_data == \"0D:00\":\n                    # Parse response to Third-party motion comand\n                    1\n                elif request_data == \"0D:01\":\n                    # Parse response to Third-party camera status obtain comand\n                    1\n                else:\n                    print('\\n[ERROR]: error on gimbal command reception, error code: ', request_data)\n\n    def setPosControl(self, yaw, roll, pitch, ctrl_byte=0x01, time_for_action=0x14):\n        \"\"\"\n        Set the gimbal position by providing the yaw, roll and pitch.\n\n        Args:\n            yaw (int): yaw angle. Value should be between -1800 and 1800.\n            roll (int): roll angle. value should be betweeen -1800 and 1800. However, gimbal might stop if it reachs its maximum/minimum (this) axis value.\n            pitch (int): pitch angle. value should be betweeen -1800 and 1800. However, gimbal might stop if it reachs its maximum/minimum (this) axis value.\n            ctrl_byte (hexadecimal, optional): Absolute or relative movement. For absolute use 0x01, while for relative use 0x00. Defaults to 0x01.\n            time_for_action (hexadecimal, optional): Time it takes for the gimbal to move to desired position. Implicitly, this command controls the speed of gimbal. It is given in units of 0.1 s. For example: a value of 0x14 is 20, which means that the gimbal will take 2s (20*0.1) to reach its destination. Defaults to 0x14.\n\n        Returns:\n            True (bool): always returns the same, unless there is a raising error.\n        \"\"\"\n\n        # yaw, roll, pitch in 0.1 steps (-1800,1800)\n        # ctrl_byte always to 1\n        # time_for_action to define speed in 0.1sec\n        hex_data = struct.pack('&lt;3h2B', yaw, roll, pitch,\n                               ctrl_byte, time_for_action)\n\n        pack_data = ['{:02X}'.format(i) for i in hex_data]\n        cmd_data = ':'.join(pack_data)\n        # print(cmd_data)\n        cmd = self.assemble_can_msg(cmd_type='03', cmd_set='0E',\n                                    cmd_id='00', data=cmd_data)\n\n        self.send_cmd(cmd)\n\n        # Save the current pitch and yaw values\n        if ctrl_byte == 0x00:\n            self.pitch = self.pitch + pitch\n            self.yaw = self.yaw + yaw\n        elif ctrl_byte == 0x01:\n            self.pitch = pitch\n            self.yaw = yaw\n\n        if self.pitch &gt; 1800 and self.pitch &lt;= 3600:\n            self.pitch = self.pitch - 3600 \n        elif self.pitch &lt; -1800 and self.pitch &gt;= -3600:\n            self.pitch = self.pitch + 3600\n\n        if self.yaw &gt; 1800 and self.yaw &lt;= 3600:\n            self.yaw = self.yaw - 3600\n        elif self.yaw &lt; -1800 and self.yaw &gt;= -3600:\n            self.yaw = self.yaw + 3600\n\n        return True    \n\n    def setSpeedControl(self, yaw, roll, pitch, ctrl_byte=0x80):\n        \"\"\"\n        Sets speed for each axis of the gimbal.\n\n        Always after seting the speed the gimbal roll is moved (strange behaviour). \n\n        Developer has to send a setPosControl to set again the position of the gimbal where it was previously.\n\n        Args:\n            yaw (int): yaw speed in units of 0.1 deg/s.\n            roll (int): roll speed in units of 0.1 deg/s.\n            pitch (int): pitch speed in units of 0.1 deg/s.\n            ctrl_byte (hexadecimal, optional): check DJI SDK manual. Defaults to 0x80.\n\n        Returns:\n            True (bool): True if provided arguments are within acceptable range. False otherwise.\n        \"\"\"\n\n        if -3600 &lt;= yaw &lt;= 3600 and -3600 &lt;= roll &lt;= 3600 and -3600 &lt;= pitch &lt;= 3600:\n\n            hex_data = struct.pack('&lt;3hB', yaw, roll, pitch, ctrl_byte)\n            pack_data = ['{:02X}'.format(i) for i in hex_data]\n            cmd_data = ':'.join(pack_data)\n\n            cmd = self.assemble_can_msg(cmd_type='03', cmd_set='0E',\n                                        cmd_id='01', data=cmd_data)\n            # print('cmd---data {}'.format(cmd))\n            self.send_cmd(cmd)\n\n            return True\n        else:\n            return False\n\n    def request_current_position(self):\n        \"\"\"\n        Sends command to request the current position of the gimbal.\n\n        Blocks thread execution for the time given by attribute ``TIME_POS_REQ`` to allow the response to be received.\n        \"\"\"\n\n        hex_data = [0x01]\n        pack_data = ['{:02X}'.format(i)\n                     for i in hex_data]\n        cmd_data = ':'.join(pack_data)\n        cmd = self.assemble_can_msg(cmd_type='03', cmd_set='0E',\n                                    cmd_id='02', data=cmd_data)\n        self.send_cmd(cmd)\n\n        # Time to receive response from gimbal\n        time.sleep(self.TIME_POS_REQ)\n\n    def assemble_can_msg(self, cmd_type, cmd_set, cmd_id, data):\n        \"\"\"\n        Builds a DJI RS2 message frame based on the command to be sent.\n\n        Args:\n            cmd_type (int): see DJI R SDK Protocol and User Interface document for a description.\n            cmd_set (int): see DJI R SDK Protocol and User Interface document for a description.\n            cmd_id (int): see DJI R SDK Protocol and User Interface document for a description.\n            data (int): see DJI R SDK Protocol and User Interface document for a description.\n\n        Returns:\n            whole_can_frame (str): parsed can frame whose fields are separated by \":\".\n        \"\"\"\n\n        if data == \"\":\n            can_frame_data = \"{prefix}\" + \\\n                \":{cmd_set}:{cmd_id}\".format(\n                    cmd_set=cmd_set, cmd_id=cmd_id)\n        else:\n            can_frame_data = \"{prefix}\" + \":{cmd_set}:{cmd_id}:{data}\".format(\n                cmd_set=cmd_set, cmd_id=cmd_id, data=data)\n\n        cmd_length = len(can_frame_data.split(\":\")) + 15\n\n        seqnum = self.seq_num()\n        # ic(seqnum)\n        can_frame_header = \"{header:02x}\".format(\n            header=self.header)  # SOF byte\n        can_frame_header += \":\" + \\\n            (\"%04x\" % (cmd_length))[2:4]  # 1st length byte\n        can_frame_header += \":\" + \\\n            (\"%04x\" % (cmd_length))[0:2]  # 2nd length byte\n        can_frame_header += \":\" + \\\n            \"{cmd_type}\".format(cmd_type=cmd_type)  # Command Type\n        can_frame_header += \":\" + \"{enc:02x}\".format(enc=self.enc)  # Encoding\n        can_frame_header += \":\" + \\\n            \"{res1:02x}\".format(res1=self.res1)  # Reserved 1\n        can_frame_header += \":\" + \\\n            \"{res2:02x}\".format(res2=self.res2)  # Reserved 2\n        can_frame_header += \":\" + \\\n            \"{res3:02x}\".format(res3=self.res3)  # Reserved 3\n        can_frame_header += \":\" + seqnum    # Sequence number\n\n        crc_obj = Checksum()\n        can_frame_header += \":\" + crc_obj.calc_crc16(can_frame_header)\n\n        # hex_seq = [eval(\"0x\" + hex_num) for hex_num in can_frame_header.split(\":\")]\n\n        whole_can_frame = can_frame_data.format(prefix=can_frame_header)\n        whole_can_frame += \":\" + crc_obj.calc_crc32(whole_can_frame)\n        whole_can_frame = whole_can_frame.upper()\n        #\n        # print(\"Header: \", can_frame_header)\n        # print(\"Total: \", whole_can_frame)\n        return whole_can_frame\n\n    def send_cmd(self, cmd):\n        \"\"\"\n        Wrapper to ``send_data`` method.\n\n        Args:\n            cmd (str): command fields separated by ':'.\n        \"\"\"\n\n        data = [int(i, 16) for i in cmd.split(\":\")]\n        self.send_data(self.send_id, data)\n\n    def send_data(self, can_id, data):\n        \"\"\"\n        Sends a command through the can bus.\n\n        Args:\n            can_id (int): static can id.\n            data (list): fields of the frame.\n        \"\"\"\n\n        data_len = len(data)\n        full_frame_num, left_len = divmod(data_len, self.MAX_CAN_FRAME_LEN)\n\n        if left_len == 0:\n            frame_num = full_frame_num\n        else:\n            frame_num = full_frame_num + 1\n\n        data_offset = 0\n\n        full_msg = []\n        for i in range(full_frame_num):\n            full_msg.append(can.Message(arbitration_id=can_id, dlc=8, data=data[data_offset:data_offset + self.MAX_CAN_FRAME_LEN], \n                                            is_extended_id=False, is_error_frame=False, is_remote_frame=False))\n            data_offset += self.MAX_CAN_FRAME_LEN\n\n        # If there is data left over, the last frame isn't 8byte long\n\n        if left_len &gt; 0:\n            full_msg.append(can.Message(arbitration_id=can_id, dlc=left_len, data=data[data_offset:data_offset + left_len], \n                                            is_extended_id=False, is_error_frame=False, is_remote_frame=False))        \n\n        for m in full_msg:\n            try:\n                self.actual_bus.send(m)\n                if self.DBG_LVL_0:\n                    print('\\ngimbal RS2 Message sent on ', self.actual_bus.channel_info)\n            except can.CanError:\n                print(\"\\n[ERROR]: gimbal RS2 Message NOT sent\")\n                return\n\n    def receive(self, bus, stop_event):\n        \"\"\"\n        Threading callback function. Defined when the thread is created. This thread listens for coming (received) can messages on a USB port. Reads 1 entry of the rx bus buffer at a time.\n\n        Args:\n            bus (can.Bus object): object pointing to the type of bus (from 'can' python package).\n            stop_event (threading.Event): works as a flag to stop receiving messages.\n        \"\"\"\n\n        if self.DBG_LVL_0:\n            print(\"Start receiving messages\")\n        while not stop_event.is_set():\n            try:\n                rx_msg = bus.recv(1)\n                if rx_msg is not None:    \n                    self.cntBytes = self.cntBytes + 1\n                    self.can_callback(rx_msg)\n            except Exception as e:\n                #There might be an error due to the gimbal disconnecting itself due to improper balance\n                print(\"[DEBUG]: Error in Gimbal RS2 callback, \", e)\n\n        if self.DBG_LVL_0:\n            print(\"Stopped receiving messages\")\n\n    def start_thread_gimbal(self, bitrate=1000000):\n        \"\"\"\n        Starts the thread for listening the incoming data (if any) from the gimbal.\n\n        Args:\n            bitrate (int, optional): Bitrate for the usb-to-can interface. This is a parameter inherited from can.Bus. Defaults to 1000000.\n        \"\"\"\n\n        try:\n            bus = can.interface.Bus(interface=\"pcan\", channel=\"PCAN_USBBUS1\", bitrate=bitrate)\n            self.actual_bus = bus\n        except Exception as e:\n            print(e)\n            self.GIMBAL_CONN_SUCCES = False\n            print(\"\\n[DEBUG]: Gimbal thread NOT started\")\n            return\n\n        self.event_stop_thread_gimbal = threading.Event()                              \n        t_receive = threading.Thread(target=self.receive, args=(self.actual_bus,self.event_stop_thread_gimbal))\n        t_receive.start()\n\n        self.GIMBAL_CONN_SUCCES = True\n        print(\"\\n[DEBUG]: Gimbal thread started\")\n\n        #self.setSpeedControl(int(self.SPEED_YAW*10), int(self.SPEED_ROLL*10), int(self.SPEED_PITCH*10))\n\n    def stop_thread_gimbal(self):\n        \"\"\"\n        Stops the gimbal thread by setting the threading. Event attribute created in ``start_thread_gimbal``.\n        \"\"\"        \n        self.event_stop_thread_gimbal.set()        \n</code></pre>"},{"location":"GimbalRS2/#a2gmeasurements.GimbalRS2.__init__","title":"<code>__init__(speed_yaw=40, speed_pitch=40, speed_roll=40, DBG_LVL_1=False, DBG_LVL_0=False)</code>","text":"<p>Initialize properties of the class, like the DJI SDK frame header, sequence number and others.</p> <p>Parameters:</p> Name Type Description Default <code>speed_yaw</code> <code>int</code> <p>speed of yaw axis in deg/s. Defaults to 40.</p> <code>40</code> <code>speed_pitch</code> <code>int</code> <p>speed of pitch axis in deg/s. Defaults to 40.</p> <code>40</code> <code>speed_roll</code> <code>int</code> <p>speed of roll axis in deg/s. Defaults to 40.</p> <code>40</code> <code>DBG_LVL_1</code> <code>bool</code> <p>level of verbose to show at the command line (beta). This shows less verbose than the 0 level. Defaults to False.</p> <code>False</code> <code>DBG_LVL_0</code> <code>bool</code> <p>level of verbose to show at the command line (beta). Defaults to False.</p> <code>False</code> Source code in <code>a2gmeasurements.py</code> <pre><code>def __init__(self, speed_yaw=40, speed_pitch=40, speed_roll=40, DBG_LVL_1=False, DBG_LVL_0=False):\n    \"\"\"\n    Initialize properties of the class, like the DJI SDK frame header, sequence number and others.\n\n    Args:\n        speed_yaw (int, optional): speed of yaw axis in deg/s. Defaults to 40.\n        speed_pitch (int, optional): speed of pitch axis in deg/s. Defaults to 40.\n        speed_roll (int, optional): speed of roll axis in deg/s. Defaults to 40.\n        DBG_LVL_1 (bool, optional): level of verbose to show at the command line (beta). This shows less verbose than the 0 level. Defaults to False.\n        DBG_LVL_0 (bool, optional): level of verbose to show at the command line (beta). Defaults to False.\n    \"\"\"      \n\n    self.header = 0xAA\n    self.enc = 0x00\n    self.res1 = 0x00\n    self.res2 = 0x00\n    self.res3 = 0x00\n    self.seq = 0x0002\n\n    self.send_id = 0x223\n    self.recv_id = 0x222\n\n    self.MAX_CAN_FRAME_LEN = 8\n\n    self.can_recv_msg_buffer = []\n    self.can_recv_msg_len_buffer = []\n    self.can_recv_buffer_len = 10\n\n    self.roll = 0.0\n    self.pitch = 0.0\n    self.yaw = 0.0\n\n    self.SPEED_YAW =  speed_yaw # deg/s\n    self.SPEED_PITCH =  speed_pitch # deg/s\n    self.SPEED_ROLL =  speed_roll # deg/s\n\n    self.MAIN_LOOP_STOP = True\n    self.keyboard_set_flag = False\n    self.keyboard_buff = []\n\n    self.cntBytes = 0\n    self.TIME_POS_REQ = 0.01\n    self.DBG_LVL_0 = DBG_LVL_0\n    self.DBG_LVL_1 = DBG_LVL_1\n\n    self.TIME2MOVE_180_DEG_YAW = 180/speed_yaw\n    self.TIME2MOVE_180_DEG_YAW = 180/speed_pitch\n    self.TIME2MOVE_180_DEG_YAW = 180/speed_roll\n</code></pre>"},{"location":"GimbalRS2/#a2gmeasurements.GimbalRS2.assemble_can_msg","title":"<code>assemble_can_msg(cmd_type, cmd_set, cmd_id, data)</code>","text":"<p>Builds a DJI RS2 message frame based on the command to be sent.</p> <p>Parameters:</p> Name Type Description Default <code>cmd_type</code> <code>int</code> <p>see DJI R SDK Protocol and User Interface document for a description.</p> required <code>cmd_set</code> <code>int</code> <p>see DJI R SDK Protocol and User Interface document for a description.</p> required <code>cmd_id</code> <code>int</code> <p>see DJI R SDK Protocol and User Interface document for a description.</p> required <code>data</code> <code>int</code> <p>see DJI R SDK Protocol and User Interface document for a description.</p> required <p>Returns:</p> Name Type Description <code>whole_can_frame</code> <code>str</code> <p>parsed can frame whose fields are separated by \":\".</p> Source code in <code>a2gmeasurements.py</code> <pre><code>def assemble_can_msg(self, cmd_type, cmd_set, cmd_id, data):\n    \"\"\"\n    Builds a DJI RS2 message frame based on the command to be sent.\n\n    Args:\n        cmd_type (int): see DJI R SDK Protocol and User Interface document for a description.\n        cmd_set (int): see DJI R SDK Protocol and User Interface document for a description.\n        cmd_id (int): see DJI R SDK Protocol and User Interface document for a description.\n        data (int): see DJI R SDK Protocol and User Interface document for a description.\n\n    Returns:\n        whole_can_frame (str): parsed can frame whose fields are separated by \":\".\n    \"\"\"\n\n    if data == \"\":\n        can_frame_data = \"{prefix}\" + \\\n            \":{cmd_set}:{cmd_id}\".format(\n                cmd_set=cmd_set, cmd_id=cmd_id)\n    else:\n        can_frame_data = \"{prefix}\" + \":{cmd_set}:{cmd_id}:{data}\".format(\n            cmd_set=cmd_set, cmd_id=cmd_id, data=data)\n\n    cmd_length = len(can_frame_data.split(\":\")) + 15\n\n    seqnum = self.seq_num()\n    # ic(seqnum)\n    can_frame_header = \"{header:02x}\".format(\n        header=self.header)  # SOF byte\n    can_frame_header += \":\" + \\\n        (\"%04x\" % (cmd_length))[2:4]  # 1st length byte\n    can_frame_header += \":\" + \\\n        (\"%04x\" % (cmd_length))[0:2]  # 2nd length byte\n    can_frame_header += \":\" + \\\n        \"{cmd_type}\".format(cmd_type=cmd_type)  # Command Type\n    can_frame_header += \":\" + \"{enc:02x}\".format(enc=self.enc)  # Encoding\n    can_frame_header += \":\" + \\\n        \"{res1:02x}\".format(res1=self.res1)  # Reserved 1\n    can_frame_header += \":\" + \\\n        \"{res2:02x}\".format(res2=self.res2)  # Reserved 2\n    can_frame_header += \":\" + \\\n        \"{res3:02x}\".format(res3=self.res3)  # Reserved 3\n    can_frame_header += \":\" + seqnum    # Sequence number\n\n    crc_obj = Checksum()\n    can_frame_header += \":\" + crc_obj.calc_crc16(can_frame_header)\n\n    # hex_seq = [eval(\"0x\" + hex_num) for hex_num in can_frame_header.split(\":\")]\n\n    whole_can_frame = can_frame_data.format(prefix=can_frame_header)\n    whole_can_frame += \":\" + crc_obj.calc_crc32(whole_can_frame)\n    whole_can_frame = whole_can_frame.upper()\n    #\n    # print(\"Header: \", can_frame_header)\n    # print(\"Total: \", whole_can_frame)\n    return whole_can_frame\n</code></pre>"},{"location":"GimbalRS2/#a2gmeasurements.GimbalRS2.can_buffer_to_full_frame","title":"<code>can_buffer_to_full_frame()</code>","text":"<p>Parse the full DJI R frame message from the can buffer.</p> <p>Its fields are explained in the DJI R SDK Protocol and User Interface.</p> <p>Returns:</p> Name Type Description <code>full_msg_frames</code> <code>list</code> <p>a full message frame</p> Source code in <code>a2gmeasurements.py</code> <pre><code>def can_buffer_to_full_frame(self):\n    \"\"\"\n    Parse the full DJI R frame message from the can buffer.\n\n    Its fields are explained in the DJI R SDK Protocol and User Interface.\n\n    Returns:\n        full_msg_frames (list): a full message frame\n    \"\"\"\n\n    full_msg_frames = []\n    full_frame_counter = 0\n    for i in range(len(self.can_recv_msg_buffer)):\n        msg = self.can_recv_msg_buffer[i]\n        length = self.can_recv_msg_len_buffer[i]\n        msg = msg[:length]\n        cmd_data = ':'.join(msg)\n        # print(\"len: \" + str(length) + \" - \" +\n        #       str(msg) + \" -&gt; \" + cmd_data)\n        if msg[0] == \"AA\":\n            full_msg_frames.append(msg)\n            full_frame_counter += 1\n        if msg[0] != \"AA\" and (full_frame_counter &gt; 0):\n            # full_msg_frames[-1] += \":\"\n            for byte in msg:\n                full_msg_frames[-1].append(byte)\n    return full_msg_frames\n</code></pre>"},{"location":"GimbalRS2/#a2gmeasurements.GimbalRS2.can_callback","title":"<code>can_callback(data)</code>","text":"<p>Callback for the thread in charge of checking the USB-to-CAN input (receive).</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>list</code> <p>DJI RS2 frame message</p> required Source code in <code>a2gmeasurements.py</code> <pre><code>def can_callback(self, data):\n    \"\"\"\n    Callback for the thread in charge of checking the USB-to-CAN input (receive).\n\n    Args:\n        data (list): DJI RS2 frame message\n    \"\"\"\n\n    str_data = ['{:02X}'.format(i) for i in data.data]\n\n    self.can_recv_msg_buffer.append(str_data)\n    self.can_recv_msg_len_buffer.append(data.dlc)\n\n    if len(self.can_recv_msg_buffer) &gt; self.can_recv_buffer_len:\n        self.can_recv_msg_buffer.pop(0)\n        self.can_recv_msg_len_buffer.pop(0)\n\n    full_msg_frames = self.can_buffer_to_full_frame()\n\n    for hex_data in full_msg_frames:\n        if self.validate_api_call(hex_data):\n            request_data = \":\".join(hex_data[12:14])\n            if request_data == \"0E:02\":\n                # This is response data to a get position request\n                if self.DBG_LVL_1:\n                    print('\\nResponse received to request_current_position on gimbal RS2')\n                self.parse_position_response(hex_data)\n            elif request_data == \"0E:00\":\n                # Parse response to control handheld gimbal position\n                1\n            elif request_data == \"0E:01\":\n                # Parse response to Control handheld gimbal speed\n                print('\\nObtained a response to setSpeedControl')\n            elif request_data == \"0E:03\":\n                # Parse response to Set handheld gimbal limit angle\n                1\n            elif request_data == \"0E:04\":\n                # Parse response to Obtain handheld gimbal limit angle\n                1\n            elif request_data == \"0E:05\":\n                # Parse response to Set handheld gimbal motor stifness\n                1\n            elif request_data == \"0E:06\":\n                # Parse response to Obtain handheld gimbal limit angle\n                1\n            elif request_data == \"0E:07\":\n                # Parse response to Set information push of handheld gimbal parameters\n                1\n            elif request_data == \"0E:08\":\n                # Parse response to Push handheld gimbal parameters\n                1\n            elif request_data == \"0E:09\":\n                # Parse response to Obtain module version number\n                1\n            elif request_data == \"0E:0A\":\n                # Parse response to Push joystick control comand\n                1\n            elif request_data == \"0E:0B\":\n                # Parse response to Obtain handheld gimbal user parameters\n                1\n            elif request_data == \"0E:0C\":\n                # Parse response to Set handheld gimbal user parameters\n                1\n            elif request_data == \"0E:0D\":\n                # Parse response to Set handheld gimbal operation mode\n                1\n            elif request_data == \"0E:0E\":\n                # Parse response to Set gimbal Recenter, Selfie, amd Follow modes\n                1\n            elif request_data == \"0D:00\":\n                # Parse response to Third-party motion comand\n                1\n            elif request_data == \"0D:01\":\n                # Parse response to Third-party camera status obtain comand\n                1\n            else:\n                print('\\n[ERROR]: error on gimbal command reception, error code: ', request_data)\n</code></pre>"},{"location":"GimbalRS2/#a2gmeasurements.GimbalRS2.parse_position_response","title":"<code>parse_position_response(data_frame)</code>","text":"<p>Retrieve the position from the full DJI frame message.</p> <p>Parameters:</p> Name Type Description Default <code>data_frame</code> <code>list</code> <p>DJI RS2 frame message</p> required Source code in <code>a2gmeasurements.py</code> <pre><code>def parse_position_response(self, data_frame):\n    \"\"\"\n    Retrieve the position from the full DJI frame message.\n\n    Args:\n        data_frame (list): DJI RS2 frame message\n    \"\"\"\n\n    pos_data = data_frame[16:-4]\n    yaw = int(\n        '0x' + pos_data[1] + pos_data[0], base=16)\n    roll = int(\n        '0x' + pos_data[3] + pos_data[2], base=16)\n    pitch = int(\n        '0x' + pos_data[5] + pos_data[4], base=16)\n    if yaw &gt; 1800:\n        yaw -= 65538\n    if roll &gt; 1800:\n        roll -= 65538\n    if pitch &gt; 1800:\n        pitch -= 65538\n\n    # Radians\n    #self.yaw = yaw * 0.1 * np.pi / 180\n    #self.roll = roll * 0.1 * np.pi / 180\n    #self.pitch = pitch * 0.1 * np.pi / 180\n\n    # Degrees\n    self.yaw = yaw * 0.1 \n    self.roll = roll * 0.1\n    self.pitch = pitch * 0.1\n\n    output = \"Pitch: \" + \\\n        str(self.pitch) + \", Yaw: \" + \\\n        str(self.yaw) + \", Roll: \" + str(self.roll)\n\n    print(output + '\\n')\n</code></pre>"},{"location":"GimbalRS2/#a2gmeasurements.GimbalRS2.receive","title":"<code>receive(bus, stop_event)</code>","text":"<p>Threading callback function. Defined when the thread is created. This thread listens for coming (received) can messages on a USB port. Reads 1 entry of the rx bus buffer at a time.</p> <p>Parameters:</p> Name Type Description Default <code>bus</code> <code>can.Bus object</code> <p>object pointing to the type of bus (from 'can' python package).</p> required <code>stop_event</code> <code>Event</code> <p>works as a flag to stop receiving messages.</p> required Source code in <code>a2gmeasurements.py</code> <pre><code>def receive(self, bus, stop_event):\n    \"\"\"\n    Threading callback function. Defined when the thread is created. This thread listens for coming (received) can messages on a USB port. Reads 1 entry of the rx bus buffer at a time.\n\n    Args:\n        bus (can.Bus object): object pointing to the type of bus (from 'can' python package).\n        stop_event (threading.Event): works as a flag to stop receiving messages.\n    \"\"\"\n\n    if self.DBG_LVL_0:\n        print(\"Start receiving messages\")\n    while not stop_event.is_set():\n        try:\n            rx_msg = bus.recv(1)\n            if rx_msg is not None:    \n                self.cntBytes = self.cntBytes + 1\n                self.can_callback(rx_msg)\n        except Exception as e:\n            #There might be an error due to the gimbal disconnecting itself due to improper balance\n            print(\"[DEBUG]: Error in Gimbal RS2 callback, \", e)\n\n    if self.DBG_LVL_0:\n        print(\"Stopped receiving messages\")\n</code></pre>"},{"location":"GimbalRS2/#a2gmeasurements.GimbalRS2.request_current_position","title":"<code>request_current_position()</code>","text":"<p>Sends command to request the current position of the gimbal.</p> <p>Blocks thread execution for the time given by attribute <code>TIME_POS_REQ</code> to allow the response to be received.</p> Source code in <code>a2gmeasurements.py</code> <pre><code>def request_current_position(self):\n    \"\"\"\n    Sends command to request the current position of the gimbal.\n\n    Blocks thread execution for the time given by attribute ``TIME_POS_REQ`` to allow the response to be received.\n    \"\"\"\n\n    hex_data = [0x01]\n    pack_data = ['{:02X}'.format(i)\n                 for i in hex_data]\n    cmd_data = ':'.join(pack_data)\n    cmd = self.assemble_can_msg(cmd_type='03', cmd_set='0E',\n                                cmd_id='02', data=cmd_data)\n    self.send_cmd(cmd)\n\n    # Time to receive response from gimbal\n    time.sleep(self.TIME_POS_REQ)\n</code></pre>"},{"location":"GimbalRS2/#a2gmeasurements.GimbalRS2.send_cmd","title":"<code>send_cmd(cmd)</code>","text":"<p>Wrapper to <code>send_data</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>cmd</code> <code>str</code> <p>command fields separated by ':'.</p> required Source code in <code>a2gmeasurements.py</code> <pre><code>def send_cmd(self, cmd):\n    \"\"\"\n    Wrapper to ``send_data`` method.\n\n    Args:\n        cmd (str): command fields separated by ':'.\n    \"\"\"\n\n    data = [int(i, 16) for i in cmd.split(\":\")]\n    self.send_data(self.send_id, data)\n</code></pre>"},{"location":"GimbalRS2/#a2gmeasurements.GimbalRS2.send_data","title":"<code>send_data(can_id, data)</code>","text":"<p>Sends a command through the can bus.</p> <p>Parameters:</p> Name Type Description Default <code>can_id</code> <code>int</code> <p>static can id.</p> required <code>data</code> <code>list</code> <p>fields of the frame.</p> required Source code in <code>a2gmeasurements.py</code> <pre><code>def send_data(self, can_id, data):\n    \"\"\"\n    Sends a command through the can bus.\n\n    Args:\n        can_id (int): static can id.\n        data (list): fields of the frame.\n    \"\"\"\n\n    data_len = len(data)\n    full_frame_num, left_len = divmod(data_len, self.MAX_CAN_FRAME_LEN)\n\n    if left_len == 0:\n        frame_num = full_frame_num\n    else:\n        frame_num = full_frame_num + 1\n\n    data_offset = 0\n\n    full_msg = []\n    for i in range(full_frame_num):\n        full_msg.append(can.Message(arbitration_id=can_id, dlc=8, data=data[data_offset:data_offset + self.MAX_CAN_FRAME_LEN], \n                                        is_extended_id=False, is_error_frame=False, is_remote_frame=False))\n        data_offset += self.MAX_CAN_FRAME_LEN\n\n    # If there is data left over, the last frame isn't 8byte long\n\n    if left_len &gt; 0:\n        full_msg.append(can.Message(arbitration_id=can_id, dlc=left_len, data=data[data_offset:data_offset + left_len], \n                                        is_extended_id=False, is_error_frame=False, is_remote_frame=False))        \n\n    for m in full_msg:\n        try:\n            self.actual_bus.send(m)\n            if self.DBG_LVL_0:\n                print('\\ngimbal RS2 Message sent on ', self.actual_bus.channel_info)\n        except can.CanError:\n            print(\"\\n[ERROR]: gimbal RS2 Message NOT sent\")\n            return\n</code></pre>"},{"location":"GimbalRS2/#a2gmeasurements.GimbalRS2.seq_num","title":"<code>seq_num()</code>","text":"<p>Updates the sequence number of the gimbal data.</p> <p>Returns:</p> Name Type Description <code>seq_str</code> <code>str</code> <p>number in hexadecimal split by a <code>:</code>.</p> Source code in <code>a2gmeasurements.py</code> <pre><code>def seq_num(self):\n    \"\"\"\n    Updates the sequence number of the gimbal data.\n\n    Returns:\n        seq_str (str): number in hexadecimal split by a ``:``.\n    \"\"\"\n\n    if self.seq &gt;= 0xFFFD:\n        self.seq = 0x0002\n    self.seq += 1\n    # Seq_Init_Data = 0x1122\n    seq_str = \"%04x\" % self.seq\n    return seq_str[2:] + \":\" + seq_str[0:2]\n</code></pre>"},{"location":"GimbalRS2/#a2gmeasurements.GimbalRS2.setPosControl","title":"<code>setPosControl(yaw, roll, pitch, ctrl_byte=1, time_for_action=20)</code>","text":"<p>Set the gimbal position by providing the yaw, roll and pitch.</p> <p>Parameters:</p> Name Type Description Default <code>yaw</code> <code>int</code> <p>yaw angle. Value should be between -1800 and 1800.</p> required <code>roll</code> <code>int</code> <p>roll angle. value should be betweeen -1800 and 1800. However, gimbal might stop if it reachs its maximum/minimum (this) axis value.</p> required <code>pitch</code> <code>int</code> <p>pitch angle. value should be betweeen -1800 and 1800. However, gimbal might stop if it reachs its maximum/minimum (this) axis value.</p> required <code>ctrl_byte</code> <code>hexadecimal</code> <p>Absolute or relative movement. For absolute use 0x01, while for relative use 0x00. Defaults to 0x01.</p> <code>1</code> <code>time_for_action</code> <code>hexadecimal</code> <p>Time it takes for the gimbal to move to desired position. Implicitly, this command controls the speed of gimbal. It is given in units of 0.1 s. For example: a value of 0x14 is 20, which means that the gimbal will take 2s (20*0.1) to reach its destination. Defaults to 0x14.</p> <code>20</code> <p>Returns:</p> Name Type Description <code>True</code> <code>bool</code> <p>always returns the same, unless there is a raising error.</p> Source code in <code>a2gmeasurements.py</code> <pre><code>def setPosControl(self, yaw, roll, pitch, ctrl_byte=0x01, time_for_action=0x14):\n    \"\"\"\n    Set the gimbal position by providing the yaw, roll and pitch.\n\n    Args:\n        yaw (int): yaw angle. Value should be between -1800 and 1800.\n        roll (int): roll angle. value should be betweeen -1800 and 1800. However, gimbal might stop if it reachs its maximum/minimum (this) axis value.\n        pitch (int): pitch angle. value should be betweeen -1800 and 1800. However, gimbal might stop if it reachs its maximum/minimum (this) axis value.\n        ctrl_byte (hexadecimal, optional): Absolute or relative movement. For absolute use 0x01, while for relative use 0x00. Defaults to 0x01.\n        time_for_action (hexadecimal, optional): Time it takes for the gimbal to move to desired position. Implicitly, this command controls the speed of gimbal. It is given in units of 0.1 s. For example: a value of 0x14 is 20, which means that the gimbal will take 2s (20*0.1) to reach its destination. Defaults to 0x14.\n\n    Returns:\n        True (bool): always returns the same, unless there is a raising error.\n    \"\"\"\n\n    # yaw, roll, pitch in 0.1 steps (-1800,1800)\n    # ctrl_byte always to 1\n    # time_for_action to define speed in 0.1sec\n    hex_data = struct.pack('&lt;3h2B', yaw, roll, pitch,\n                           ctrl_byte, time_for_action)\n\n    pack_data = ['{:02X}'.format(i) for i in hex_data]\n    cmd_data = ':'.join(pack_data)\n    # print(cmd_data)\n    cmd = self.assemble_can_msg(cmd_type='03', cmd_set='0E',\n                                cmd_id='00', data=cmd_data)\n\n    self.send_cmd(cmd)\n\n    # Save the current pitch and yaw values\n    if ctrl_byte == 0x00:\n        self.pitch = self.pitch + pitch\n        self.yaw = self.yaw + yaw\n    elif ctrl_byte == 0x01:\n        self.pitch = pitch\n        self.yaw = yaw\n\n    if self.pitch &gt; 1800 and self.pitch &lt;= 3600:\n        self.pitch = self.pitch - 3600 \n    elif self.pitch &lt; -1800 and self.pitch &gt;= -3600:\n        self.pitch = self.pitch + 3600\n\n    if self.yaw &gt; 1800 and self.yaw &lt;= 3600:\n        self.yaw = self.yaw - 3600\n    elif self.yaw &lt; -1800 and self.yaw &gt;= -3600:\n        self.yaw = self.yaw + 3600\n\n    return True    \n</code></pre>"},{"location":"GimbalRS2/#a2gmeasurements.GimbalRS2.setSpeedControl","title":"<code>setSpeedControl(yaw, roll, pitch, ctrl_byte=128)</code>","text":"<p>Sets speed for each axis of the gimbal.</p> <p>Always after seting the speed the gimbal roll is moved (strange behaviour). </p> <p>Developer has to send a setPosControl to set again the position of the gimbal where it was previously.</p> <p>Parameters:</p> Name Type Description Default <code>yaw</code> <code>int</code> <p>yaw speed in units of 0.1 deg/s.</p> required <code>roll</code> <code>int</code> <p>roll speed in units of 0.1 deg/s.</p> required <code>pitch</code> <code>int</code> <p>pitch speed in units of 0.1 deg/s.</p> required <code>ctrl_byte</code> <code>hexadecimal</code> <p>check DJI SDK manual. Defaults to 0x80.</p> <code>128</code> <p>Returns:</p> Name Type Description <code>True</code> <code>bool</code> <p>True if provided arguments are within acceptable range. False otherwise.</p> Source code in <code>a2gmeasurements.py</code> <pre><code>def setSpeedControl(self, yaw, roll, pitch, ctrl_byte=0x80):\n    \"\"\"\n    Sets speed for each axis of the gimbal.\n\n    Always after seting the speed the gimbal roll is moved (strange behaviour). \n\n    Developer has to send a setPosControl to set again the position of the gimbal where it was previously.\n\n    Args:\n        yaw (int): yaw speed in units of 0.1 deg/s.\n        roll (int): roll speed in units of 0.1 deg/s.\n        pitch (int): pitch speed in units of 0.1 deg/s.\n        ctrl_byte (hexadecimal, optional): check DJI SDK manual. Defaults to 0x80.\n\n    Returns:\n        True (bool): True if provided arguments are within acceptable range. False otherwise.\n    \"\"\"\n\n    if -3600 &lt;= yaw &lt;= 3600 and -3600 &lt;= roll &lt;= 3600 and -3600 &lt;= pitch &lt;= 3600:\n\n        hex_data = struct.pack('&lt;3hB', yaw, roll, pitch, ctrl_byte)\n        pack_data = ['{:02X}'.format(i) for i in hex_data]\n        cmd_data = ':'.join(pack_data)\n\n        cmd = self.assemble_can_msg(cmd_type='03', cmd_set='0E',\n                                    cmd_id='01', data=cmd_data)\n        # print('cmd---data {}'.format(cmd))\n        self.send_cmd(cmd)\n\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"GimbalRS2/#a2gmeasurements.GimbalRS2.start_thread_gimbal","title":"<code>start_thread_gimbal(bitrate=1000000)</code>","text":"<p>Starts the thread for listening the incoming data (if any) from the gimbal.</p> <p>Parameters:</p> Name Type Description Default <code>bitrate</code> <code>int</code> <p>Bitrate for the usb-to-can interface. This is a parameter inherited from can.Bus. Defaults to 1000000.</p> <code>1000000</code> Source code in <code>a2gmeasurements.py</code> <pre><code>def start_thread_gimbal(self, bitrate=1000000):\n    \"\"\"\n    Starts the thread for listening the incoming data (if any) from the gimbal.\n\n    Args:\n        bitrate (int, optional): Bitrate for the usb-to-can interface. This is a parameter inherited from can.Bus. Defaults to 1000000.\n    \"\"\"\n\n    try:\n        bus = can.interface.Bus(interface=\"pcan\", channel=\"PCAN_USBBUS1\", bitrate=bitrate)\n        self.actual_bus = bus\n    except Exception as e:\n        print(e)\n        self.GIMBAL_CONN_SUCCES = False\n        print(\"\\n[DEBUG]: Gimbal thread NOT started\")\n        return\n\n    self.event_stop_thread_gimbal = threading.Event()                              \n    t_receive = threading.Thread(target=self.receive, args=(self.actual_bus,self.event_stop_thread_gimbal))\n    t_receive.start()\n\n    self.GIMBAL_CONN_SUCCES = True\n    print(\"\\n[DEBUG]: Gimbal thread started\")\n</code></pre>"},{"location":"GimbalRS2/#a2gmeasurements.GimbalRS2.stop_thread_gimbal","title":"<code>stop_thread_gimbal()</code>","text":"<p>Stops the gimbal thread by setting the threading. Event attribute created in <code>start_thread_gimbal</code>.</p> Source code in <code>a2gmeasurements.py</code> <pre><code>def stop_thread_gimbal(self):\n    \"\"\"\n    Stops the gimbal thread by setting the threading. Event attribute created in ``start_thread_gimbal``.\n    \"\"\"        \n    self.event_stop_thread_gimbal.set()        \n</code></pre>"},{"location":"GimbalRS2/#a2gmeasurements.GimbalRS2.validate_api_call","title":"<code>validate_api_call(data_frame)</code>","text":"<p>CRC error check.</p> <p>Parameters:</p> Name Type Description Default <code>data_frame</code> <code>list</code> <p>DJI RS2 frame message</p> required <p>Returns:</p> Name Type Description <code>validated</code> <code>bool</code> <p>passed or not the crc check</p> Source code in <code>a2gmeasurements.py</code> <pre><code>def validate_api_call(self, data_frame):\n    \"\"\"\n    CRC error check.\n\n    Args:\n        data_frame (list): DJI RS2 frame message\n\n    Returns:\n        validated (bool): passed or not the crc check\n    \"\"\"\n\n    validated = False\n    check_sum = ':'.join(data_frame[-4:])\n    data = ':'.join(data_frame[:-4])\n    # # print(len(hex_data))\n    # # print(data)\n    if len(data_frame) &gt;= 8:\n        crc_obj = Checksum()\n        if check_sum == crc_obj.calc_crc32(data):\n            #         # print(\"Approved Message: \" + str(hex_data))\n            header = ':'.join(data_frame[:10])\n            header_check_sum = ':'.join(data_frame[10:12])\n            if header_check_sum == crc_obj.calc_crc16(header):\n                validated = True\n    return validated\n</code></pre>"},{"location":"GpsSignaling/","title":"GpsSignaling module","text":"<p>             Bases: <code>object</code></p> <p>Python class that works as \"software\" driver for the Septentrios GPS receiver (Mosaic-go). </p> <p>It implements the commands described in Septentrios \"mosaic-go Reference Guide\".</p> <p>There are commands (sent to the GPS receiver) that control (mainly) what type of information (in the form of what is called in Septentrio's documentation, NMEA or SBF sentences) is retrieved from the receiver. </p> <p>It creates a thread (called here a gps thread) to handle the communication between the receiver and this host computer.</p> <p>The reference coordinate system used by the Septentrio gps is defined as followed:</p> <ol> <li> <p>The (positive) x-axis is the longitudinal axis. This is the axis pointing in the direction of movement of the node.</p> </li> <li> <p>The (positive) y-axis is 90 degrees to the right (clockwise) of the (positive) x-axis.</p> </li> </ol> Source code in <code>a2gmeasurements.py</code> <pre><code>class GpsSignaling(object):\n    \"\"\"\n    Python class that works as \"software\" driver for the Septentrios GPS receiver (Mosaic-go). \n\n    It implements the commands described in Septentrios \"mosaic-go Reference Guide\".\n\n    There are commands (sent to the GPS receiver) that control (mainly) what type of information (in the form of what is called in Septentrio's documentation, NMEA or SBF sentences) is retrieved from the receiver. \n\n    It creates a thread (called here a gps thread) to handle the communication between the receiver and this host computer.\n\n    The reference coordinate system used by the Septentrio gps is defined as followed:\n\n     1. The (positive) x-axis is the **longitudinal** axis. This is the axis pointing in the direction of movement of the node.\n\n     2. The (positive) y-axis is 90 degrees to the right (clockwise) of the (positive) x-axis.\n\n    \"\"\"\n\n    def __init__(self, DBG_LVL_1=False, DBG_LVL_2=False, DBG_LVL_0=False, save_filename='GPS'):\n        \"\"\"\n        Contructor for the GpsSignaling class. Important attributes are:\n\n        * ``register_sbf_sentences_by_id``: list of integers containing the expected SBF sentences that are going to be requested at the receiver. The integer is the ID of the sentence described in Septentrio's manual.\n\n        * ``SBF_frame_buffer``: list of dictionaries containing the SBF frames during the execution of the thread responsible for receiving SBF frames.\n\n        * ``MAX_SBF_BUFF_LEN``: Maximum number of entries in the SBF frame buffer before saving, cleaning and starting again\n\n        Args:\n            DBG_LVL_1 (bool, optional): used to print less verbose than level 0. Defaults to False.\n            DBG_LVL_2 (bool, optional): used to print less verbose than level 2. Defaults to False.\n            DBG_LVL_0 (bool, optional): prints all the verbose available. Defaults to False.\n            save_filename (str, optional): name of the file where to save the record of GPS coordinates along an experiment. Defaults to 'GPS'.\n        \"\"\"\n\n        # Initializations\n        datestr = datetime.datetime.now()\n        datestr = datestr.strftime('%Y-%m-%d-%H-%M-%S-%f')\n        self.save_filename = save_filename + '-' + datestr\n        self.SBF_frame_buffer = []\n        self.NMEA_buffer = []\n        self.stream_info = []\n        self.MAX_SBF_BUFF_LEN = 100\n\n        self.DBG_LVL_1 = DBG_LVL_1\n        self.DBG_LVL_2 = DBG_LVL_2\n        self.DBG_LVL_0 = DBG_LVL_0\n\n        # Expected SBF sentences to be requested. Add or remove according to planned\n        # SBF sentences to be requested.\n        self.register_sbf_sentences_by_id = [4006, 5938] # PVTCart, AttEul\n        self.n_sbf_sentences = len(self.register_sbf_sentences_by_id)\n\n        self.ERR_GPS_CODE_GENERAL = -1.5e3\n        self.ERR_GPS_CODE_SMALL_BUFF_SZ = -2.5e3       \n        self.ERR_GPS_CODE_BUFF_NULL = -3.5e3\n        self.ERR_GPS_CODE_NO_COORD_AVAIL = -4.5e3 \n        self.ERR_GPS_CODE_NO_HEAD_AVAIL = -5.5e3\n\n    def serial_connect(self, serial_port=None):\n        \"\"\"\n        Open a serial connection. The Septentrio mosaic-go provides 2 virtual serial ports.\n\n        In Windows the name of the virtual serial ports are typically: COM# (Virtual serial port 1), COM# (Virtual serial port 2).\n\n        In Linux the name of the virtual serial ports (controlled by the standard Linux CDC-ACM driver) are: ``/dev/ttyACM0`` (Virtual serial port 1), ``/dev/ttyACM1`` (Virtual serial port 2).\n\n        Septentrio has different interfaces to use with its receiver. Among other interfaces are: IP (using Ethernet-over-USB), USB.\n\n        For the virtual serial ports the interface name in Septentrio receiver is 'USB' as their\n        communication is made through the USB connection with the host computer. \n\n        Additionally there is an actual (not virtual) serial port in the mosaic-go device. Under Linux, the name of this port is ``/dev/serial0`` which is the symbolic link to either ``dev/ttyS#`` or ``/dev/ttyAMA#``.\n\n        For information about all available interfaces check the Septentrio \"mosaic-go Reference Guide\".\n\n        *It is important to note that only the USB interface has been implemented in this class*.\n\n        Args:\n            serial_port (str, optional): serial port or virtual serial port name. Defaults to None.\n        \"\"\"\n\n        self.serial_port = None\n        # Look for the first Virtual Com in Septentrio receiver. It is assumed that it is available, \n        # meaning that it has been closed by user if was used before.        \n        for (this_port, desc, _) in sorted(comports()):\n\n            # Linux CDC-ACM driver\n            if 'Septentrio USB Device - CDC Abstract Control Model (ACM)' in desc:\n                    #self.serial_port = '/dev/ttyACM0'\n                    self.serial_port = this_port\n                    self.interface_number = 2\n            # Windows driver\n            elif 'Septentrio Virtual USB COM Port 1' in desc: # Choose the first virtual COM port\n                    self.serial_port = this_port\n                    self.interface_number = 1\n\n        if self.serial_port is None:\n            self.GPS_CONN_SUCCESS = False\n            print(\"\\n[DEBUG]: NO GPS found in any serial port\")\n            return\n        else:\n            self.GPS_CONN_SUCCESS = True\n            print(\"\\n[DEBUG]: GPS found in one serial port\")\n\n        serial_instance = None\n        while serial_instance is None:\n            try:\n                serial_instance = serial.serial_for_url(self.serial_port,\n                                                        9600,\n                                                        parity='N',\n                                                        rtscts=False,\n                                                        xonxoff=False,\n                                                        do_not_open=True)\n\n                serial_instance.timeout = 5\n\n                serial_instance.exclusive = True\n                serial_instance.open()\n\n            except serial.SerialException as e:\n                sys.stderr.write('could not open port {!r}: {}\\n'.format(self.serial_port, e))\n\n            else:\n                break\n\n        #if self.DBG_LVL_0:\n        print('[DEBUG]:CONNECTED TO VIRTUAL SERIAL PORT IN SEPTENTRIO')\n\n        self.serial_instance = serial_instance\n        time.sleep(0.1)\n\n    def process_gps_nmea_data(self, data):\n        \"\"\"\n        Parses a line of NMEA data retrieved from the gps and coming from the virtual serial port.\n\n        Used NMEA sentences are GGA and HDT.\n\n        The labels of the items of the returned dictionary are the following ones for the GGA sentence: ``Timestamp``, ``Latitude``, ``Longitude``, ``Latitude Direction``, ``Longitude``, ``Longitude Direction``, ``GPS Quality Indicator``, ``Number of Satellites in use``, ``Horizontal Dilution of Precision``, ``Antenna Alt above sea level (mean)``, ``Units of altitude (meters)``, ``Geoidal Separation``, ``Units of Geoidal Separation (meters)``, ``Age of Differential GPS Data (secs)``, ``Differential Reference Station ID``.\n\n        *The instances of this class created in the GUI and other classes, use SBF sentences as the default type of sentence*.\n\n        Args:\n            data (str): line of read data following the structure of a NMEA frame.\n        \"\"\"\n\n        try:\n            if self.DBG_LVL_0:\n                print('\\nNMEA PARSING')\n\n            nmeaobj = pynmea2.parse(data.decode())\n            extracted_data = ['%s: %s' % (nmeaobj.fields[i][0], nmeaobj.data[i]) for i in range(len(nmeaobj.fields))]\n            gps_data = {}\n            for item in extracted_data:\n                tmp = item.split(': ')\n                gps_data[tmp[0]] = tmp[1]\n\n            # GGA type of NMEA sentence\n            if 'Antenna Alt above sea level (mean)' in gps_data:\n                if int(gps_data['Latitude'][0]) != 0:\n                    gps_data['Latitude'] = float(gps_data['Latitude'][0:2]) + float(gps_data['Latitude'][2:])/60\n                else:\n                    gps_data['Latitude'] = float(gps_data['Latitude'][0:3]) + float(gps_data['Latitude'][3:])/60\n\n                if int(gps_data['Longitude'][0]) != 0:\n                    gps_data['Longitude'] = float(gps_data['Longitude'][0:2]) + float(gps_data['Longitude'][2:])/60\n                else:\n                    gps_data['Longitude'] = float(gps_data['Longitude'][0:3]) + float(gps_data['Longitude'][3:])/60\n\n                gps_data['Antenna Alt above sea level (mean)'] = float(gps_data['Antenna Alt above sea level (mean)'])\n                gps_data['Timestamp'] = float(gps_data['Timestamp'])\n\n                '''\n                # Save the UNIX timestamp. As the timestamp provides hour/min/sec only, add the date\n                today_date = datetime.date.today()\n                today_date = [int(i) for i in today_date.strftime(\"%Y-%m-%d\").split('-')]                \n\n                complete_date = datetime.datetime(year=today_date[0], \n                                                month=today_date[1], \n                                                day=today_date[2], \n                                                hour=int(gps_data['Timestamp'][0:2]), \n                                                minute=int(gps_data['Timestamp'][2:4]), \n                                                second=int(gps_data['Timestamp'][4:6]))\n\n                gps_data['Timestamp'] = time.mktime(complete_date.timetuple())\n\n                '''\n\n            # HDT NMEA sentence\n            if 'Heading' in gps_data:\n                if gps_data['Heading'] == '':\n                    gps_data['Heading'] = -2000\n                else:\n                    gps_data['Heading'] = float(gps_data['Heading'])\n\n                # No need to restrict heading to [-pi, pi] since it will be done \n                # inside 'ground_gimbal_follows_drone' function \n                #if gps_data['Heading'] &gt; 180:\n                #    gps_data['Heading'] = gps_data['Heading'] - 360\n\n                # Make the timestamp the same format as the GGA sentence\n                for stream in self.stream_info:\n                    if stream['msg_type'] == 'NMEA':\n                        # Need to update faster\n                        if 'msec' in stream['interval']:\n                            1\n                        #elif 'sec' in stream['interval']:                            \n                        else:\n                            gps_data['Timestamp'] = ''\n                            for i in datetime.datetime.utcnow().timetuple()[3:6]:\n                                tmp = str(i)\n                                if len(tmp) == 1:\n                                    tmp = '0' + tmp\n                                gps_data['Timestamp'] = gps_data['Timestamp'] + tmp\n                            gps_data['Timestamp'] = float(int(gps_data['Timestamp']))\n\n            if self.DBG_LVL_2 or len(self.NMEA_buffer):\n                if self.DBG_LVL_0:\n                    print('\\nSAVES NMEA DATA INTO BUFFER')    \n                self.NMEA_buffer.append(gps_data)  \n\n        except Exception as e:\n            # Do not save any other comand line\n            if self.DBG_LVL_1:\n                print('\\nEXCEPTION PROCESSING NMEA')\n            if self.DBG_LVL_0:\n                print('\\nThis is the exception: ', e) \n\n    def process_pvtcart_sbf_data(self, raw_data):\n        \"\"\"\n        Parses an PVTCart SBF sentence. To be able to receive this block, the receiver should be configured to output SBF sentences.\n\n        The PVTCart SBF sentence provides geocentric coordinates X, Y, Z for the position of the receiver.\n\n        The coordinates are stored in ``SBF_frame_buffer``. Each ``MAX_SBF_BUFF_LEN`` entries of ``SBF_frame_buffer``, the buffer is flushed and its contents are saved on disk.\n\n        *More about the information carried by this block in \"mosaic-go Reference Guide\"*.\n\n        Args:\n            raw_data (bytes): received data corresponding to the PVTCart SBF block.\n        \"\"\"\n\n        format_before_padd = '&lt;1c3H1I1H2B3d5f1d1f4B2H1I2B4H1B' \n        format_after_padd = format_before_padd + str(sys.getsizeof(raw_data)-struct.calcsize(format_before_padd)) + 'B'\n\n        TOW = struct.unpack('&lt;1I', raw_data[7:11])[0]\n        WNc = struct.unpack('&lt;1H', raw_data[11:13])[0]        \n        MODE =  struct.unpack('&lt;1B', raw_data[13:14])[0]\n        ERR =  struct.unpack('&lt;1B', raw_data[14:15])[0]\n        X =  struct.unpack('&lt;1d', raw_data[15:23])[0]\n        Y =  struct.unpack('&lt;1d', raw_data[23:31])[0]\n        try:\n            Z = struct.unpack('&lt;1d', raw_data[31:39])[0]\n        except Exception as e:\n            if self.DBG_LVL_0:\n                print(\"[DEBUG]: error unpacking Z coord, \", e)\n        Undulation =  struct.unpack('&lt;1f', raw_data[39:43])[0]\n        Vx =  struct.unpack('&lt;1f', raw_data[43:47])[0]\n        Vy = struct.unpack('&lt;1f', raw_data[47:51])[0]\n        Vz =  struct.unpack('&lt;1f', raw_data[51:55])[0]\n        COG =  struct.unpack('&lt;1f', raw_data[55:59])[0]\n        RxClkBias = struct.unpack('&lt;1d', raw_data[59:67])[0]\n        RxClkDrift =  struct.unpack('&lt;1f', raw_data[67:71])[0]\n        TimeSystem = struct.unpack('&lt;1B', raw_data[71:72])[0]\n        Datum =  struct.unpack('&lt;1B', raw_data[72:73])[0]\n        NrSV = struct.unpack('&lt;1B', raw_data[73:74])[0]\n        WACorrInfo =  struct.unpack('&lt;1B', raw_data[74:75])[0]\n        ReferenceID =  struct.unpack('&lt;1H', raw_data[75:77])[0]\n        MeanCorrAge = struct.unpack('&lt;1H', raw_data[77:79])[0]\n        SignalInfo =  struct.unpack('&lt;1I', raw_data[79:83])[0] \n        AlertFlag = struct.unpack('&lt;1B', raw_data[83:84])[0]\n        NrBases =  struct.unpack('&lt;1B', raw_data[84:85])[0]\n        PPPInfo =  struct.unpack('&lt;1H', raw_data[85:87])[0]\n        Latency =  struct.unpack('&lt;1H', raw_data[87:89])[0]        \n        HAccuracy =  struct.unpack('&lt;1H', raw_data[89:91])[0]         \n        VAccuracy =  struct.unpack('&lt;1H', raw_data[91:93])[0]  \n\n        '''\n        pvt_msg_format = {'TOW': TOW, 'WNc': WNc, 'MODE': MODE, 'ERR': ERR, 'X': X, 'Y': Y, 'Z': Z,\n                          'Undulation': Undulation, 'Vx': Vx, 'Vy': Vy, 'Vz': Vz, 'COG': COG,\n                          'RxClkBias': RxClkBias, 'RxClkDrift': RxClkDrift, 'TimeSystem': TimeSystem, 'Datum': Datum,\n                          'NrSV': NrSV, 'WACorrInfo': WACorrInfo, 'ReferenceID': ReferenceID, 'MeanCorrAge': MeanCorrAge,\n                          'SignalInfo': SignalInfo, 'AlertFlag': AlertFlag, 'NrBases': NrBases, 'PPPInfo': PPPInfo,\n                          'Latency': Latency, 'HAccuracy': HAccuracy, 'VAccuracy': VAccuracy}        \n        '''\n        pvt_data_we_care = {'ID': 'Coordinates', 'TOW': TOW, 'WNc': WNc, 'MODE': MODE, 'ERR': ERR, \n                            'X': X, 'Y': Y, 'Z': Z, 'Datum': Datum}\n\n        self.SBF_frame_buffer.append(pvt_data_we_care)\n\n        if len(self.SBF_frame_buffer) &gt; self.MAX_SBF_BUFF_LEN:\n            with open(self.save_filename + '.txt', 'a+') as file:      \n                file.write(json.dumps(self.SBF_frame_buffer))       \n                print(\"[DEBUG]: Saved GPS cooridnates file\")     \n            self.SBF_frame_buffer = []\n\n    def process_pvtgeodetic_sbf_data(self, raw_data):\n        \"\"\"\n        Parses an PVTGeodetic SBF sentence. To be able to receive this block, the receiver should be configured to output SBF sentences.\n\n        The PVTGeodetic SBF sentence provides geodetic coordinates lat, lon, h for the position of the receiver.\n\n        The coordinates are stored in ``SBF_frame_buffer``. Each ``MAX_SBF_BUFF_LEN`` entries of ``SBF_frame_buffer``, the buffer is flushed and its contents are saved on disk.\n\n        *More about the information carried by this block in \"mosaic-go Reference Guide\"*.\n\n        Args:\n            raw_data (bytes): received data corresponding to the PVTGeodetic SBF block.\n        \"\"\"\n\n        TOW = struct.unpack('&lt;1I', raw_data[7:11])[0]\n        WNc = struct.unpack('&lt;1H', raw_data[11:13])[0]        \n        MODE =  struct.unpack('&lt;1B', raw_data[13:14])[0]\n        ERR =  struct.unpack('&lt;1B', raw_data[14:15])[0]\n        LAT =  struct.unpack('&lt;1d', raw_data[15:23])[0]\n        LON =  struct.unpack('&lt;1d', raw_data[23:31])[0]\n        H = struct.unpack('&lt;1d', raw_data[31:39])[0]\n        Undulation =  struct.unpack('&lt;1f', raw_data[39:43])[0]\n        Vx =  struct.unpack('&lt;1f', raw_data[43:47])[0]\n        Vy = struct.unpack('&lt;1f', raw_data[47:51])[0]\n        Vz =  struct.unpack('&lt;1f', raw_data[51:55])[0]\n        COG =  struct.unpack('&lt;1f', raw_data[55:59])[0]\n        RxClkBias = struct.unpack('&lt;1d', raw_data[59:67])[0]\n        RxClkDrift =  struct.unpack('&lt;1f', raw_data[67:71])[0]\n        TimeSystem = struct.unpack('&lt;1B', raw_data[71:72])[0]\n        Datum =  struct.unpack('&lt;1B', raw_data[72:73])[0]        \n\n        pvt_data_we_care = {'ID': 'Coordinates', 'TOW': TOW, 'WNc': WNc, 'MODE': MODE, 'ERR': ERR, \n                            'LAT': LAT, 'LON': LON, 'HEIGHT': H, 'Datum': Datum}\n\n        self.SBF_frame_buffer.append(pvt_data_we_care)\n\n        if len(self.SBF_frame_buffer) &gt; self.MAX_SBF_BUFF_LEN:\n            with open(self.save_filename + '.txt', 'a+') as file:      \n                file.write(json.dumps(self.SBF_frame_buffer))      \n                print(\"[DEBUG]: Saved GPS cooridnates file\")           \n            self.SBF_frame_buffer = []\n\n    def process_atteuler_sbf_data(self, raw_data):\n        \"\"\"\n        Parses an AttEuler SBF sentence. To be able to receive this block, the receiver should be configured to output SBF sentences.\n\n        The AttEuler SBF sentence provides heading information of the imaginary line formed by the first and second antennas, w.r.t the North. To do so, the heading, pitch, and roll axis are defined.\n\n        The coordinates are stored in ``SBF_frame_buffer``. Each ``MAX_SBF_BUFF_LEN`` entries of ``SBF_frame_buffer``, the buffer is flushed and its contents are saved on disk.\n\n        *More about all axis definition, and heading information in \"mosaic-go Reference Guide\"*.\n\n        Args:\n            raw_data (bytes): received data corresponding to the AttEurler SBF sentence.\n        \"\"\"\n\n        TOW = struct.unpack('&lt;1I', raw_data[7:11])[0]\n        WNc = struct.unpack('&lt;1H', raw_data[11:13])[0]        \n        NrSV = struct.unpack('&lt;1B', raw_data[13:14])[0]\n        ERR =  struct.unpack('&lt;1B', raw_data[14:15])[0]\n        MODE =  struct.unpack('&lt;1H', raw_data[15:17])[0]\n        Heading =  struct.unpack('&lt;1f', raw_data[19:23])[0]\n        try:\n            Pitch =  struct.unpack('&lt;1f', raw_data[23:27])[0]\n        except Exception as e:\n            print(\"[DEBUG]: Error unpacking Pitch attitude, \", e)\n        Roll = struct.unpack('&lt;1f', raw_data[27:31])[0]\n        PitchDot =  struct.unpack('&lt;1f', raw_data[31:35])[0]\n        RollDot =  struct.unpack('&lt;1f', raw_data[35:39])[0]\n        HeadingDot = struct.unpack('&lt;1f', raw_data[39:43])[0]\n\n        '''\n        atteul_msg_format = {'TOW': TOW, 'WNc': WNc, 'NrSV': NrSV, 'ERR': ERR, 'MODE': MODE, \n                             'Heading': Heading, 'Pitch': Pitch, 'Roll': Roll, \n                             'PitchDot': PitchDot, 'RollDot': RollDot, 'HeadingDot': HeadingDot}        \n        '''\n        atteul_msg_useful = {'ID': 'Heading', 'TOW': TOW, 'WNc': WNc,'ERR': ERR, 'MODE': MODE, \n                             'Heading': Heading, 'Pitch': Pitch, 'Roll': Roll}\n\n        self.SBF_frame_buffer.append(atteul_msg_useful)\n\n        if len(self.SBF_frame_buffer) &gt; self.MAX_SBF_BUFF_LEN:\n            with open(self.save_filename + '.txt', 'a+') as file:      \n                file.write(json.dumps(self.SBF_frame_buffer))    \n                print(\"[DEBUG]: Saved GPS cooridnates file\")             \n            self.SBF_frame_buffer = []\n\n    def parse_septentrio_msg(self, rx_msg):\n        \"\"\"\n        Parses the received message and process it depending if it is an SBF or NMEA message\n\n        Raises an exception if *any* problem is encountered when parsing the message.\n\n        Args:\n            rx_msg (bytes or str): received msg from Ronin RS2 gimbal.\n        \"\"\"\n\n        try:\n            if self.DBG_LVL_1:\n                print('\\nPARSING RX DATA')\n            if self.DBG_LVL_0:\n                print('0 POS: ', rx_msg[0])\n                print('\\nRX DATA LENGTH: ', len(rx_msg), rx_msg.decode('utf-8', 'ignore'))\n\n            # The SBF output follows the $ sync1 byte, with a second sync byte that is the symbol @ or in utf-8 the decimal 64\n            # Bytes indexing  works as follows:\n            # One integer gives a decimal\n            # A slice (i.e. 0:1) gives a bytes object ---&gt; rx_msg[0] != rx_msg[0:1]\n            if rx_msg[0] == 64:                \n                if self.DBG_LVL_0:\n                    print('\\nDETECTS SBF')\n\n                # Header detection\n                #SYNC = struct.unpack('&lt;1c', rx_msg[0:1]) \n                CRC = struct.unpack('&lt;1H', rx_msg[1:3])                \n                ID_SBF_msg = struct.unpack('&lt;1H', rx_msg[3:5])\n                LEN_SBF_msg = struct.unpack('&lt;1H', rx_msg[5:7])\n\n                # According to the manual, the LEN should always be a multiple of 4, otherwise \n                # there is an error\n                if np.mod(int(LEN_SBF_msg[0]),4) != 0 :\n                    if self.DBG_LVL_1:\n                        print('\\nDiscarded frame as LEN_SBF_msg is not multiple of 4, LEN_SBF_msg: ', LEN_SBF_msg[0])\n                    return\n\n                '''\n                # CRC checker\n                crc16_checker = Calculator(Crc16.CCITT)\n                idx_bytes_crc_to_read = 7+int(LEN_SBF_msg[0])-8\n                crc_data = rx_msg[7:idx_bytes_crc_to_read]\n                print(type(crc_data))\n                crc16 = crc16_checker.checksum(crc_data)\n                print(rx_msg[1:3], type(crc16))\n                if CRC[0] != crc16:\n                    if self.DBG_LVL_1:\n                        print('\\nDiscarded frame cause it did not pass the CRC check')\n                    return\n                '''\n\n                # PVTGeodetic SBF sentenced identified by ID 4007\n                if ID_SBF_msg[0] &amp; 8191 == 4007: # np.sum([np.power(2,i) for i in range(13)]) # ---&gt;  bits 0-12 contain the ID                    \n                    self.process_pvtgeodetic_sbf_data(rx_msg)\n                    #print(\"Received pvt geodetic\")\n\n                # PVTCart SBF sentence identified by ID 4006\n                if ID_SBF_msg[0] &amp; 8191 == 4006: # np.sum([np.power(2,i) for i in range(13)]) # ---&gt;  bits 0-12 contain the ID                    \n                    self.process_pvtcart_sbf_data(rx_msg)\n                    #print(\"Received pvtcart\")\n\n                # PosCovCartesian SBF sentence identified by ID 5905\n                if ID_SBF_msg[0] &amp; 8191 == 5905: # np.sum([np.power(2,i) for i in range(13)]) # ---&gt;  bits 0-12 contain the ID\n                    if self.DBG_LVL_1:\n                        print('\\nReceived PosCovCartesian SBF sentence')\n\n                if ID_SBF_msg[0] &amp; 8191 == 5907: # np.sum([np.power(2,i) for i in range(13)]) # ---&gt;  bits 0-12 contain the ID\n                    if self.DBG_LVL_1:\n                        print('\\nReceived VelCovCartesian SBF sentence')\n\n                if ID_SBF_msg[0] &amp; 8191 == 4043: # np.sum([np.power(2,i) for i in range(13)]) # ---&gt;  bits 0-12 contain the ID\n                    if self.DBG_LVL_1:\n                        print('\\nReceived BaseVectorCart SBF sentence')\n\n                if ID_SBF_msg[0] &amp; 8191 == 5942: # np.sum([np.power(2,i) for i in range(13)]) # ---&gt;  bits 0-12 contain the ID\n                    if self.DBG_LVL_1:\n                        print('\\nReceived AuxAntPositions SBF sentence')\n\n                if ID_SBF_msg[0] &amp; 8191 == 5938: # np.sum([np.power(2,i) for i in range(13)]) # ---&gt;  bits 0-12 contain the ID\n                    if self.DBG_LVL_1:\n                        1\n                        #print('\\nReceived AttEuler SBF sentence')\n                    print(\"Received attitude\")\n                    self.process_atteuler_sbf_data(rx_msg)\n\n                if ID_SBF_msg[0] &amp; 8191 == 5939: # np.sum([np.power(2,i) for i in range(13)]) # ---&gt;  bits 0-12 contain the ID\n                    if self.DBG_LVL_1:\n                        print('\\nReceived AttCovEuler SBF sentence')\n\n                if ID_SBF_msg[0] &amp; 8191 == 5943: # np.sum([np.power(2,i) for i in range(13)]) # ---&gt;  bits 0-12 contain the ID\n                    if self.DBG_LVL_1:\n                        print('\\nReceived EndOfAtt SBF sentence')\n\n                # Sort SBF buffer entries by time (this is double checking, as they are expected to arrive in time order)\n                self.SBF_frame_buffer.sort(key=lambda k : k['TOW'])\n\n                # Merge buffer entries corresponding to the same TOW\n                #self.util_merge_buffer_entries_by_timetag(type_msg='SBF')\n\n            # NMEA Output starts with the letter G, that in utf-8 is the decimal 71\n            elif rx_msg[0] == 71:\n                if self.DBG_LVL_0:\n                    print('\\nDETECTS NMEA')\n                self.process_gps_nmea_data(rx_msg[:-1])\n                #self.util_merge_buffer_entries_by_timetag(type_msg='NMEA')\n\n        except Exception as e:\n            if self.DBG_LVL_1:\n                print('\\nEXCEPTION IN parse_septentrio_msg')\n            if self.DBG_LVL_0:\n                print('\\nThis is the exception: ', e, )\n                logging.exception(\"\\nError occurred: \")\n\n    def get_last_sbf_buffer_info(self, what='Coordinates'):\n        \"\"\"\n        Retrieves the last gps coordinates, the last heading information of the receiver, or both things.\n\n        Args:\n            what (str, optional): defines which information wants to be retrieved from ``SBF_frame_buffer``. Options are: 'Coordinates', 'Heading' or 'Both'. Defaults to 'Coordinates'.\n\n        Returns:\n            data_to_return (dict): ``X``, ``Y`` and ``Z`` coordinates in absence of any error. Otherwise, the error code.\n            data_to_return_2 (dict, optional): ``Heading`` angle in [0, 360] degrees.\n        \"\"\"\n\n        # Coordinates\n        data_to_return = []       \n\n        # Heading\n        data_to_return_2 = []     \n\n        len_sbf_buffer = len(self.SBF_frame_buffer)\n\n        cnt = 1\n        if  len_sbf_buffer &gt; 0:\n            if what == 'Coordinates' or what == 'Heading':\n                while(len(data_to_return) == 0):\n                    if cnt &gt; len_sbf_buffer:\n                        print('\\n[WARNING]: Either heading or coordinates information not available')\n\n                        if what == 'Coordinates':\n                            print('\\n[WARNING]: Return ERR_GPS_CODE_NO_COORD_AVAIL for each coordinate in data_to_return')\n                            data_to_return = {'X': self.ERR_GPS_CODE_NO_COORD_AVAIL, 'Y': self.ERR_GPS_CODE_NO_COORD_AVAIL, 'Z': self.ERR_GPS_CODE_NO_COORD_AVAIL}\n                            return data_to_return\n\n                        elif what == 'Heading':\n                            print('\\n[WARNING]: Return ERR_GPS_CODE_NO_HEAD_AVAIL for heading in data_to_return')\n                            data_to_return = {'Heading': self.ERR_GPS_CODE_NO_HEAD_AVAIL}\n                            return data_to_return\n\n                    dict_i = self.SBF_frame_buffer[-cnt]\n                    if dict_i['ID'] == what:\n                        # Both AttEuler and PVTCart return 'Error' field equal to 0, when there is no error\n                        if dict_i['ERR'] == 0:\n                            data_to_return = dict_i\n\n                    cnt = cnt + 1             \n\n                if self.DBG_LVL_1:\n                    print('\\n[DEBUG_1]: retrieved a ' + what + ' response') \n\n                return data_to_return\n\n            elif what == 'Both':\n                while((len(data_to_return) == 0) or (len(data_to_return_2) == 0)):     \n                    if cnt &gt; len_sbf_buffer:\n                        print('\\n[WARNING]: heading stream not on or not heading info available /or/ coordinates stream not on or no coordinates available')\n                        print('\\n[WARNING]: Return ERR_GPS_CODE_SMALL_BUFF_SZ for each coordinate in data_to_return')\n                        print('\\n[WARNING]: Return ERR_GPS_CODE_SMALL_BUFF_SZ for heading in data_to_return_2')\n\n                        data_to_return = {'X': self.ERR_GPS_CODE_SMALL_BUFF_SZ, 'Y': self.ERR_GPS_CODE_SMALL_BUFF_SZ, 'Z': self.ERR_GPS_CODE_SMALL_BUFF_SZ}\n                        data_to_return_2 = {'Heading': self.ERR_GPS_CODE_SMALL_BUFF_SZ}\n\n                        return data_to_return, data_to_return_2\n\n                    dict_i = self.SBF_frame_buffer[-cnt]\n\n                    if dict_i['ID'] == 'Heading':\n                        # Both AttEuler and PVTCart return 'Error' field equal to 0, when there is no error\n                        if dict_i['ERR'] == 0:\n                            data_to_return_2 = dict_i                           \n\n                    elif dict_i['ID'] == 'Coordinates':\n                        # Both AttEuler and PVTCart return 'Error' field equal to 0, when there is no error\n                        if dict_i['ERR'] == 0:                            \n                            data_to_return = dict_i\n\n                    cnt = cnt + 1\n\n                if self.DBG_LVL_1:\n                    print('\\n[DEBUG_1]: retrieved a Heading and Coordinates response') \n\n                return data_to_return, data_to_return_2\n        else:\n            print('\\n[WARNING]: nothing in SBF buffer')\n            if what == 'Coordinates':\n                data_to_return = {'X': self.ERR_GPS_CODE_BUFF_NULL, 'Y': self.ERR_GPS_CODE_BUFF_NULL, 'Z': self.ERR_GPS_CODE_BUFF_NULL}\n                print('\\n[ERROR]: Return ERR_GPS_CODE_BUFF_NULL for each coordinate in data_to_return')\n                return data_to_return\n\n            elif what == 'Heading':\n                data_to_return = {'Heading': self.ERR_GPS_CODE_BUFF_NULL}\n                print('\\n[ERROR]: Return ERR_GPS_CODE_BUFF_NULL for each heading in in data_to_return')\n                return data_to_return\n\n            elif what == 'Both':\n                data_to_return = {'X': self.ERR_GPS_CODE_BUFF_NULL, 'Y': self.ERR_GPS_CODE_BUFF_NULL, 'Z': self.ERR_GPS_CODE_BUFF_NULL}\n                data_to_return_2 = {'Heading': self.ERR_GPS_CODE_BUFF_NULL}\n                print('\\n[ERROR]: Return ERR_GPS_CODE_BUFF_NULL for each coordinate in data_to_return and for heading in data_to_return_2')\n                return data_to_return, data_to_return_2    \n\n    def check_coord_closeness(self, coordinates2compare, tol=5):\n        \"\"\"\n        Checks how close is a coordinate with respect to the actual node position.\n\n        It is assumed that both pair of coordinates to be compared lay at the same height.\n\n        Args:\n            coordinates2compare (dict): keys of the dictionary are 'LAT' and 'LON', and each of them has ONLY ONE value.\n            tol (int, optional): margin in meters by which the coordinates in comparison are close or not. Defaults to 5.\n\n        Returns:\n            True (bool): True if close , False otherwise.\n        \"\"\"\n\n        coords, head_info = self.get_last_sbf_buffer_info(what='Both')\n\n        if coords['X'] == self.ERR_GPS_CODE_BUFF_NULL or self.ERR_GPS_CODE_SMALL_BUFF_SZ:\n            return None\n        else:\n            lat_node, lon_node, height_node = geocentric2geodetic(coords['X'], coords['Y'], coords['Z'])\n            wgs84_geod = Geod(ellps='WGS84')\n\n            _,_, dist = wgs84_geod.inv(lon_node, lat_node, coordinates2compare['LON'], coordinates2compare['LAT'])\n\n            if dist &lt; tol:\n                return True\n            else:\n                return False\n\n    def serial_receive(self, serial_instance_actual, stop_event):\n        \"\"\"\n        Callback function invoked by the thread responsible for handling I/O communication between the host computer and the Septentrio mosaic-go receiver.\n\n        Most of all messages sent by Septentrio mosaic-go receiver start with an \"$\" character.\n\n        The next character depends if the message is an echo of a command sent by the host computer, or if the message is an answer to a command sent by the host computer.\n\n        Echoes of commands sent by the host computer, don't follow the ``$`` character with any predefined character. This messages are discarded by the method ``parse_septentrio_msg``.\n\n        Messages that answer a command sent by the host computer, DO start with a predefined character. The predefined character depends wheter the answer arises from a NMEA sentence or an SBF sentence. This messages are parsed by the method ``parse_septentrio_msg``.\n\n        Args:\n            serial_instance_actual (Serial): serial connection instance.\n            stop_event (threading.Event): Event to be used to stop the reading of the serial port.\n        \"\"\"\n\n        while not stop_event.is_set():\n            # This is if only NMEA messages are received\n            #rx_msg = serial_instance_actual.readline()\n\n            # This looks for the start of a sentence in either NMEA or SBF messages\n            try:\n                rx_msg = serial_instance_actual.read_until(expected='$'.encode('utf-8'))\n                if len(rx_msg) &gt; 0:\n                    self.parse_septentrio_msg(rx_msg)\n            except Exception as e:\n                print('[WARNING]: No bytes to read, ', e)\n\n    def start_thread_gps(self, interface='USB'):\n        \"\"\"\n        Starts the GPS thread responsible for handling I/O communication between the host computer and the Septentrio mosaic-go receiver.\n\n        Creates the threading Event that is set when the I/O communication must be closed.\n\n        Args:\n            interface (str, optional): is one of the allowed Septentrio interfaces. Current implementation of this class only uses 'USB' interface. Defaults to 'USB'.\n        \"\"\"\n\n        self.event_stop_thread_gps = threading.Event()\n\n        if interface == 'USB' or interface == 'COM':\n            t_receive = threading.Thread(target=self.serial_receive, args=(self.serial_instance, self.event_stop_thread_gps))\n\n        #elif interface == 'IP':\n        #    t_receive = threading.Thread(target=self.socket_receive, args=(self.event_stop_thread_gps))\n\n        t_receive.start()\n        print('\\n[DEBUG]: Septentrio GPS thread opened')\n        time.sleep(0.5)\n\n    def stop_thread_gps(self, interface='USB'):\n        \"\"\"\n        Stops the GPS thread.\n\n        Args:\n            interface (str, optional): is one of the allowed Septentrio interfaces. Current implementation of this class only uses 'USB' interface. Defaults to 'USB'.\n        \"\"\"\n\n        self.event_stop_thread_gps.set()\n        time.sleep(0.1)\n\n        if interface =='USB' or interface == 'COM':\n            self.serial_instance.close()\n\n        elif interface =='IP':\n            self.socket.close()\n\n        print('\\n[DEBUG]: Septentrio GPS thread closed')\n\n    def sendCommandGps(self, cmd, interface='USB'):\n        \"\"\"\n        Sends a command to the Septentrio mosaic-go receiver.\n\n        Blocks this thread execution for 500 ms.\n\n        Args:\n            cmd (str): command to be sent to the Septentrio mosaic-go receiver. The available list of commands is defined in \"mosaic-go Reference Guide\".\n            interface (str, optional): is one of the allowed Septentrio interfaces. Current implementation of this class only uses 'USB' interface. Defaults to 'USB'.\n        \"\"\"\n\n        cmd_eof = cmd + '\\n'\n\n        if interface =='USB':\n            self.serial_instance.write(cmd_eof.encode('utf-8'))\n        #elif interface == 'IP':\n        #    self.socket.sendall(cmd_eof.encode('utf-8'))\n\n        time.sleep(0.5)\n\n    def start_gps_data_retrieval(self, stream_number=1, interface='USB', interval='sec1', msg_type='SBF', \n                                 nmea_type='+GGA+HDT', sbf_type='+PVTCartesian+AttEuler'):\n        \"\"\"\n        Starts the streaming of the NMEA or SBF sentences.\n\n        Wrapper of ``sendCommandGps``.\n\n        Args:\n            stream_number (int, optional): each interface can have multiple data streams. This parameter defined which is the number of the stream for the given ``interface``. Defaults to 1.\n            interface (str, optional): is one of the allowed Septentrio interfaces. Current implementation of this class only uses 'USB' interface. Defaults to 'USB'.\n            interval (str, optional): time regularity used by the Septentrio receiver to sense the given SBF/NMEA sentence. Can be any of the following self-explanatory names: 'msec10', 'msec20', 'msec40', 'msec50', 'msec100', 'msec200', 'msec500', 'sec1', 'sec2', 'sec5', 'sec10', 'sec15', 'sec30', 'sec60', 'min2', 'min5', 'min10', 'min15', 'min30', 'min60'. Defaults to 'sec1'.\n            msg_type (str, optional): ``NMEA`` or ``SBF``. Defaults to ``SBF``.\n            nmea_type (str, optional): name/s of the NMEA sentence/s to be retrieved. If multiple sentences, each sentence string identifier should be preceded by '+', and all the string should be concatenated in one single string (i.e. ``+HDT+GGA``). Defaults to ``+GGA+HDT``.\n            sbf_type (str, optional): name/s of the SBF sentence/s to be retrieved. If multiple sentences, each sentence string identifier should be preceded by '+', and all the string should be concatenated in one single string (i.e. '+PVTCartesian+AttEuler'). Each sentence needs to have a parsing function that is called in ``parse_septentrio_msg`` in the part corresponding to the id of the sentence. Defaults to ``+PVTCartesian+AttEuler``.\n        \"\"\"\n\n        if interface == 'USB' or interface == 'COM':\n            if msg_type == 'SBF':\n                cmd1 = 'setDataInOut, ' + interface + str(self.interface_number) + ',, ' + '+SBF'\n                cmd2 = 'setSBFOutput, Stream ' + str(stream_number) + ', ' + interface + str(self.interface_number) + ', ' +  sbf_type + ', ' + interval\n            elif msg_type == 'NMEA':\n                cmd1 = 'setDataInOut, ' + interface + str(self.interface_number) + ',, ' + '+NMEA'\n                cmd2 = 'sno, Stream ' + str(stream_number) + ', ' + interface + str(self.interface_number) + ', ' + nmea_type + ', ' + interval\n\n        self.stream_info.append({'interface': interface, 'stream_number': stream_number, 'interval': interval, 'msg_type': msg_type})\n\n        self.sendCommandGps(cmd1)\n        self.sendCommandGps(cmd2)\n\n        if self.DBG_LVL_1:\n            print('\\n'+ cmd1)\n            print('\\n'+ cmd2)\n\n    def stop_gps_data_retrieval(self, stream_number=1, interface='USB', msg_type='+NMEA+SBF'):   \n        \"\"\"\n        Stops the streaming of the NMEA/SBF sentences initiated by calling ``start_gps_data_retrieval``. \n\n        Wrapper of ``sendCommandGps``.\n\n        *Unexpected behaviour to be noted by* **developers**: *it seems that if the stream is not stopped by the time the serial connection is closed, then, when the user opens a new serial connection, Septentrio will start sending all the SBF or NMEA messages that were produced between the last time the serial connection was closed and the time it is opened again*.\n\n        Args:\n            stream_number (int, optional): number of the stream to be stopped. Defaults to 1.\n            interface (str, optional): is one of the allowed Septentrio interfaces. Current implementation of this class only uses 'USB' interface. Defaults to 'USB'.\n            msg_type (str, optional): the message type corresponding to the stream ``stream_number``. Options: 'SBF', 'NMEA' or '+NMEA+SBF' or '+SBF+NMEA' (the last two are the same). Defaults to ``NMEA+SBF``.\n        \"\"\"\n\n        if interface == 'USB' or interface == 'COM':\n            if msg_type == 'SBF':\n                cmd1 = 'setSBFOutput, Stream ' + str(stream_number) + ', ' + interface + str(self.interface_number) + ', none '\n                cmd2 = 'sdio, ' + interface + str(self.interface_number) + ',, -SBF'\n\n                self.sendCommandGps(cmd1)\n                self.sendCommandGps(cmd2)\n            elif msg_type == 'NMEA':\n                cmd1 = 'sno, Stream ' + str(stream_number) + ', ' + interface + str(self.interface_number) + ', none ' \n                cmd2 = 'sdio, ' + interface + str(self.interface_number) + ',, -NMEA'\n\n                self.sendCommandGps(cmd1)\n                self.sendCommandGps(cmd2)\n            elif msg_type == '+NMEA+SBF' or msg_type == '+SBF+NMEA':\n                cmd1 = 'setSBFOutput, Stream ' + str(stream_number) + ', ' + interface + str(self.interface_number) + ', none '\n                cmd2 = 'sdio, ' + interface + str(self.interface_number) + ',, -SBF'\n                cmd3 = 'sno, Stream ' + str(stream_number) + ', ' + interface + str(self.interface_number) + ', none ' \n                cmd4 = 'sdio, ' + interface + str(self.interface_number) + ',, -NMEA'\n\n                self.sendCommandGps(cmd1)\n                self.sendCommandGps(cmd2)       \n                self.sendCommandGps(cmd3)\n                self.sendCommandGps(cmd4)       \n\n    def setHeadingOffset(self, offset_wrt_xaxis):\n        \"\"\"\n        Sets the offset mismatch between between the imaginary line formed by the first and second antennas AND the longitudinal axis of the node.\n\n        Wrapper of ``sendCommandGps``.\n\n        Args:\n            offset_wrt_xaxis (float): angle (degrees) *from* the longitudinal axis of the node *to* the imaginary line formed by the first and second antennas.\n        \"\"\"\n\n        self.sendCommandGps(cmd='setAttitudeOffset, ' + str(offset_wrt_xaxis))\n</code></pre>"},{"location":"GpsSignaling/#a2gmeasurements.GpsSignaling.__init__","title":"<code>__init__(DBG_LVL_1=False, DBG_LVL_2=False, DBG_LVL_0=False, save_filename='GPS')</code>","text":"<p>Contructor for the GpsSignaling class. Important attributes are:</p> <ul> <li> <p><code>register_sbf_sentences_by_id</code>: list of integers containing the expected SBF sentences that are going to be requested at the receiver. The integer is the ID of the sentence described in Septentrio's manual.</p> </li> <li> <p><code>SBF_frame_buffer</code>: list of dictionaries containing the SBF frames during the execution of the thread responsible for receiving SBF frames.</p> </li> <li> <p><code>MAX_SBF_BUFF_LEN</code>: Maximum number of entries in the SBF frame buffer before saving, cleaning and starting again</p> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>DBG_LVL_1</code> <code>bool</code> <p>used to print less verbose than level 0. Defaults to False.</p> <code>False</code> <code>DBG_LVL_2</code> <code>bool</code> <p>used to print less verbose than level 2. Defaults to False.</p> <code>False</code> <code>DBG_LVL_0</code> <code>bool</code> <p>prints all the verbose available. Defaults to False.</p> <code>False</code> <code>save_filename</code> <code>str</code> <p>name of the file where to save the record of GPS coordinates along an experiment. Defaults to 'GPS'.</p> <code>'GPS'</code> Source code in <code>a2gmeasurements.py</code> <pre><code>def __init__(self, DBG_LVL_1=False, DBG_LVL_2=False, DBG_LVL_0=False, save_filename='GPS'):\n    \"\"\"\n    Contructor for the GpsSignaling class. Important attributes are:\n\n    * ``register_sbf_sentences_by_id``: list of integers containing the expected SBF sentences that are going to be requested at the receiver. The integer is the ID of the sentence described in Septentrio's manual.\n\n    * ``SBF_frame_buffer``: list of dictionaries containing the SBF frames during the execution of the thread responsible for receiving SBF frames.\n\n    * ``MAX_SBF_BUFF_LEN``: Maximum number of entries in the SBF frame buffer before saving, cleaning and starting again\n\n    Args:\n        DBG_LVL_1 (bool, optional): used to print less verbose than level 0. Defaults to False.\n        DBG_LVL_2 (bool, optional): used to print less verbose than level 2. Defaults to False.\n        DBG_LVL_0 (bool, optional): prints all the verbose available. Defaults to False.\n        save_filename (str, optional): name of the file where to save the record of GPS coordinates along an experiment. Defaults to 'GPS'.\n    \"\"\"\n\n    # Initializations\n    datestr = datetime.datetime.now()\n    datestr = datestr.strftime('%Y-%m-%d-%H-%M-%S-%f')\n    self.save_filename = save_filename + '-' + datestr\n    self.SBF_frame_buffer = []\n    self.NMEA_buffer = []\n    self.stream_info = []\n    self.MAX_SBF_BUFF_LEN = 100\n\n    self.DBG_LVL_1 = DBG_LVL_1\n    self.DBG_LVL_2 = DBG_LVL_2\n    self.DBG_LVL_0 = DBG_LVL_0\n\n    # Expected SBF sentences to be requested. Add or remove according to planned\n    # SBF sentences to be requested.\n    self.register_sbf_sentences_by_id = [4006, 5938] # PVTCart, AttEul\n    self.n_sbf_sentences = len(self.register_sbf_sentences_by_id)\n\n    self.ERR_GPS_CODE_GENERAL = -1.5e3\n    self.ERR_GPS_CODE_SMALL_BUFF_SZ = -2.5e3       \n    self.ERR_GPS_CODE_BUFF_NULL = -3.5e3\n    self.ERR_GPS_CODE_NO_COORD_AVAIL = -4.5e3 \n    self.ERR_GPS_CODE_NO_HEAD_AVAIL = -5.5e3\n</code></pre>"},{"location":"GpsSignaling/#a2gmeasurements.GpsSignaling.check_coord_closeness","title":"<code>check_coord_closeness(coordinates2compare, tol=5)</code>","text":"<p>Checks how close is a coordinate with respect to the actual node position.</p> <p>It is assumed that both pair of coordinates to be compared lay at the same height.</p> <p>Parameters:</p> Name Type Description Default <code>coordinates2compare</code> <code>dict</code> <p>keys of the dictionary are 'LAT' and 'LON', and each of them has ONLY ONE value.</p> required <code>tol</code> <code>int</code> <p>margin in meters by which the coordinates in comparison are close or not. Defaults to 5.</p> <code>5</code> <p>Returns:</p> Name Type Description <code>True</code> <code>bool</code> <p>True if close , False otherwise.</p> Source code in <code>a2gmeasurements.py</code> <pre><code>def check_coord_closeness(self, coordinates2compare, tol=5):\n    \"\"\"\n    Checks how close is a coordinate with respect to the actual node position.\n\n    It is assumed that both pair of coordinates to be compared lay at the same height.\n\n    Args:\n        coordinates2compare (dict): keys of the dictionary are 'LAT' and 'LON', and each of them has ONLY ONE value.\n        tol (int, optional): margin in meters by which the coordinates in comparison are close or not. Defaults to 5.\n\n    Returns:\n        True (bool): True if close , False otherwise.\n    \"\"\"\n\n    coords, head_info = self.get_last_sbf_buffer_info(what='Both')\n\n    if coords['X'] == self.ERR_GPS_CODE_BUFF_NULL or self.ERR_GPS_CODE_SMALL_BUFF_SZ:\n        return None\n    else:\n        lat_node, lon_node, height_node = geocentric2geodetic(coords['X'], coords['Y'], coords['Z'])\n        wgs84_geod = Geod(ellps='WGS84')\n\n        _,_, dist = wgs84_geod.inv(lon_node, lat_node, coordinates2compare['LON'], coordinates2compare['LAT'])\n\n        if dist &lt; tol:\n            return True\n        else:\n            return False\n</code></pre>"},{"location":"GpsSignaling/#a2gmeasurements.GpsSignaling.get_last_sbf_buffer_info","title":"<code>get_last_sbf_buffer_info(what='Coordinates')</code>","text":"<p>Retrieves the last gps coordinates, the last heading information of the receiver, or both things.</p> <p>Parameters:</p> Name Type Description Default <code>what</code> <code>str</code> <p>defines which information wants to be retrieved from <code>SBF_frame_buffer</code>. Options are: 'Coordinates', 'Heading' or 'Both'. Defaults to 'Coordinates'.</p> <code>'Coordinates'</code> <p>Returns:</p> Name Type Description <code>data_to_return</code> <code>dict</code> <p><code>X</code>, <code>Y</code> and <code>Z</code> coordinates in absence of any error. Otherwise, the error code.</p> <code>data_to_return_2</code> <code>(dict, optional)</code> <p><code>Heading</code> angle in [0, 360] degrees.</p> Source code in <code>a2gmeasurements.py</code> <pre><code>def get_last_sbf_buffer_info(self, what='Coordinates'):\n    \"\"\"\n    Retrieves the last gps coordinates, the last heading information of the receiver, or both things.\n\n    Args:\n        what (str, optional): defines which information wants to be retrieved from ``SBF_frame_buffer``. Options are: 'Coordinates', 'Heading' or 'Both'. Defaults to 'Coordinates'.\n\n    Returns:\n        data_to_return (dict): ``X``, ``Y`` and ``Z`` coordinates in absence of any error. Otherwise, the error code.\n        data_to_return_2 (dict, optional): ``Heading`` angle in [0, 360] degrees.\n    \"\"\"\n\n    # Coordinates\n    data_to_return = []       \n\n    # Heading\n    data_to_return_2 = []     \n\n    len_sbf_buffer = len(self.SBF_frame_buffer)\n\n    cnt = 1\n    if  len_sbf_buffer &gt; 0:\n        if what == 'Coordinates' or what == 'Heading':\n            while(len(data_to_return) == 0):\n                if cnt &gt; len_sbf_buffer:\n                    print('\\n[WARNING]: Either heading or coordinates information not available')\n\n                    if what == 'Coordinates':\n                        print('\\n[WARNING]: Return ERR_GPS_CODE_NO_COORD_AVAIL for each coordinate in data_to_return')\n                        data_to_return = {'X': self.ERR_GPS_CODE_NO_COORD_AVAIL, 'Y': self.ERR_GPS_CODE_NO_COORD_AVAIL, 'Z': self.ERR_GPS_CODE_NO_COORD_AVAIL}\n                        return data_to_return\n\n                    elif what == 'Heading':\n                        print('\\n[WARNING]: Return ERR_GPS_CODE_NO_HEAD_AVAIL for heading in data_to_return')\n                        data_to_return = {'Heading': self.ERR_GPS_CODE_NO_HEAD_AVAIL}\n                        return data_to_return\n\n                dict_i = self.SBF_frame_buffer[-cnt]\n                if dict_i['ID'] == what:\n                    # Both AttEuler and PVTCart return 'Error' field equal to 0, when there is no error\n                    if dict_i['ERR'] == 0:\n                        data_to_return = dict_i\n\n                cnt = cnt + 1             \n\n            if self.DBG_LVL_1:\n                print('\\n[DEBUG_1]: retrieved a ' + what + ' response') \n\n            return data_to_return\n\n        elif what == 'Both':\n            while((len(data_to_return) == 0) or (len(data_to_return_2) == 0)):     \n                if cnt &gt; len_sbf_buffer:\n                    print('\\n[WARNING]: heading stream not on or not heading info available /or/ coordinates stream not on or no coordinates available')\n                    print('\\n[WARNING]: Return ERR_GPS_CODE_SMALL_BUFF_SZ for each coordinate in data_to_return')\n                    print('\\n[WARNING]: Return ERR_GPS_CODE_SMALL_BUFF_SZ for heading in data_to_return_2')\n\n                    data_to_return = {'X': self.ERR_GPS_CODE_SMALL_BUFF_SZ, 'Y': self.ERR_GPS_CODE_SMALL_BUFF_SZ, 'Z': self.ERR_GPS_CODE_SMALL_BUFF_SZ}\n                    data_to_return_2 = {'Heading': self.ERR_GPS_CODE_SMALL_BUFF_SZ}\n\n                    return data_to_return, data_to_return_2\n\n                dict_i = self.SBF_frame_buffer[-cnt]\n\n                if dict_i['ID'] == 'Heading':\n                    # Both AttEuler and PVTCart return 'Error' field equal to 0, when there is no error\n                    if dict_i['ERR'] == 0:\n                        data_to_return_2 = dict_i                           \n\n                elif dict_i['ID'] == 'Coordinates':\n                    # Both AttEuler and PVTCart return 'Error' field equal to 0, when there is no error\n                    if dict_i['ERR'] == 0:                            \n                        data_to_return = dict_i\n\n                cnt = cnt + 1\n\n            if self.DBG_LVL_1:\n                print('\\n[DEBUG_1]: retrieved a Heading and Coordinates response') \n\n            return data_to_return, data_to_return_2\n    else:\n        print('\\n[WARNING]: nothing in SBF buffer')\n        if what == 'Coordinates':\n            data_to_return = {'X': self.ERR_GPS_CODE_BUFF_NULL, 'Y': self.ERR_GPS_CODE_BUFF_NULL, 'Z': self.ERR_GPS_CODE_BUFF_NULL}\n            print('\\n[ERROR]: Return ERR_GPS_CODE_BUFF_NULL for each coordinate in data_to_return')\n            return data_to_return\n\n        elif what == 'Heading':\n            data_to_return = {'Heading': self.ERR_GPS_CODE_BUFF_NULL}\n            print('\\n[ERROR]: Return ERR_GPS_CODE_BUFF_NULL for each heading in in data_to_return')\n            return data_to_return\n\n        elif what == 'Both':\n            data_to_return = {'X': self.ERR_GPS_CODE_BUFF_NULL, 'Y': self.ERR_GPS_CODE_BUFF_NULL, 'Z': self.ERR_GPS_CODE_BUFF_NULL}\n            data_to_return_2 = {'Heading': self.ERR_GPS_CODE_BUFF_NULL}\n            print('\\n[ERROR]: Return ERR_GPS_CODE_BUFF_NULL for each coordinate in data_to_return and for heading in data_to_return_2')\n            return data_to_return, data_to_return_2    \n</code></pre>"},{"location":"GpsSignaling/#a2gmeasurements.GpsSignaling.parse_septentrio_msg","title":"<code>parse_septentrio_msg(rx_msg)</code>","text":"<p>Parses the received message and process it depending if it is an SBF or NMEA message</p> <p>Raises an exception if any problem is encountered when parsing the message.</p> <p>Parameters:</p> Name Type Description Default <code>rx_msg</code> <code>bytes or str</code> <p>received msg from Ronin RS2 gimbal.</p> required Source code in <code>a2gmeasurements.py</code> <pre><code>def parse_septentrio_msg(self, rx_msg):\n    \"\"\"\n    Parses the received message and process it depending if it is an SBF or NMEA message\n\n    Raises an exception if *any* problem is encountered when parsing the message.\n\n    Args:\n        rx_msg (bytes or str): received msg from Ronin RS2 gimbal.\n    \"\"\"\n\n    try:\n        if self.DBG_LVL_1:\n            print('\\nPARSING RX DATA')\n        if self.DBG_LVL_0:\n            print('0 POS: ', rx_msg[0])\n            print('\\nRX DATA LENGTH: ', len(rx_msg), rx_msg.decode('utf-8', 'ignore'))\n\n        # The SBF output follows the $ sync1 byte, with a second sync byte that is the symbol @ or in utf-8 the decimal 64\n        # Bytes indexing  works as follows:\n        # One integer gives a decimal\n        # A slice (i.e. 0:1) gives a bytes object ---&gt; rx_msg[0] != rx_msg[0:1]\n        if rx_msg[0] == 64:                \n            if self.DBG_LVL_0:\n                print('\\nDETECTS SBF')\n\n            # Header detection\n            #SYNC = struct.unpack('&lt;1c', rx_msg[0:1]) \n            CRC = struct.unpack('&lt;1H', rx_msg[1:3])                \n            ID_SBF_msg = struct.unpack('&lt;1H', rx_msg[3:5])\n            LEN_SBF_msg = struct.unpack('&lt;1H', rx_msg[5:7])\n\n            # According to the manual, the LEN should always be a multiple of 4, otherwise \n            # there is an error\n            if np.mod(int(LEN_SBF_msg[0]),4) != 0 :\n                if self.DBG_LVL_1:\n                    print('\\nDiscarded frame as LEN_SBF_msg is not multiple of 4, LEN_SBF_msg: ', LEN_SBF_msg[0])\n                return\n\n            '''\n            # CRC checker\n            crc16_checker = Calculator(Crc16.CCITT)\n            idx_bytes_crc_to_read = 7+int(LEN_SBF_msg[0])-8\n            crc_data = rx_msg[7:idx_bytes_crc_to_read]\n            print(type(crc_data))\n            crc16 = crc16_checker.checksum(crc_data)\n            print(rx_msg[1:3], type(crc16))\n            if CRC[0] != crc16:\n                if self.DBG_LVL_1:\n                    print('\\nDiscarded frame cause it did not pass the CRC check')\n                return\n            '''\n\n            # PVTGeodetic SBF sentenced identified by ID 4007\n            if ID_SBF_msg[0] &amp; 8191 == 4007: # np.sum([np.power(2,i) for i in range(13)]) # ---&gt;  bits 0-12 contain the ID                    \n                self.process_pvtgeodetic_sbf_data(rx_msg)\n                #print(\"Received pvt geodetic\")\n\n            # PVTCart SBF sentence identified by ID 4006\n            if ID_SBF_msg[0] &amp; 8191 == 4006: # np.sum([np.power(2,i) for i in range(13)]) # ---&gt;  bits 0-12 contain the ID                    \n                self.process_pvtcart_sbf_data(rx_msg)\n                #print(\"Received pvtcart\")\n\n            # PosCovCartesian SBF sentence identified by ID 5905\n            if ID_SBF_msg[0] &amp; 8191 == 5905: # np.sum([np.power(2,i) for i in range(13)]) # ---&gt;  bits 0-12 contain the ID\n                if self.DBG_LVL_1:\n                    print('\\nReceived PosCovCartesian SBF sentence')\n\n            if ID_SBF_msg[0] &amp; 8191 == 5907: # np.sum([np.power(2,i) for i in range(13)]) # ---&gt;  bits 0-12 contain the ID\n                if self.DBG_LVL_1:\n                    print('\\nReceived VelCovCartesian SBF sentence')\n\n            if ID_SBF_msg[0] &amp; 8191 == 4043: # np.sum([np.power(2,i) for i in range(13)]) # ---&gt;  bits 0-12 contain the ID\n                if self.DBG_LVL_1:\n                    print('\\nReceived BaseVectorCart SBF sentence')\n\n            if ID_SBF_msg[0] &amp; 8191 == 5942: # np.sum([np.power(2,i) for i in range(13)]) # ---&gt;  bits 0-12 contain the ID\n                if self.DBG_LVL_1:\n                    print('\\nReceived AuxAntPositions SBF sentence')\n\n            if ID_SBF_msg[0] &amp; 8191 == 5938: # np.sum([np.power(2,i) for i in range(13)]) # ---&gt;  bits 0-12 contain the ID\n                if self.DBG_LVL_1:\n                    1\n                    #print('\\nReceived AttEuler SBF sentence')\n                print(\"Received attitude\")\n                self.process_atteuler_sbf_data(rx_msg)\n\n            if ID_SBF_msg[0] &amp; 8191 == 5939: # np.sum([np.power(2,i) for i in range(13)]) # ---&gt;  bits 0-12 contain the ID\n                if self.DBG_LVL_1:\n                    print('\\nReceived AttCovEuler SBF sentence')\n\n            if ID_SBF_msg[0] &amp; 8191 == 5943: # np.sum([np.power(2,i) for i in range(13)]) # ---&gt;  bits 0-12 contain the ID\n                if self.DBG_LVL_1:\n                    print('\\nReceived EndOfAtt SBF sentence')\n\n            # Sort SBF buffer entries by time (this is double checking, as they are expected to arrive in time order)\n            self.SBF_frame_buffer.sort(key=lambda k : k['TOW'])\n\n            # Merge buffer entries corresponding to the same TOW\n            #self.util_merge_buffer_entries_by_timetag(type_msg='SBF')\n\n        # NMEA Output starts with the letter G, that in utf-8 is the decimal 71\n        elif rx_msg[0] == 71:\n            if self.DBG_LVL_0:\n                print('\\nDETECTS NMEA')\n            self.process_gps_nmea_data(rx_msg[:-1])\n            #self.util_merge_buffer_entries_by_timetag(type_msg='NMEA')\n\n    except Exception as e:\n        if self.DBG_LVL_1:\n            print('\\nEXCEPTION IN parse_septentrio_msg')\n        if self.DBG_LVL_0:\n            print('\\nThis is the exception: ', e, )\n            logging.exception(\"\\nError occurred: \")\n</code></pre>"},{"location":"GpsSignaling/#a2gmeasurements.GpsSignaling.process_atteuler_sbf_data","title":"<code>process_atteuler_sbf_data(raw_data)</code>","text":"<p>Parses an AttEuler SBF sentence. To be able to receive this block, the receiver should be configured to output SBF sentences.</p> <p>The AttEuler SBF sentence provides heading information of the imaginary line formed by the first and second antennas, w.r.t the North. To do so, the heading, pitch, and roll axis are defined.</p> <p>The coordinates are stored in <code>SBF_frame_buffer</code>. Each <code>MAX_SBF_BUFF_LEN</code> entries of <code>SBF_frame_buffer</code>, the buffer is flushed and its contents are saved on disk.</p> <p>More about all axis definition, and heading information in \"mosaic-go Reference Guide\".</p> <p>Parameters:</p> Name Type Description Default <code>raw_data</code> <code>bytes</code> <p>received data corresponding to the AttEurler SBF sentence.</p> required Source code in <code>a2gmeasurements.py</code> <pre><code>def process_atteuler_sbf_data(self, raw_data):\n    \"\"\"\n    Parses an AttEuler SBF sentence. To be able to receive this block, the receiver should be configured to output SBF sentences.\n\n    The AttEuler SBF sentence provides heading information of the imaginary line formed by the first and second antennas, w.r.t the North. To do so, the heading, pitch, and roll axis are defined.\n\n    The coordinates are stored in ``SBF_frame_buffer``. Each ``MAX_SBF_BUFF_LEN`` entries of ``SBF_frame_buffer``, the buffer is flushed and its contents are saved on disk.\n\n    *More about all axis definition, and heading information in \"mosaic-go Reference Guide\"*.\n\n    Args:\n        raw_data (bytes): received data corresponding to the AttEurler SBF sentence.\n    \"\"\"\n\n    TOW = struct.unpack('&lt;1I', raw_data[7:11])[0]\n    WNc = struct.unpack('&lt;1H', raw_data[11:13])[0]        \n    NrSV = struct.unpack('&lt;1B', raw_data[13:14])[0]\n    ERR =  struct.unpack('&lt;1B', raw_data[14:15])[0]\n    MODE =  struct.unpack('&lt;1H', raw_data[15:17])[0]\n    Heading =  struct.unpack('&lt;1f', raw_data[19:23])[0]\n    try:\n        Pitch =  struct.unpack('&lt;1f', raw_data[23:27])[0]\n    except Exception as e:\n        print(\"[DEBUG]: Error unpacking Pitch attitude, \", e)\n    Roll = struct.unpack('&lt;1f', raw_data[27:31])[0]\n    PitchDot =  struct.unpack('&lt;1f', raw_data[31:35])[0]\n    RollDot =  struct.unpack('&lt;1f', raw_data[35:39])[0]\n    HeadingDot = struct.unpack('&lt;1f', raw_data[39:43])[0]\n\n    '''\n    atteul_msg_format = {'TOW': TOW, 'WNc': WNc, 'NrSV': NrSV, 'ERR': ERR, 'MODE': MODE, \n                         'Heading': Heading, 'Pitch': Pitch, 'Roll': Roll, \n                         'PitchDot': PitchDot, 'RollDot': RollDot, 'HeadingDot': HeadingDot}        \n    '''\n    atteul_msg_useful = {'ID': 'Heading', 'TOW': TOW, 'WNc': WNc,'ERR': ERR, 'MODE': MODE, \n                         'Heading': Heading, 'Pitch': Pitch, 'Roll': Roll}\n\n    self.SBF_frame_buffer.append(atteul_msg_useful)\n\n    if len(self.SBF_frame_buffer) &gt; self.MAX_SBF_BUFF_LEN:\n        with open(self.save_filename + '.txt', 'a+') as file:      \n            file.write(json.dumps(self.SBF_frame_buffer))    \n            print(\"[DEBUG]: Saved GPS cooridnates file\")             \n        self.SBF_frame_buffer = []\n</code></pre>"},{"location":"GpsSignaling/#a2gmeasurements.GpsSignaling.process_gps_nmea_data","title":"<code>process_gps_nmea_data(data)</code>","text":"<p>Parses a line of NMEA data retrieved from the gps and coming from the virtual serial port.</p> <p>Used NMEA sentences are GGA and HDT.</p> <p>The labels of the items of the returned dictionary are the following ones for the GGA sentence: <code>Timestamp</code>, <code>Latitude</code>, <code>Longitude</code>, <code>Latitude Direction</code>, <code>Longitude</code>, <code>Longitude Direction</code>, <code>GPS Quality Indicator</code>, <code>Number of Satellites in use</code>, <code>Horizontal Dilution of Precision</code>, <code>Antenna Alt above sea level (mean)</code>, <code>Units of altitude (meters)</code>, <code>Geoidal Separation</code>, <code>Units of Geoidal Separation (meters)</code>, <code>Age of Differential GPS Data (secs)</code>, <code>Differential Reference Station ID</code>.</p> <p>The instances of this class created in the GUI and other classes, use SBF sentences as the default type of sentence.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>line of read data following the structure of a NMEA frame.</p> required Source code in <code>a2gmeasurements.py</code> <pre><code>def process_gps_nmea_data(self, data):\n    \"\"\"\n    Parses a line of NMEA data retrieved from the gps and coming from the virtual serial port.\n\n    Used NMEA sentences are GGA and HDT.\n\n    The labels of the items of the returned dictionary are the following ones for the GGA sentence: ``Timestamp``, ``Latitude``, ``Longitude``, ``Latitude Direction``, ``Longitude``, ``Longitude Direction``, ``GPS Quality Indicator``, ``Number of Satellites in use``, ``Horizontal Dilution of Precision``, ``Antenna Alt above sea level (mean)``, ``Units of altitude (meters)``, ``Geoidal Separation``, ``Units of Geoidal Separation (meters)``, ``Age of Differential GPS Data (secs)``, ``Differential Reference Station ID``.\n\n    *The instances of this class created in the GUI and other classes, use SBF sentences as the default type of sentence*.\n\n    Args:\n        data (str): line of read data following the structure of a NMEA frame.\n    \"\"\"\n\n    try:\n        if self.DBG_LVL_0:\n            print('\\nNMEA PARSING')\n\n        nmeaobj = pynmea2.parse(data.decode())\n        extracted_data = ['%s: %s' % (nmeaobj.fields[i][0], nmeaobj.data[i]) for i in range(len(nmeaobj.fields))]\n        gps_data = {}\n        for item in extracted_data:\n            tmp = item.split(': ')\n            gps_data[tmp[0]] = tmp[1]\n\n        # GGA type of NMEA sentence\n        if 'Antenna Alt above sea level (mean)' in gps_data:\n            if int(gps_data['Latitude'][0]) != 0:\n                gps_data['Latitude'] = float(gps_data['Latitude'][0:2]) + float(gps_data['Latitude'][2:])/60\n            else:\n                gps_data['Latitude'] = float(gps_data['Latitude'][0:3]) + float(gps_data['Latitude'][3:])/60\n\n            if int(gps_data['Longitude'][0]) != 0:\n                gps_data['Longitude'] = float(gps_data['Longitude'][0:2]) + float(gps_data['Longitude'][2:])/60\n            else:\n                gps_data['Longitude'] = float(gps_data['Longitude'][0:3]) + float(gps_data['Longitude'][3:])/60\n\n            gps_data['Antenna Alt above sea level (mean)'] = float(gps_data['Antenna Alt above sea level (mean)'])\n            gps_data['Timestamp'] = float(gps_data['Timestamp'])\n\n            '''\n            # Save the UNIX timestamp. As the timestamp provides hour/min/sec only, add the date\n            today_date = datetime.date.today()\n            today_date = [int(i) for i in today_date.strftime(\"%Y-%m-%d\").split('-')]                \n\n            complete_date = datetime.datetime(year=today_date[0], \n                                            month=today_date[1], \n                                            day=today_date[2], \n                                            hour=int(gps_data['Timestamp'][0:2]), \n                                            minute=int(gps_data['Timestamp'][2:4]), \n                                            second=int(gps_data['Timestamp'][4:6]))\n\n            gps_data['Timestamp'] = time.mktime(complete_date.timetuple())\n\n            '''\n\n        # HDT NMEA sentence\n        if 'Heading' in gps_data:\n            if gps_data['Heading'] == '':\n                gps_data['Heading'] = -2000\n            else:\n                gps_data['Heading'] = float(gps_data['Heading'])\n\n            # No need to restrict heading to [-pi, pi] since it will be done \n            # inside 'ground_gimbal_follows_drone' function \n            #if gps_data['Heading'] &gt; 180:\n            #    gps_data['Heading'] = gps_data['Heading'] - 360\n\n            # Make the timestamp the same format as the GGA sentence\n            for stream in self.stream_info:\n                if stream['msg_type'] == 'NMEA':\n                    # Need to update faster\n                    if 'msec' in stream['interval']:\n                        1\n                    #elif 'sec' in stream['interval']:                            \n                    else:\n                        gps_data['Timestamp'] = ''\n                        for i in datetime.datetime.utcnow().timetuple()[3:6]:\n                            tmp = str(i)\n                            if len(tmp) == 1:\n                                tmp = '0' + tmp\n                            gps_data['Timestamp'] = gps_data['Timestamp'] + tmp\n                        gps_data['Timestamp'] = float(int(gps_data['Timestamp']))\n\n        if self.DBG_LVL_2 or len(self.NMEA_buffer):\n            if self.DBG_LVL_0:\n                print('\\nSAVES NMEA DATA INTO BUFFER')    \n            self.NMEA_buffer.append(gps_data)  \n\n    except Exception as e:\n        # Do not save any other comand line\n        if self.DBG_LVL_1:\n            print('\\nEXCEPTION PROCESSING NMEA')\n        if self.DBG_LVL_0:\n            print('\\nThis is the exception: ', e) \n</code></pre>"},{"location":"GpsSignaling/#a2gmeasurements.GpsSignaling.process_pvtcart_sbf_data","title":"<code>process_pvtcart_sbf_data(raw_data)</code>","text":"<p>Parses an PVTCart SBF sentence. To be able to receive this block, the receiver should be configured to output SBF sentences.</p> <p>The PVTCart SBF sentence provides geocentric coordinates X, Y, Z for the position of the receiver.</p> <p>The coordinates are stored in <code>SBF_frame_buffer</code>. Each <code>MAX_SBF_BUFF_LEN</code> entries of <code>SBF_frame_buffer</code>, the buffer is flushed and its contents are saved on disk.</p> <p>More about the information carried by this block in \"mosaic-go Reference Guide\".</p> <p>Parameters:</p> Name Type Description Default <code>raw_data</code> <code>bytes</code> <p>received data corresponding to the PVTCart SBF block.</p> required Source code in <code>a2gmeasurements.py</code> <pre><code>def process_pvtcart_sbf_data(self, raw_data):\n    \"\"\"\n    Parses an PVTCart SBF sentence. To be able to receive this block, the receiver should be configured to output SBF sentences.\n\n    The PVTCart SBF sentence provides geocentric coordinates X, Y, Z for the position of the receiver.\n\n    The coordinates are stored in ``SBF_frame_buffer``. Each ``MAX_SBF_BUFF_LEN`` entries of ``SBF_frame_buffer``, the buffer is flushed and its contents are saved on disk.\n\n    *More about the information carried by this block in \"mosaic-go Reference Guide\"*.\n\n    Args:\n        raw_data (bytes): received data corresponding to the PVTCart SBF block.\n    \"\"\"\n\n    format_before_padd = '&lt;1c3H1I1H2B3d5f1d1f4B2H1I2B4H1B' \n    format_after_padd = format_before_padd + str(sys.getsizeof(raw_data)-struct.calcsize(format_before_padd)) + 'B'\n\n    TOW = struct.unpack('&lt;1I', raw_data[7:11])[0]\n    WNc = struct.unpack('&lt;1H', raw_data[11:13])[0]        \n    MODE =  struct.unpack('&lt;1B', raw_data[13:14])[0]\n    ERR =  struct.unpack('&lt;1B', raw_data[14:15])[0]\n    X =  struct.unpack('&lt;1d', raw_data[15:23])[0]\n    Y =  struct.unpack('&lt;1d', raw_data[23:31])[0]\n    try:\n        Z = struct.unpack('&lt;1d', raw_data[31:39])[0]\n    except Exception as e:\n        if self.DBG_LVL_0:\n            print(\"[DEBUG]: error unpacking Z coord, \", e)\n    Undulation =  struct.unpack('&lt;1f', raw_data[39:43])[0]\n    Vx =  struct.unpack('&lt;1f', raw_data[43:47])[0]\n    Vy = struct.unpack('&lt;1f', raw_data[47:51])[0]\n    Vz =  struct.unpack('&lt;1f', raw_data[51:55])[0]\n    COG =  struct.unpack('&lt;1f', raw_data[55:59])[0]\n    RxClkBias = struct.unpack('&lt;1d', raw_data[59:67])[0]\n    RxClkDrift =  struct.unpack('&lt;1f', raw_data[67:71])[0]\n    TimeSystem = struct.unpack('&lt;1B', raw_data[71:72])[0]\n    Datum =  struct.unpack('&lt;1B', raw_data[72:73])[0]\n    NrSV = struct.unpack('&lt;1B', raw_data[73:74])[0]\n    WACorrInfo =  struct.unpack('&lt;1B', raw_data[74:75])[0]\n    ReferenceID =  struct.unpack('&lt;1H', raw_data[75:77])[0]\n    MeanCorrAge = struct.unpack('&lt;1H', raw_data[77:79])[0]\n    SignalInfo =  struct.unpack('&lt;1I', raw_data[79:83])[0] \n    AlertFlag = struct.unpack('&lt;1B', raw_data[83:84])[0]\n    NrBases =  struct.unpack('&lt;1B', raw_data[84:85])[0]\n    PPPInfo =  struct.unpack('&lt;1H', raw_data[85:87])[0]\n    Latency =  struct.unpack('&lt;1H', raw_data[87:89])[0]        \n    HAccuracy =  struct.unpack('&lt;1H', raw_data[89:91])[0]         \n    VAccuracy =  struct.unpack('&lt;1H', raw_data[91:93])[0]  \n\n    '''\n    pvt_msg_format = {'TOW': TOW, 'WNc': WNc, 'MODE': MODE, 'ERR': ERR, 'X': X, 'Y': Y, 'Z': Z,\n                      'Undulation': Undulation, 'Vx': Vx, 'Vy': Vy, 'Vz': Vz, 'COG': COG,\n                      'RxClkBias': RxClkBias, 'RxClkDrift': RxClkDrift, 'TimeSystem': TimeSystem, 'Datum': Datum,\n                      'NrSV': NrSV, 'WACorrInfo': WACorrInfo, 'ReferenceID': ReferenceID, 'MeanCorrAge': MeanCorrAge,\n                      'SignalInfo': SignalInfo, 'AlertFlag': AlertFlag, 'NrBases': NrBases, 'PPPInfo': PPPInfo,\n                      'Latency': Latency, 'HAccuracy': HAccuracy, 'VAccuracy': VAccuracy}        \n    '''\n    pvt_data_we_care = {'ID': 'Coordinates', 'TOW': TOW, 'WNc': WNc, 'MODE': MODE, 'ERR': ERR, \n                        'X': X, 'Y': Y, 'Z': Z, 'Datum': Datum}\n\n    self.SBF_frame_buffer.append(pvt_data_we_care)\n\n    if len(self.SBF_frame_buffer) &gt; self.MAX_SBF_BUFF_LEN:\n        with open(self.save_filename + '.txt', 'a+') as file:      \n            file.write(json.dumps(self.SBF_frame_buffer))       \n            print(\"[DEBUG]: Saved GPS cooridnates file\")     \n        self.SBF_frame_buffer = []\n</code></pre>"},{"location":"GpsSignaling/#a2gmeasurements.GpsSignaling.process_pvtgeodetic_sbf_data","title":"<code>process_pvtgeodetic_sbf_data(raw_data)</code>","text":"<p>Parses an PVTGeodetic SBF sentence. To be able to receive this block, the receiver should be configured to output SBF sentences.</p> <p>The PVTGeodetic SBF sentence provides geodetic coordinates lat, lon, h for the position of the receiver.</p> <p>The coordinates are stored in <code>SBF_frame_buffer</code>. Each <code>MAX_SBF_BUFF_LEN</code> entries of <code>SBF_frame_buffer</code>, the buffer is flushed and its contents are saved on disk.</p> <p>More about the information carried by this block in \"mosaic-go Reference Guide\".</p> <p>Parameters:</p> Name Type Description Default <code>raw_data</code> <code>bytes</code> <p>received data corresponding to the PVTGeodetic SBF block.</p> required Source code in <code>a2gmeasurements.py</code> <pre><code>def process_pvtgeodetic_sbf_data(self, raw_data):\n    \"\"\"\n    Parses an PVTGeodetic SBF sentence. To be able to receive this block, the receiver should be configured to output SBF sentences.\n\n    The PVTGeodetic SBF sentence provides geodetic coordinates lat, lon, h for the position of the receiver.\n\n    The coordinates are stored in ``SBF_frame_buffer``. Each ``MAX_SBF_BUFF_LEN`` entries of ``SBF_frame_buffer``, the buffer is flushed and its contents are saved on disk.\n\n    *More about the information carried by this block in \"mosaic-go Reference Guide\"*.\n\n    Args:\n        raw_data (bytes): received data corresponding to the PVTGeodetic SBF block.\n    \"\"\"\n\n    TOW = struct.unpack('&lt;1I', raw_data[7:11])[0]\n    WNc = struct.unpack('&lt;1H', raw_data[11:13])[0]        \n    MODE =  struct.unpack('&lt;1B', raw_data[13:14])[0]\n    ERR =  struct.unpack('&lt;1B', raw_data[14:15])[0]\n    LAT =  struct.unpack('&lt;1d', raw_data[15:23])[0]\n    LON =  struct.unpack('&lt;1d', raw_data[23:31])[0]\n    H = struct.unpack('&lt;1d', raw_data[31:39])[0]\n    Undulation =  struct.unpack('&lt;1f', raw_data[39:43])[0]\n    Vx =  struct.unpack('&lt;1f', raw_data[43:47])[0]\n    Vy = struct.unpack('&lt;1f', raw_data[47:51])[0]\n    Vz =  struct.unpack('&lt;1f', raw_data[51:55])[0]\n    COG =  struct.unpack('&lt;1f', raw_data[55:59])[0]\n    RxClkBias = struct.unpack('&lt;1d', raw_data[59:67])[0]\n    RxClkDrift =  struct.unpack('&lt;1f', raw_data[67:71])[0]\n    TimeSystem = struct.unpack('&lt;1B', raw_data[71:72])[0]\n    Datum =  struct.unpack('&lt;1B', raw_data[72:73])[0]        \n\n    pvt_data_we_care = {'ID': 'Coordinates', 'TOW': TOW, 'WNc': WNc, 'MODE': MODE, 'ERR': ERR, \n                        'LAT': LAT, 'LON': LON, 'HEIGHT': H, 'Datum': Datum}\n\n    self.SBF_frame_buffer.append(pvt_data_we_care)\n\n    if len(self.SBF_frame_buffer) &gt; self.MAX_SBF_BUFF_LEN:\n        with open(self.save_filename + '.txt', 'a+') as file:      \n            file.write(json.dumps(self.SBF_frame_buffer))      \n            print(\"[DEBUG]: Saved GPS cooridnates file\")           \n        self.SBF_frame_buffer = []\n</code></pre>"},{"location":"GpsSignaling/#a2gmeasurements.GpsSignaling.sendCommandGps","title":"<code>sendCommandGps(cmd, interface='USB')</code>","text":"<p>Sends a command to the Septentrio mosaic-go receiver.</p> <p>Blocks this thread execution for 500 ms.</p> <p>Parameters:</p> Name Type Description Default <code>cmd</code> <code>str</code> <p>command to be sent to the Septentrio mosaic-go receiver. The available list of commands is defined in \"mosaic-go Reference Guide\".</p> required <code>interface</code> <code>str</code> <p>is one of the allowed Septentrio interfaces. Current implementation of this class only uses 'USB' interface. Defaults to 'USB'.</p> <code>'USB'</code> Source code in <code>a2gmeasurements.py</code> <pre><code>def sendCommandGps(self, cmd, interface='USB'):\n    \"\"\"\n    Sends a command to the Septentrio mosaic-go receiver.\n\n    Blocks this thread execution for 500 ms.\n\n    Args:\n        cmd (str): command to be sent to the Septentrio mosaic-go receiver. The available list of commands is defined in \"mosaic-go Reference Guide\".\n        interface (str, optional): is one of the allowed Septentrio interfaces. Current implementation of this class only uses 'USB' interface. Defaults to 'USB'.\n    \"\"\"\n\n    cmd_eof = cmd + '\\n'\n\n    if interface =='USB':\n        self.serial_instance.write(cmd_eof.encode('utf-8'))\n    #elif interface == 'IP':\n    #    self.socket.sendall(cmd_eof.encode('utf-8'))\n\n    time.sleep(0.5)\n</code></pre>"},{"location":"GpsSignaling/#a2gmeasurements.GpsSignaling.serial_connect","title":"<code>serial_connect(serial_port=None)</code>","text":"<p>Open a serial connection. The Septentrio mosaic-go provides 2 virtual serial ports.</p> <p>In Windows the name of the virtual serial ports are typically: COM# (Virtual serial port 1), COM# (Virtual serial port 2).</p> <p>In Linux the name of the virtual serial ports (controlled by the standard Linux CDC-ACM driver) are: <code>/dev/ttyACM0</code> (Virtual serial port 1), <code>/dev/ttyACM1</code> (Virtual serial port 2).</p> <p>Septentrio has different interfaces to use with its receiver. Among other interfaces are: IP (using Ethernet-over-USB), USB.</p> <p>For the virtual serial ports the interface name in Septentrio receiver is 'USB' as their communication is made through the USB connection with the host computer. </p> <p>Additionally there is an actual (not virtual) serial port in the mosaic-go device. Under Linux, the name of this port is <code>/dev/serial0</code> which is the symbolic link to either <code>dev/ttyS#</code> or <code>/dev/ttyAMA#</code>.</p> <p>For information about all available interfaces check the Septentrio \"mosaic-go Reference Guide\".</p> <p>It is important to note that only the USB interface has been implemented in this class.</p> <p>Parameters:</p> Name Type Description Default <code>serial_port</code> <code>str</code> <p>serial port or virtual serial port name. Defaults to None.</p> <code>None</code> Source code in <code>a2gmeasurements.py</code> <pre><code>def serial_connect(self, serial_port=None):\n    \"\"\"\n    Open a serial connection. The Septentrio mosaic-go provides 2 virtual serial ports.\n\n    In Windows the name of the virtual serial ports are typically: COM# (Virtual serial port 1), COM# (Virtual serial port 2).\n\n    In Linux the name of the virtual serial ports (controlled by the standard Linux CDC-ACM driver) are: ``/dev/ttyACM0`` (Virtual serial port 1), ``/dev/ttyACM1`` (Virtual serial port 2).\n\n    Septentrio has different interfaces to use with its receiver. Among other interfaces are: IP (using Ethernet-over-USB), USB.\n\n    For the virtual serial ports the interface name in Septentrio receiver is 'USB' as their\n    communication is made through the USB connection with the host computer. \n\n    Additionally there is an actual (not virtual) serial port in the mosaic-go device. Under Linux, the name of this port is ``/dev/serial0`` which is the symbolic link to either ``dev/ttyS#`` or ``/dev/ttyAMA#``.\n\n    For information about all available interfaces check the Septentrio \"mosaic-go Reference Guide\".\n\n    *It is important to note that only the USB interface has been implemented in this class*.\n\n    Args:\n        serial_port (str, optional): serial port or virtual serial port name. Defaults to None.\n    \"\"\"\n\n    self.serial_port = None\n    # Look for the first Virtual Com in Septentrio receiver. It is assumed that it is available, \n    # meaning that it has been closed by user if was used before.        \n    for (this_port, desc, _) in sorted(comports()):\n\n        # Linux CDC-ACM driver\n        if 'Septentrio USB Device - CDC Abstract Control Model (ACM)' in desc:\n                #self.serial_port = '/dev/ttyACM0'\n                self.serial_port = this_port\n                self.interface_number = 2\n        # Windows driver\n        elif 'Septentrio Virtual USB COM Port 1' in desc: # Choose the first virtual COM port\n                self.serial_port = this_port\n                self.interface_number = 1\n\n    if self.serial_port is None:\n        self.GPS_CONN_SUCCESS = False\n        print(\"\\n[DEBUG]: NO GPS found in any serial port\")\n        return\n    else:\n        self.GPS_CONN_SUCCESS = True\n        print(\"\\n[DEBUG]: GPS found in one serial port\")\n\n    serial_instance = None\n    while serial_instance is None:\n        try:\n            serial_instance = serial.serial_for_url(self.serial_port,\n                                                    9600,\n                                                    parity='N',\n                                                    rtscts=False,\n                                                    xonxoff=False,\n                                                    do_not_open=True)\n\n            serial_instance.timeout = 5\n\n            serial_instance.exclusive = True\n            serial_instance.open()\n\n        except serial.SerialException as e:\n            sys.stderr.write('could not open port {!r}: {}\\n'.format(self.serial_port, e))\n\n        else:\n            break\n\n    #if self.DBG_LVL_0:\n    print('[DEBUG]:CONNECTED TO VIRTUAL SERIAL PORT IN SEPTENTRIO')\n\n    self.serial_instance = serial_instance\n    time.sleep(0.1)\n</code></pre>"},{"location":"GpsSignaling/#a2gmeasurements.GpsSignaling.serial_receive","title":"<code>serial_receive(serial_instance_actual, stop_event)</code>","text":"<p>Callback function invoked by the thread responsible for handling I/O communication between the host computer and the Septentrio mosaic-go receiver.</p> <p>Most of all messages sent by Septentrio mosaic-go receiver start with an \"$\" character.</p> <p>The next character depends if the message is an echo of a command sent by the host computer, or if the message is an answer to a command sent by the host computer.</p> <p>Echoes of commands sent by the host computer, don't follow the <code>$</code> character with any predefined character. This messages are discarded by the method <code>parse_septentrio_msg</code>.</p> <p>Messages that answer a command sent by the host computer, DO start with a predefined character. The predefined character depends wheter the answer arises from a NMEA sentence or an SBF sentence. This messages are parsed by the method <code>parse_septentrio_msg</code>.</p> <p>Parameters:</p> Name Type Description Default <code>serial_instance_actual</code> <code>Serial</code> <p>serial connection instance.</p> required <code>stop_event</code> <code>Event</code> <p>Event to be used to stop the reading of the serial port.</p> required Source code in <code>a2gmeasurements.py</code> <pre><code>def serial_receive(self, serial_instance_actual, stop_event):\n    \"\"\"\n    Callback function invoked by the thread responsible for handling I/O communication between the host computer and the Septentrio mosaic-go receiver.\n\n    Most of all messages sent by Septentrio mosaic-go receiver start with an \"$\" character.\n\n    The next character depends if the message is an echo of a command sent by the host computer, or if the message is an answer to a command sent by the host computer.\n\n    Echoes of commands sent by the host computer, don't follow the ``$`` character with any predefined character. This messages are discarded by the method ``parse_septentrio_msg``.\n\n    Messages that answer a command sent by the host computer, DO start with a predefined character. The predefined character depends wheter the answer arises from a NMEA sentence or an SBF sentence. This messages are parsed by the method ``parse_septentrio_msg``.\n\n    Args:\n        serial_instance_actual (Serial): serial connection instance.\n        stop_event (threading.Event): Event to be used to stop the reading of the serial port.\n    \"\"\"\n\n    while not stop_event.is_set():\n        # This is if only NMEA messages are received\n        #rx_msg = serial_instance_actual.readline()\n\n        # This looks for the start of a sentence in either NMEA or SBF messages\n        try:\n            rx_msg = serial_instance_actual.read_until(expected='$'.encode('utf-8'))\n            if len(rx_msg) &gt; 0:\n                self.parse_septentrio_msg(rx_msg)\n        except Exception as e:\n            print('[WARNING]: No bytes to read, ', e)\n</code></pre>"},{"location":"GpsSignaling/#a2gmeasurements.GpsSignaling.setHeadingOffset","title":"<code>setHeadingOffset(offset_wrt_xaxis)</code>","text":"<p>Sets the offset mismatch between between the imaginary line formed by the first and second antennas AND the longitudinal axis of the node.</p> <p>Wrapper of <code>sendCommandGps</code>.</p> <p>Parameters:</p> Name Type Description Default <code>offset_wrt_xaxis</code> <code>float</code> <p>angle (degrees) from the longitudinal axis of the node to the imaginary line formed by the first and second antennas.</p> required Source code in <code>a2gmeasurements.py</code> <pre><code>def setHeadingOffset(self, offset_wrt_xaxis):\n    \"\"\"\n    Sets the offset mismatch between between the imaginary line formed by the first and second antennas AND the longitudinal axis of the node.\n\n    Wrapper of ``sendCommandGps``.\n\n    Args:\n        offset_wrt_xaxis (float): angle (degrees) *from* the longitudinal axis of the node *to* the imaginary line formed by the first and second antennas.\n    \"\"\"\n\n    self.sendCommandGps(cmd='setAttitudeOffset, ' + str(offset_wrt_xaxis))\n</code></pre>"},{"location":"GpsSignaling/#a2gmeasurements.GpsSignaling.start_gps_data_retrieval","title":"<code>start_gps_data_retrieval(stream_number=1, interface='USB', interval='sec1', msg_type='SBF', nmea_type='+GGA+HDT', sbf_type='+PVTCartesian+AttEuler')</code>","text":"<p>Starts the streaming of the NMEA or SBF sentences.</p> <p>Wrapper of <code>sendCommandGps</code>.</p> <p>Parameters:</p> Name Type Description Default <code>stream_number</code> <code>int</code> <p>each interface can have multiple data streams. This parameter defined which is the number of the stream for the given <code>interface</code>. Defaults to 1.</p> <code>1</code> <code>interface</code> <code>str</code> <p>is one of the allowed Septentrio interfaces. Current implementation of this class only uses 'USB' interface. Defaults to 'USB'.</p> <code>'USB'</code> <code>interval</code> <code>str</code> <p>time regularity used by the Septentrio receiver to sense the given SBF/NMEA sentence. Can be any of the following self-explanatory names: 'msec10', 'msec20', 'msec40', 'msec50', 'msec100', 'msec200', 'msec500', 'sec1', 'sec2', 'sec5', 'sec10', 'sec15', 'sec30', 'sec60', 'min2', 'min5', 'min10', 'min15', 'min30', 'min60'. Defaults to 'sec1'.</p> <code>'sec1'</code> <code>msg_type</code> <code>str</code> <p><code>NMEA</code> or <code>SBF</code>. Defaults to <code>SBF</code>.</p> <code>'SBF'</code> <code>nmea_type</code> <code>str</code> <p>name/s of the NMEA sentence/s to be retrieved. If multiple sentences, each sentence string identifier should be preceded by '+', and all the string should be concatenated in one single string (i.e. <code>+HDT+GGA</code>). Defaults to <code>+GGA+HDT</code>.</p> <code>'+GGA+HDT'</code> <code>sbf_type</code> <code>str</code> <p>name/s of the SBF sentence/s to be retrieved. If multiple sentences, each sentence string identifier should be preceded by '+', and all the string should be concatenated in one single string (i.e. '+PVTCartesian+AttEuler'). Each sentence needs to have a parsing function that is called in <code>parse_septentrio_msg</code> in the part corresponding to the id of the sentence. Defaults to <code>+PVTCartesian+AttEuler</code>.</p> <code>'+PVTCartesian+AttEuler'</code> Source code in <code>a2gmeasurements.py</code> <pre><code>def start_gps_data_retrieval(self, stream_number=1, interface='USB', interval='sec1', msg_type='SBF', \n                             nmea_type='+GGA+HDT', sbf_type='+PVTCartesian+AttEuler'):\n    \"\"\"\n    Starts the streaming of the NMEA or SBF sentences.\n\n    Wrapper of ``sendCommandGps``.\n\n    Args:\n        stream_number (int, optional): each interface can have multiple data streams. This parameter defined which is the number of the stream for the given ``interface``. Defaults to 1.\n        interface (str, optional): is one of the allowed Septentrio interfaces. Current implementation of this class only uses 'USB' interface. Defaults to 'USB'.\n        interval (str, optional): time regularity used by the Septentrio receiver to sense the given SBF/NMEA sentence. Can be any of the following self-explanatory names: 'msec10', 'msec20', 'msec40', 'msec50', 'msec100', 'msec200', 'msec500', 'sec1', 'sec2', 'sec5', 'sec10', 'sec15', 'sec30', 'sec60', 'min2', 'min5', 'min10', 'min15', 'min30', 'min60'. Defaults to 'sec1'.\n        msg_type (str, optional): ``NMEA`` or ``SBF``. Defaults to ``SBF``.\n        nmea_type (str, optional): name/s of the NMEA sentence/s to be retrieved. If multiple sentences, each sentence string identifier should be preceded by '+', and all the string should be concatenated in one single string (i.e. ``+HDT+GGA``). Defaults to ``+GGA+HDT``.\n        sbf_type (str, optional): name/s of the SBF sentence/s to be retrieved. If multiple sentences, each sentence string identifier should be preceded by '+', and all the string should be concatenated in one single string (i.e. '+PVTCartesian+AttEuler'). Each sentence needs to have a parsing function that is called in ``parse_septentrio_msg`` in the part corresponding to the id of the sentence. Defaults to ``+PVTCartesian+AttEuler``.\n    \"\"\"\n\n    if interface == 'USB' or interface == 'COM':\n        if msg_type == 'SBF':\n            cmd1 = 'setDataInOut, ' + interface + str(self.interface_number) + ',, ' + '+SBF'\n            cmd2 = 'setSBFOutput, Stream ' + str(stream_number) + ', ' + interface + str(self.interface_number) + ', ' +  sbf_type + ', ' + interval\n        elif msg_type == 'NMEA':\n            cmd1 = 'setDataInOut, ' + interface + str(self.interface_number) + ',, ' + '+NMEA'\n            cmd2 = 'sno, Stream ' + str(stream_number) + ', ' + interface + str(self.interface_number) + ', ' + nmea_type + ', ' + interval\n\n    self.stream_info.append({'interface': interface, 'stream_number': stream_number, 'interval': interval, 'msg_type': msg_type})\n\n    self.sendCommandGps(cmd1)\n    self.sendCommandGps(cmd2)\n\n    if self.DBG_LVL_1:\n        print('\\n'+ cmd1)\n        print('\\n'+ cmd2)\n</code></pre>"},{"location":"GpsSignaling/#a2gmeasurements.GpsSignaling.start_thread_gps","title":"<code>start_thread_gps(interface='USB')</code>","text":"<p>Starts the GPS thread responsible for handling I/O communication between the host computer and the Septentrio mosaic-go receiver.</p> <p>Creates the threading Event that is set when the I/O communication must be closed.</p> <p>Parameters:</p> Name Type Description Default <code>interface</code> <code>str</code> <p>is one of the allowed Septentrio interfaces. Current implementation of this class only uses 'USB' interface. Defaults to 'USB'.</p> <code>'USB'</code> Source code in <code>a2gmeasurements.py</code> <pre><code>def start_thread_gps(self, interface='USB'):\n    \"\"\"\n    Starts the GPS thread responsible for handling I/O communication between the host computer and the Septentrio mosaic-go receiver.\n\n    Creates the threading Event that is set when the I/O communication must be closed.\n\n    Args:\n        interface (str, optional): is one of the allowed Septentrio interfaces. Current implementation of this class only uses 'USB' interface. Defaults to 'USB'.\n    \"\"\"\n\n    self.event_stop_thread_gps = threading.Event()\n\n    if interface == 'USB' or interface == 'COM':\n        t_receive = threading.Thread(target=self.serial_receive, args=(self.serial_instance, self.event_stop_thread_gps))\n\n    #elif interface == 'IP':\n    #    t_receive = threading.Thread(target=self.socket_receive, args=(self.event_stop_thread_gps))\n\n    t_receive.start()\n    print('\\n[DEBUG]: Septentrio GPS thread opened')\n    time.sleep(0.5)\n</code></pre>"},{"location":"GpsSignaling/#a2gmeasurements.GpsSignaling.stop_gps_data_retrieval","title":"<code>stop_gps_data_retrieval(stream_number=1, interface='USB', msg_type='+NMEA+SBF')</code>","text":"<p>Stops the streaming of the NMEA/SBF sentences initiated by calling <code>start_gps_data_retrieval</code>. </p> <p>Wrapper of <code>sendCommandGps</code>.</p> <p>Unexpected behaviour to be noted by developers: it seems that if the stream is not stopped by the time the serial connection is closed, then, when the user opens a new serial connection, Septentrio will start sending all the SBF or NMEA messages that were produced between the last time the serial connection was closed and the time it is opened again.</p> <p>Parameters:</p> Name Type Description Default <code>stream_number</code> <code>int</code> <p>number of the stream to be stopped. Defaults to 1.</p> <code>1</code> <code>interface</code> <code>str</code> <p>is one of the allowed Septentrio interfaces. Current implementation of this class only uses 'USB' interface. Defaults to 'USB'.</p> <code>'USB'</code> <code>msg_type</code> <code>str</code> <p>the message type corresponding to the stream <code>stream_number</code>. Options: 'SBF', 'NMEA' or '+NMEA+SBF' or '+SBF+NMEA' (the last two are the same). Defaults to <code>NMEA+SBF</code>.</p> <code>'+NMEA+SBF'</code> Source code in <code>a2gmeasurements.py</code> <pre><code>def stop_gps_data_retrieval(self, stream_number=1, interface='USB', msg_type='+NMEA+SBF'):   \n    \"\"\"\n    Stops the streaming of the NMEA/SBF sentences initiated by calling ``start_gps_data_retrieval``. \n\n    Wrapper of ``sendCommandGps``.\n\n    *Unexpected behaviour to be noted by* **developers**: *it seems that if the stream is not stopped by the time the serial connection is closed, then, when the user opens a new serial connection, Septentrio will start sending all the SBF or NMEA messages that were produced between the last time the serial connection was closed and the time it is opened again*.\n\n    Args:\n        stream_number (int, optional): number of the stream to be stopped. Defaults to 1.\n        interface (str, optional): is one of the allowed Septentrio interfaces. Current implementation of this class only uses 'USB' interface. Defaults to 'USB'.\n        msg_type (str, optional): the message type corresponding to the stream ``stream_number``. Options: 'SBF', 'NMEA' or '+NMEA+SBF' or '+SBF+NMEA' (the last two are the same). Defaults to ``NMEA+SBF``.\n    \"\"\"\n\n    if interface == 'USB' or interface == 'COM':\n        if msg_type == 'SBF':\n            cmd1 = 'setSBFOutput, Stream ' + str(stream_number) + ', ' + interface + str(self.interface_number) + ', none '\n            cmd2 = 'sdio, ' + interface + str(self.interface_number) + ',, -SBF'\n\n            self.sendCommandGps(cmd1)\n            self.sendCommandGps(cmd2)\n        elif msg_type == 'NMEA':\n            cmd1 = 'sno, Stream ' + str(stream_number) + ', ' + interface + str(self.interface_number) + ', none ' \n            cmd2 = 'sdio, ' + interface + str(self.interface_number) + ',, -NMEA'\n\n            self.sendCommandGps(cmd1)\n            self.sendCommandGps(cmd2)\n        elif msg_type == '+NMEA+SBF' or msg_type == '+SBF+NMEA':\n            cmd1 = 'setSBFOutput, Stream ' + str(stream_number) + ', ' + interface + str(self.interface_number) + ', none '\n            cmd2 = 'sdio, ' + interface + str(self.interface_number) + ',, -SBF'\n            cmd3 = 'sno, Stream ' + str(stream_number) + ', ' + interface + str(self.interface_number) + ', none ' \n            cmd4 = 'sdio, ' + interface + str(self.interface_number) + ',, -NMEA'\n\n            self.sendCommandGps(cmd1)\n            self.sendCommandGps(cmd2)       \n            self.sendCommandGps(cmd3)\n            self.sendCommandGps(cmd4)       \n</code></pre>"},{"location":"GpsSignaling/#a2gmeasurements.GpsSignaling.stop_thread_gps","title":"<code>stop_thread_gps(interface='USB')</code>","text":"<p>Stops the GPS thread.</p> <p>Parameters:</p> Name Type Description Default <code>interface</code> <code>str</code> <p>is one of the allowed Septentrio interfaces. Current implementation of this class only uses 'USB' interface. Defaults to 'USB'.</p> <code>'USB'</code> Source code in <code>a2gmeasurements.py</code> <pre><code>def stop_thread_gps(self, interface='USB'):\n    \"\"\"\n    Stops the GPS thread.\n\n    Args:\n        interface (str, optional): is one of the allowed Septentrio interfaces. Current implementation of this class only uses 'USB' interface. Defaults to 'USB'.\n    \"\"\"\n\n    self.event_stop_thread_gps.set()\n    time.sleep(0.1)\n\n    if interface =='USB' or interface == 'COM':\n        self.serial_instance.close()\n\n    elif interface =='IP':\n        self.socket.close()\n\n    print('\\n[DEBUG]: Septentrio GPS thread closed')\n</code></pre>"},{"location":"GuideForGUI/","title":"Guide for using the GUI","text":""},{"location":"GuideForGUI/#initial-recommendations","title":"Initial recommendations","text":"<p>It is recommended to follow the guidelines in this section to start the operation of the air-to-ground channel sounder.</p> <ul> <li> <p>Connect every component of the system as shown in the Figure of section Block Diagram.</p> </li> <li> <p>Turn on both host computers (Manifold and Rasberry Pi).</p> </li> <li>Manually check each component connection, by following what is explained in sections Gimbal to Host Connection, GPS to Host Connection, RFSoC to Host Connection, Host Wifi to Router Connection, RFSoC to Host Ethernet Connection. The software will check which devices are physically connected to the host, but is better to do a double check.</li> <li>If an error is encountered check some common problems in section Troubleshooting.</li> </ul>"},{"location":"GuideForGUI/#definitions","title":"Definitions","text":"<p>For the sake of clarity, we redefine some words that are being used in this document.</p> <ul> <li>Measurement: comprises the channel sounding process from the moment the user presses the <code>START</code> button until <code>STOP</code> is pressed.</li> <li>Experiment: comprises the channel sounding process from the moment the user presses the <code>START</code> button until <code>FINISH</code> is pressed. </li> </ul>"},{"location":"GuideForGUI/#operation","title":"Operation","text":"<p>After opening the A2GMeasurements GUI, the first window that will appear is shown in the following Figure:</p> First window after A2GMeasurements GUI is opened <p>Press the <code>Setup</code> menu:</p> Setup menu opened <p>Then press <code>Setup devices and more</code>:</p> Setup devices and more <p>After that, a Setup window as shown in the following Figure  will appear:</p> Setup window for configuring some parameters <p>Choose the drone gimbal from the available options:</p> Drone gimbal selection <p>NOTE: the Gremsy H16 gimbal option is available but the behaviour of the gimbal is not optimal.</p> <p>Choose along which of its own axis, drone's gimbal should follow ground node movement:</p> drone's gimbal axis following ground node <p>Choose along which of its own axis, ground's gimbal should follow drone node movement:</p> ground's gimbal axis following drone node <p>Choose ground node mobility:</p> ground node mobility <p>If ground node's mobility was <code>Static</code>, the following text boxes will become active. Enter there the coordinates (in decimal degrees) of the ground node:</p> static coordinates for ground node <p>Choose drone node mobility:</p> drone node mobility <p>If drone node's mobility was <code>Static</code>, the following text boxes will become active. Enter there, the coordinates (in decimal degrees) of the drone node:</p> static coordinates for drone node <p>If there is mismatch between the front of the ground gimbal and the GPS attitude baseline (see section Components), enter in the following text box the offset (in degrees). The offset angle is measured as described in the API html in <code>GpsSignaling()</code> and <code>GpsSignaling.setHeadingOffset()</code>:</p> ground node attitude offset for the baseline between gps antennas <p>Finally, press <code>OK</code>:</p> press OK <p>After pressing <code>OK</code>, the main window of the A2GMeasurements app will appear.</p> <p>NOTE: the parameters configured in the Setup window (see Setup Window) are not modifiable until the user presses <code>Disconnect drone</code>. After that, the menu <code>Setup devices and more</code> will be available again.</p>"},{"location":"InfoDevelopers/","title":"Developers guide","text":""},{"location":"InfoDevelopers/#communication-protocol","title":"Communication protocol","text":"<p>It is possible to extend the communication protocol by implementing new functionality in the methods <code>encode_message()</code>, <code>socket_send_cmd()</code> and <code>decode_message()</code> in the class <code>HelperA2GMeasurements</code> of the file <code>a2gmeasurements.py</code>.</p> <p>New functionality means new messages exchanged between both nodes. As to now, there are three types of messages implemented (shown under row <code>message_type</code> in one of the Tables in Communication protocol. New messages introduced by the developer can be short messages without requiring any answer back from the receiver, long messages without requiring the answer from the receiver (long messages make use of the <code>data</code> field of the communication process to send additional data, i.e. a vector with channel impulse response related information), or messages that require an answer from the receiver.</p> <p>Developers need to modify <code>encode_message()</code>, as shown in the following snippet of code:</p> <p>Change encoder to extend available messages</p> <pre><code>def encode_message(self, source_id, destination_id, message_type, cmd, data=None):\n    if message_type == 0x01: \n    //...\n        elif cmd == 0x0A:\n        # INSERT HERE HOW TO ENCODE YOUR NEW MESSAGE IF IT IS A SHORT MESSAGE WITHOUT ANSWER FROM THE RECEIVER\n    elif message_type == 0x02:\n    //...\n        elif cmd == 0x02:\n        # INSERT HERE HOW TO ENCODE YOUR NEW MESSAGE IF IT IS A LONG MESSAGE WITHOUT ANSWER FROM THE RECEIVER\n    elif message_type == 0x03:\n    //...\n        elif cmd == 0x02:\n        # INSERT HERE HOW TO ENCODE YOUR NEW MESSAGE IF IT IS A MESSAGE REQUIRING AN ANSWER FROM THE RECEIVER    \n</code></pre> <p>Then modify <code>decode_message()</code>, as shown in the following snippet:</p> <p>Change decoder to extend available messages</p> <pre><code>def decode_message(self, data):\n    if message_type == 0x01: \n    # ...\n        elif cmd == 0x0A:\n        # INSERT HERE HOW TO DECODE YOUR NEW MESSAGE IF IT IS A SHORT MESSAGE WITHOUT ANSWER FROM THE RECEIVER. # IT SHOULD MATCH THE ENCODING FORMAT\n    elif message_type == 0x02:\n    # ...\n        elif cmd == 0x02:\n        # INSERT HERE HOW TO DECODE YOUR NEW MESSAGE IF IT IS A LONG MESSAGE WITHOUT ANSWER FROM THE RECEIVER\n        # IT SHOULD MATCH THE ENCODING FORMAT\n    elif message_type == 0x03:\n    # ...\n        elif cmd == 0x02:\n        # INSERT HERE HOW TO DECODE YOUR NEW MESSAGE IF IT IS A MESSAGE REQUIRING AN ANSWER FROM THE RECEIVER\n        # IT SHOULD MATCH THE ENCODING FORMAT\n</code></pre> <p>Finally, modify <code>socket_send_cmd()</code>. This method is a wrapper for the <code>encode_message()</code> method, and assigns a string name to each message, so that it is easier to identify them:</p> <p>Change socket sender to extend available messages</p> <pre><code>def socket_send_cmd(self, type_cmd=None, data=None):\n    if type_cmd == 'SETGIMBAL': \n    # ...\n    elif type_cmd == '': # ENTER HERE THE NAME WITH WHICH YOU WILL IDENTIFY THE NEW MESSAGE\n        frame = self.encode_message(source_id= , destination_id= ,message_type= , cmd= , data= ,) \n        # FILL THE PREVIOUS LINE WITH THE CORRESPONDING INFORMATION FOR THE NEW MESSAGE\n</code></pre>"},{"location":"InfoDevelopers/#web-app","title":"Web app","text":"<p>If it is of interest of the developer to migrate all the functionality done in PyQt5 (comprised in the files mentioned in section Files in directory ), to a web application, a starting point can be the web application developed to control the DJI Ronin RS2 gimbal. </p> <p>The web application was done using the Django framework, and its backbone (the directory structure shown as follows) can be further extended if it is required.</p> <pre><code>.\n|- a2gmeasurements\n |- GimbalRS2WebApp\n  |- gimbalcontrol  \n   |- migrations\n    |- __init__.py\n    |- 0001_initial.py\n   |- static\n    |- css\n     |- bootstrap.min.css\n     |- styles.css\n    |- js\n     |- bootstrap.min.js\n   |- templates\n    |- automatic_move.html\n    |- base_generic.html\n    |- bs4_form.html\n    |- index.html\n    |- manual_move.html\n   |- __init__.py\n   |- admin.py\n   |- apps.py\n   |- forms.py\n   |- models.py\n   |- tests.py\n   |- urls.py\n   |- views.py\n  |- webAppRS2\n   |- __init__.py\n   |- asgi.py\n   |- settings.py\n   |- urls.py\n   |- wsgi.py\n  | manage.py\n</code></pre> <p>Extending this web app mainly requires to modify the files <code>forms.py</code>, <code>models.py</code>, <code>urls.py</code>, <code>views.py</code> and add the new html files (responsible for all the user interface functionality) under the <code>templates</code> directory, the new css files (if any) to the <code>css</code> directory, and the new javascript files (if any) to the <code>js</code> directory.</p>"},{"location":"InfoDevelopers/#gremsy-h16-gimbal","title":"Gremsy H16 gimbal","text":"<p>If Gremsy H16 gimbal must be used as drone's gimbal, this section provides useful information to understand the classes <code>GimbalGremsyH16</code> and <code>SBUSEncoder</code> responsible to control gimbal's orientation (yaw, pitch, roll). Information about the classes is provided in the html document containing information about all the API developed.</p> <p>It is required a TTL-to-USB \"bridge\" to connect the host computer with the sbus port of the gimbal. There are different manufacturer specifications for the SBUS protocol. For this one, an inverter of the Tx Uart signal is required (due to this sbus specification, it is required to invert the normal idle voltage level in UART communication; more on this is found later in this section).</p> <p>The data field of the sbus protocol is the Remote Control (RC) control value used by most of the RC vendors (i.e. FrSky, flysky, ...): a value in the range [-100, 100] that is equivalent to the angular speed at which the gimbal will move. Another data field controls which axis (yaw, pitch or roll) is moved using either the throttle, aileron, rudder or elevation channels of a conventional RC. With this being said, the angle (either yaw, pitch or roll) is controlled then by the RC control value (equivalent to speed) and the time the sbus protocol will hold that value.</p> <p>Due to the fact that the RC control value is not actually a speed value, a characterization of the angle (yaw, pitch or roll) dependence on this RC control value and time, is needed. </p> <p>As it is not possible to access Gremsy gimbal's controller (and thus its IMU) an external IMU is required to read gimbal's angle for the characterization. Alternatively, the characterization can be done as described in what follows without the need of an external IMU. </p>"},{"location":"InfoDevelopers/#characterization-of-gremsy-h16-angle-dependece-on-the-rc-control-value-and-the-time-holding-it","title":"Characterization of Gremsy H16 angle dependece on the RC control value and the time holding it","text":"<p>NOTE: this characterization was designed before the arrival of an external IMU. The angle characterization can be done in an easier manner by using the external IMU, a cheap host MCU (i.e. a Raspberry Pi Pico running CircuitPython with an implemented function reading IMU values is available) and the methods <code>start_imu_thread</code>, <code>receive_imu_data</code>, <code>stop_thread_imu</code> of the class <code>GimbalGremsyH16</code> (described in the API html document).</p> <p>In the following Figure it is shown an illustration of the measurement setup from a top view. The point where all lines collide is the beginning of the laser beam. The ticks that appear in the wall are marks of 10 cm. </p> Illustration of lines between the laser beam at the gimbal and the regular ticks at the wall <p>For each of the triangles in the previous Figure, we can obtain the angles \\(\\alpha, \\beta, \\gamma\\) defined in Figure Angle distances. The distances \\(a_{i}, a_{i+1}, b_{i}, \\: i=1,\\;...,\\;12\\), are known and are shown in the following Table. </p> No. \\(a_{i}\\) [m] \\(a_{i+1}\\) [m] \\(b_{i}\\) [m] \\(\\alpha_{i}\\) [deg] \\(\\beta_{i}\\) [deg] \\(\\gamma_{i}\\) [deg] 1 1.985 1.955 0.1 2.77 71.16 106.06 2 1.955 1.93 0.1 2.85 74.09 103.04 3 1.93 1.91 0.1 2.92 77 100.07 4 1.91 1.895 0.1 2.97 79.88 97.13 5 1.895 1.884 0.1 3.01 82.17 94.8 6 1.884 1.878 0.1 3.04 85.04 91.91 7 1.878 1.879 0.1 3.05 89.04 87.9 8 1.879 1.882 0.1 3.04 90.19 86.75 9 1.882 1.892 0.1 3.02 94.22 82.75 10 1.892 1.906 0.1 2.98 96.55 80.46 11 1.906 1.926 0.1 2.93 100.06 77 12 1.926 1.949 0.1 2.87 101.06 75.26 <p>From those distances the angles are obtained by solving the following 3 equations.</p> \\[ \\cos(\\alpha_{i}) = \\frac{a_{i}^2 + a_{i+1}^2 - b_{i}^2}{2a_{i} a_{i+1}} \\] \\[ \\cos(\\beta_{i}) = \\frac{b_{i}^2 + a_{i}^2 - a_{i+1}^2}{2b_{i} a_{i}} \\] \\[ \\cos(\\gamma_{i}) = \\frac{b_{i}^2 + a_{i+1}^2 - a_{i}^2}{2b_{i} a_{i+1}} \\] Zoom-in at one of the \"triangles\" defined in the previous Figure"},{"location":"InfoDevelopers/#sbus-encoder","title":"SBUS Encoder","text":"<p>The SBUS encoder at the host computer mimics the behaviour of a Remote Controller (RC) transmitter. Specifically, it mimics the behaviour of the transmitter for which a X8R FrSky receiver is paired.</p> <p>The X8R FrsKy frame is encoded in the SBUS protocol. It is a serial protocol that uses regular UART communication, where a packet is composed by a start bit in '1', 2 stop bit in '0', even parity (meaning '1' when even number of '1's in data) and 8 bits of data. High voltage is '1' and low voltage is '0'. The RC values of the channels, for instance throttle, rudder, elevation and aileron  (besides other possible channels) are encoded into 11 bits (meaning more than 1 UART packet). </p> <p>No receivers besides the FrSky were used, but it is highly probable that those 11 bits are used in different manners by different manufacturers (and even within the same manufacturer, there might be used differently for different receivers). Some might use MSB or LSB. And each of them might map in a different way the channel values from the RC TX (throttle, rudder, elevation and aileron channel values lie within the interval [-100, 100] in the RC TX) to the actual 11 bit representation (i.e.: is the -100 value a 0 in 16-bit unsigned integer representation or is it a -100 in 16-bit signed integer representation or is it any other value they use for specific reasons?). </p> <p>Since the range of unsigned integers one can get with 11 bits starts in 0 and ends in 2047, an intuitive encoding of the [-100, 100] would be using 0 for -100 and 2047 for 100. However, it has been seen in forums of different receivers that not always the manufacturer is interested in using the full [0, 2047] scale for the 11 bits. </p> <p>Furthermore, the mapping between the other RC channel values lying within (-100, 100) to the 11 bit representation might not be linear. </p> <p>The 11 bit were measured with an oscilloscope at the X8R receiver for the case when the RC TX was sending a -99, -50, 0, 50, 100. Figure \\ref{fig:x8r_osc_values} shows the 8-bit data values for each of the 25 channels sent by the RC TX.</p> Python dictionaries for different values of a given channel at the RC TX. 'A' refers to the Aileron channel, 'E' for Elevation, 'T' for Throttle and 'R' for Rudder. In this case the channel that was changed at the RC TX was 'A', but the same procedure applies to either 'E', 'R' or 'T'. The numbers '1', '2', ... '25' are the 22 channels that conform a SBUS frame, excluding the SYNC ('1') and 2 STOP packets ('24, '25)"},{"location":"InfoDevelopers/#drifting","title":"Drifting","text":"<p>When the gimbal is controlled remotely (Lock Mode) there is a drift towards the right w.r.t to the reference along the azimuth axis. Rudder (azimuth) positive values make the gimbal move to the left, while negative values make the gimbal move to the right.</p> <p>The value of the drifting towards the right is \\(\\frac{10}{30} \\frac{cm}{s}\\).</p> <p>The SBUS encoder at the host computer is periodically (periodicity has been test for the interval 9-20ms) sending a frame to the gimbal with the channel values. The channels that are of our interest are rudder (or the RC channel -throttle, rudder, elevation, aileron- used for azimuth) and the elevation (or the RC channel -throttle, rudder, elevation, aileron- used for elevation). </p>"},{"location":"InfoDevelopers/#counter-the-right-drift-by-setting-a-non-zero-rudder-azimuth-for-gimbal-rest","title":"Counter the right drift by setting a non-zero rudder (azimuth) for gimbal rest","text":"<p>When the gimbal stops moving, by the default, the frame sent periodically has a 0 in the elevation and azimuth channels. This makes sense, since the 0 in both channels means that the gimbal should not move. However, since there is a drift towards the right in the azimuth axis, we can counter it by instead of sending a 0, send a value (such that the gimbal moves towards the left) when the gimbal is supposed to rest. </p> <p>The lowest value for rudder (azimuth) experimentally found to counter the drifting towards the right in azimuth is <code>LOW_SPEED_COUNTER = 8.74601226993865933</code>. By lowest it is meant the following:</p> <p>If you take the rudder value <code>NOT_COUNTER_SPEED = 8.74601226993865932</code>, any rudder value <code>SPEED &lt;= NOT_COUNTER_SPEED</code> will not counter the drifting towards the right. This means for any of those values, the gimbal will still have a drift of \\(\\frac{10}{30}\\frac{cm}{s}\\) to the right. </p> <p>However, when <code>LOW_SPEED_COUNTER</code> is used as the value periodically sent for the rudder (azimuth) channel, what happens is that the gimbal starts to drift to the left.</p> <p>With <code>LOW_SPEED_COUNTER</code> used as the value for the rudder channel when we want the gimbal to stay at its position, the drifting is about \\(\\frac{10}{75}\\frac{cm}{s}\\) to the LEFT.</p> <p>This means that the actual rudder value <code>REAL_COUNTER_SPEED</code> that counters the drifting to the right lies within <code>NOT_COUNTER_SPEED &lt; REAL_COUNTER_SPEED &lt; LOW_SPEED_COUNTER</code>.</p> <p>However, the value <code>REAL_COUNTER_SPEED</code> might be an irrational number, meaning it requires infinite decimals for representation. Since that is not possible, the counter for the drifting has to be achieved in another way.</p>"},{"location":"InfoDevelopers/#counter-drift-by-toggling-rudder-value-for-gimbal-rest","title":"Counter drift by toggling rudder value for gimbal rest","text":"<p>It is possible to reduce further the drift by considering the following.</p> <p>Given a time \\(\\Delta t\\) that can be interpreted as an interval of time during which the gimbal drifts, the gimbal will move an amount of \\(\\Delta x\\) in millimeters</p> \\[ \\Delta x = pv_{1} \\Delta t + q v_{2} \\Delta t     \\] <p>in the interval \\(T\\) in seconds</p> \\[ T = p \\Delta t + q \\Delta t   \\] <p>where \\(p, q\\) are integers, \\(v_{1} = \\frac{100}{75} \\frac{mm}{s}\\) is the drifting velocity after setting a non-zero rudder for gimbal rest, and \\(v_{2} = - \\frac{100}{30} \\frac{mm}{s}\\) is the drifting velocity when a zero-rudder value is set for gimbal rest.</p> <p>As a consequence of this, the resulting drifting velocity \\(v_{DRIFT}\\) in millimeters per second, would be</p> \\[ v_{DRIFT} = \\frac{\\Delta x}{T} = \\frac{pv_{1} \\Delta t + qv_{2} \\Delta t}{p \\Delta t + q \\Delta t} = \\frac{pv_{1} + qv_{2}}{p+q} \\] <p>We can find values for \\(p\\) and \\(q\\) such that \\(\\Delta t = 0\\). Such values satisfy the relationship:</p> \\[ pv_{1} = - qv_{2} \\: \\: \\:  \\rightarrow  \\: \\: \\: 2p = 5q \\rightarrow p = \\frac{5}{2} q \\] <p>Since \\(p, q\\) are integers values that represent the number of \\(\\Delta t\\) times we move with speed \\(v_{1}, v_{2}\\) respectively, we choose \\(q\\), such that \\(p\\) is an integer. </p> <p>For example, choosing \\(q = 2\\) gives \\(p = 5\\), and what this means is that for each 7\\(\\Delta t\\) periods of time, the rudder value for when the gimbal rests, will be \\texttt{LOW_SPEED_COUNTER} during 5\\(\\Delta t\\) seconds (corresponding to a drift towards the left of \\(v_{1}\\)), and 0 during 2\\(\\Delta t\\) seconds (corresponding to a drift towards the right of \\(v_{2}\\).</p> <p>Now, \\(\\Delta t\\) can be any value, but, as for the SBUS protocol there is the need to send a frame each given time (i.e. 10 ms), this period we set to periodically send that frame corresponds to \\(\\Delta t\\). </p> <p>However, this last choice requires further revision of previous equations. It will happen that since this is implemented in software, the period \\(\\Delta t\\) is not always the same. We can revisit the equations by considering that, if the period jitter is not big (is a fraction of the real assumed period), \\(\\Delta t\\) for any of the two speeds is slightly different:</p> \\[ \\Delta x = pv_{1} \\Delta t + q v_{2} k \\Delta t  \\] <p>where \\(0&lt;k&lt;2\\). A value of \\(k = 0.1\\) means that the actual period during which the velocity was \\(v_{2}\\) was 0.1 times the period during which velocity was \\(v_{1}\\), and a value of \\(k = 1.9\\) means that the actual period during which the velocity was \\(v_{2}\\) was 90\\(\\%\\) longer than the period during which velocity was \\(v_{1}\\).</p> <p>In practice, it is hard to have control over this period mismatch. What this means is that the value of \\(k\\) can't be predicted easily, and will vary between a value lower than 1 and a value higher than 1 (but lower to 2).</p>"},{"location":"InfoDevelopers/#connections-handling","title":"Connections handling","text":"<p>To modify the layout of the panel modify  the method <code>create_check_connections_panel()</code>.</p> <p>If any bug encounter (or the developer wants to extend any functionality) in the methods used to check the connections between the devices and each node, modify one of the following functions (the one/s corresponding to the device/s) : <code>check_if_ssh_2_drone_reached()</code>,  <code>check_if_drone_fpga_connected()</code>, <code>check_if_gnd_fpga_connected()</code>, <code>check_if_drone_gimbal_connected()</code>, <code>check_if_gnd_gimbal_connected()</code>, <code>check_if_server_running_drone_fpga()</code>, <code>check_if_server_running_gnd_fpga()</code>, <code>check_if_gnd_gps_connected()</code>, <code>check_if_drone_gps_connected()</code>.</p> <p>To modify any implemented functionality in the panel (i.e. if the developer wants that the <code>Connect</code> button is activated only when both RFSoCs are detected, ...) modify the callbacks <code>check_status_all_devices()</code>, <code>connect_drone_callback()</code> and <code>disconnect_drone_callback()</code> corresponding to the buttons <code>Check</code>, <code>Connect</code> and <code>Disconnect</code> respectively. </p> <p>Also might be necessary to modify the method <code>create_class_instances()</code> called under some conditions after pressing the <code>Connect</code> button.</p>"},{"location":"MeasurementSystem/","title":"Measurement system","text":""},{"location":"MeasurementSystem/#components","title":"Components","text":"<p>HERE GOES PICTURES OF THE GIMBALS, etc. Draw on the pictures some important definitions, for example, </p> <p>Show which is the \"front\" of the gimbal RS2.</p> <p>Show which is the \"GPS attitude baseline\". Which is the \"longitudinal\" axis.</p>"},{"location":"MeasurementSystem/#block-diagram","title":"Block diagram","text":"<p>The system is composed by two nodes (the ground node and the air/drone node) that communicate with each other through IEEE 802.11 ac. </p> <p>Each node contains a set of devices connected to it, and managed by a host computer. A diagram of the devices connected to each node is shown in the following Figure.</p> Host computer and devices connected to it for each node <p>The specific devices used for each of the components in the previous Figure are shown in the next Table. </p> Type device Device used Host computer (ground) Raspberry Pi 4B Host computer (air) DJI Manifold 2-C Gimbal DJI Ronin RS2 PCAN \"bridge\" DJI Ronin Focus Wheel + PEAK system PCAN-USB GPS Septentrio mosaic-go heading evaluation kit RFSoC board Xilinx RFSoC 2 x 2 Kit WiFi Txr (ground) Raspberry Pi 4B integrated IEEE 802.11ac WiFi Txr (air) TP Link Archer T4U RF System Sivers EVK06002 + Sivers TRX BF/01 RFIC <p>In addition to the mentioned devices, we use a TP-Link AX1500 5GHz router as an access point for both nodes. The router is already configured to assign specific static addresses to each node (see Connection Router).</p>"},{"location":"MeasurementSystem/#files-in-directory","title":"Files in directory","text":"<p>The main files where most of the system functionality is implemented are:</p> <ul> <li> <p><code>a2gmeasurements.py</code>: this file has all the functionality related with operating, controlling and collecting information from the devices. It comprises the classes <code>GimbalRS2</code>, <code>GpsSignaling</code>, <code>myAnritsuSpectrumAnalyzer</code>, <code>HelperA2GMeasurements</code>, <code>GimbalGremsyH16</code>, <code>SBUSEncoder</code> and <code>RFSoCRemoteControlFromHost</code> among others. See the available API in API Reference Gimbal, API Reference GPS, API Reference RFSoC, API Reference Communication.</p> </li> <li> <p><code>GUI_A2G_MEAS.py</code>: this file has all the functionality related with the Graphical User Interface (GUI). It calls methods from <code>a2gmeasurements.py</code> to manipulate the devices by using the GUI. </p> </li> <li> <p><code>drone_main.py</code>: this is a script that setup the devices and the wireless connection at the air node.    </p> </li> <li> <p><code>a2gUtils.py</code>: this file contains few auxiliary (general purpose) methods that are used by other files previously mentioned. It is required for both nodes. If the developer wants to follow the file structure already used, they can extend this file by adding any auxiliary or general purpose functionality that is not specifically related to the devices used, i.e. some type of mathematical computation, memory management, etc.</p> </li> <li> <p><code>docs/</code>: this folder contains the documentation for this project.</p> </li> </ul> <p>The files <code>a2gmeasurements.py</code> and <code>a2gUtils.py</code> must be placed in the working directories of each node's host computer.</p> <p>The file <code>GUI_A2G_MEAS.py</code> is only required to be placed in the working directory of the ground node's host computer.</p> <p>The file <code>drone_main.py</code> is only required to be placed in the working directory of the air node's host computer.</p>"},{"location":"MeasurementSystem/#gimbalrs2-to-host-connection","title":"GimbalRS2 to host connection","text":"<p>Connect the CAN port of the gimbal RS2 to any USB port of the host computer, using the DJI Ronin Focus Wheel and the PEAK System PCAN-USB bridge, as indicated in the following Figure.</p> Connection between the gimbal RS2 and the host"},{"location":"MeasurementSystem/#gps-to-host-connection","title":"GPS to host connection","text":"<p>Connect the USB port from the Septentrio gps to any USB port of the host computer, as indicated in Figure.</p> Connection between the GPS and the host <p>DO NOT use the port named <code>REC-USB</code> of the Septentrio gps.</p>"},{"location":"MeasurementSystem/#rfsoc-to-host-connection","title":"RFSoC to host connection","text":"<p>Connect any of the RFSoC Ethernet ports to any of th Ethernet ports of the host computer, as indicated in the following Figure.</p> Connection between the RFSoC and the host"},{"location":"MeasurementSystem/#host-wifi-to-router-connection","title":"Host WiFi to router connection","text":"<p>To guarantee that the connection between each of the host computers (Manifold and Raspberry or their replacements) to the router is done through the 5GHz network, we have only enabled the 5GHz band in the router configuration website.</p> <ul> <li> <p>The website to configure the router is the address: <code>192.168.0.1</code></p> </li> <li> <p>The password to login is: jvvtt2937</p> </li> </ul> <p>In order to automatize the connections between both host computers, the TP-Link AX1500 5GHz Router has been configured so that the IP addressing of the DHCP server assigns always the same IP address to the host computers (Manifold and Raspberry) identified by their MAC addresses.</p> <ul> <li> <p>The IP address of the drone host computer (Manifold) has been set to: <code>192.168.0.157</code></p> </li> <li> <p>The IP address of the ground host computer (Raspberry) has been set to: <code>192.168.0.124</code></p> </li> </ul>"},{"location":"MeasurementSystem/#ethernet-rfsoc-to-host-connection","title":"Ethernet RFSoC to host connection","text":"<p>Open a terminal or command line in the host computer. Type the following command:</p> <p>Connect to RFSoC</p> <p>ssh xilinx@10.1.1.30 // the address of the node to be checked</p> <p>When asked for password, type: </p> <p>Enter password</p> <p>xilinx</p> <p>This will allow you to use the command line of the RFSoC from the host computer.</p>"},{"location":"NodesCommunication/","title":"HelperA2GMeasurements","text":"Communication between the nodes handler <p>             Bases: <code>object</code></p> <p>Python class for handling the interaction between the multiple devices available in the system: gps, gimbal and rfsoc.</p> <p>It creates instances of each class handling one of those devices (i.e. GimbalRS2, GpsSignaling).</p> <p>It creates a wireless TCP connection between the host computers of both nodes (air and ground node) to control devices and retrieve information from them.</p> <p>It creates a thread (called here communication thread) to handle the communication between the host computers of both nodes.</p> <ul> <li> <p><code>MAX_TIME_EMPTY_SOCKETS</code>: the maximum allowed time to wait if no information was sent over a socket.</p> </li> <li> <p><code>CONN_MUST_OVER_FLAG</code>: a (boolean) flag indicating whether to close or not the connection between the host computers.</p> </li> <li> <p><code>drone_fm_flag</code>: a (boolean) flag set at the GUI indicating whether the air node's gimbal should follow the ground node. In all our documentation, a gimbal is said to be in \"follow mode\" (don't confuse with DJI's RS2 camera-based follow mode) if it follows the other node. </p> </li> <li> <p><code>PAP_TO_PLOT</code>: a numpy array (of size defined in the method <code>pipeline_operations_rfsoc_rx_ndarray</code>of the class <code>RFSoCRemoteControlFromHost</code>) used to plot the Power Angular Profile (PAP) of the wireless channel in GUI's PAP Panel.</p> </li> </ul> Source code in <code>a2gmeasurements.py</code> <pre><code>class HelperA2GMeasurements(object):\n    \"\"\"\n    Python class for handling the interaction between the multiple devices available in the system: gps, gimbal and rfsoc.\n\n    It creates instances of each class handling one of those devices (i.e. GimbalRS2, GpsSignaling).\n\n    It creates a wireless TCP connection between the host computers of both nodes (air and ground node) to control devices and retrieve information from them.\n\n    It creates a thread (called here communication thread) to handle the communication between the host computers of both nodes.\n\n    * ``MAX_TIME_EMPTY_SOCKETS``: the maximum allowed time to wait if no information was sent over a socket.\n\n    * ``CONN_MUST_OVER_FLAG``: a (boolean) flag indicating whether to close or not the connection between the host computers.\n\n    * ``drone_fm_flag``: a (boolean) flag set at the GUI indicating whether the air node's gimbal should follow the ground node. In all our documentation, a gimbal is said to be in \"follow mode\" (don't confuse with DJI's RS2 camera-based follow mode) if it follows the other node. \n\n    * ``PAP_TO_PLOT``: a numpy array (of size defined in the method ``pipeline_operations_rfsoc_rx_ndarray``of the class ``RFSoCRemoteControlFromHost``) used to plot the Power Angular Profile (PAP) of the wireless channel in GUI's PAP Panel.\n    \"\"\"\n    def __init__(self, ID, SERVER_ADDRESS, \n                 DBG_LVL_0=False, DBG_LVL_1=False, \n                 IsGimbal=False, IsGPS=False, IsSignalGenerator=False, IsRFSoC=False,\n                 rfsoc_static_ip_address=None, #uses the default ip_adress\n                 F0=None, L0=None,\n                 SPEED=0,\n                 GPS_Stream_Interval='msec500', AVG_CALLBACK_TIME_SOCKET_RECEIVE_FCN=0.001,\n                 operating_freq=57.51e9,\n                 heading_offset=0):\n        \"\"\"\n        Creates instances of classes ``GimbalRS2`` (or ``GimbalGremsyH16``), ``GpsSignaling``, ``RFSoCRemoteControlFromHost`` to control these devices.\n\n        Args:\n            ID (str): either 'DRONE' or 'GND'.\n            SERVER_ADDRESS (str): the IP address of the ground station.\n            DBG_LVL_0 (bool, optional): if set, prints some low-level messages usefull for debugging. Defaults to False.\n            DBG_LVL_1 (bool, optional): if set, prints some higher-level messages usefull for debugging. Defaults to False.\n            IsGimbal (bool, optional): 0 or FALSE, when no gimbal is physically connected to this host computer; 1, when a Ronin RS2 is physically connected; 2, when a Gremsy H16 is physically connected. Defaults to False.\n            IsGPS (bool, optional): True if a gps is physically connected to this host computer. False otherwise. Defaults to False.\n            IsSignalGenerator (bool, optional): True if a signal generator controlled by pyvisa commands is physically connected to this host computer. False otherwise. Defaults to False.\n            IsRFSoC (bool, optional): True if an RFSoC is physically connected to this host computer. False otherwise. Defaults to False.\n            rfsoc_static_ip_address (str, optional): IP address of the RFSoC connected to this host computer. Defaults to None.\n            L0 (float, optional): parameter of the signal generator. Defaults to None.\n            SPEED (int, optional): the speed of the node in m/s. If this node is GROUND it should be 0 (gnd node does not move) as it is by default. This parameter ONLY incides in raising a warning debug print when the speed of the node is higher than the time difference between consecutive SBF sentences. NOT a crutial parameter at all. Stays here for back compatibility. Defaults to 0.\n            GPS_Stream_Interval (str, optional): time interval used for the retrieving of the configured SBF sentences in Septentrio's receiver connected to this host computer. A list of available options is shown in ``start_gps_data_retrieval`` of class ``GpsSignaling``. Defaults to 'msec500'.\n            AVG_CALLBACK_TIME_SOCKET_RECEIVE_FCN (float, optional): approximated time between calls of the communication thread. This parameter is used in conjunction with ``MAX_TIME_EMPTY_SOCKETS`` to raise an exception when neither side of the communication link is sending any message. Unfortunately, this is a very simple estimate, since the actual time between calls depends on many factors and is does not remain constant between calls. Defaults to 0.001.\n            operating_freq (_type_, optional): operating frequency of the Sivers RF-frontend. The range of defined frequencies is defined in the \"User Manual EVK06002\" of the Sivers EVK (57-71 GHz). Defaults to 57.51e9.\n            heading_offset (int, optional): heading offset (check its definition in the ``GpsSignaling.setHeadingOffset`` method). Defaults to 0.\n        \"\"\"\n\n        self.AVG_CALLBACK_TIME_SOCKET_RECEIVE_FCN = AVG_CALLBACK_TIME_SOCKET_RECEIVE_FCN\n        self.MAX_TIME_EMPTY_SOCKETS = 20 # in [s]\n        self.MAX_NUM_RX_EMPTY_SOCKETS = round(self.MAX_TIME_EMPTY_SOCKETS / self.AVG_CALLBACK_TIME_SOCKET_RECEIVE_FCN)\n        self.rxEmptySockCounter = 0\n\n        self.ID = ID\n        self.SERVER_ADDRESS = SERVER_ADDRESS  \n        self.SOCKET_BUFFER = []\n        self.DBG_LVL_0 = DBG_LVL_0\n        self.DBG_LVL_1 = DBG_LVL_1\n        self.IsGimbal = IsGimbal\n        self.IsGPS = IsGPS\n        self.IsRFSoC = IsRFSoC\n        self.IsSignalGenerator = IsSignalGenerator\n        self.ERR_HELPER_CODE_GPS_HEAD_UNRELATED_2_COORD = -7.5e3 \n        self.ERR_HELPER_CODE_GPS_NOT_KNOWN_DATUM = -8.5e3\n        self.ERR_HELPER_CODE_BOTH_NODES_COORDS_CANTBE_EMPTY = -9.5e3\n        self.SPEED_NODE = SPEED # m/s\n        self.CONN_MUST_OVER_FLAG = False # Usefull for drone side, as its script will poll for looking if this is True\n        self.PAP_TO_PLOT = []\n        self.drone_fm_flag = False\n\n        print(IsGPS, self.IsGPS)\n\n        if IsRFSoC:\n            self.myrfsoc = RFSoCRemoteControlFromHost(operating_freq=operating_freq, rfsoc_static_ip_address=rfsoc_static_ip_address)\n            print(\"[DEBUG]: Created RFSoC class\")\n        if IsGimbal == 1: # By default, the TRUE value is GimbalRS2\n            self.myGimbal = GimbalRS2()\n            self.myGimbal.start_thread_gimbal()\n            time.sleep(0.5)\n            print(\"[DEBUG]: Created Gimbal class\")\n        elif IsGimbal == 2:\n            self.myGimbal = GimbalGremsyH16()\n            self.myGimbal.start_thread_gimbal()\n            print(\"[DEBUG]: Created Gimbal class\")\n        else: # IsGimbal = False\n            print(\"[DEBUG]: No gimbal class is created\")\n        if IsGPS:\n            self.mySeptentrioGPS = GpsSignaling(DBG_LVL_2=True, DBG_LVL_1=False, DBG_LVL_0=False)\n            print(\"[DEBUG]: Created GPS class\")\n            self.mySeptentrioGPS.serial_connect()\n\n            if self.mySeptentrioGPS.GPS_CONN_SUCCESS:\n                self.mySeptentrioGPS.serial_instance.reset_input_buffer()\n\n                # Set the heading offset if any\n                self.mySeptentrioGPS.setHeadingOffset(heading_offset)\n\n                if self.ID == 'DRONE':\n                    self.mySeptentrioGPS.start_gps_data_retrieval(stream_number=1,  msg_type='SBF', interval=GPS_Stream_Interval, sbf_type='+PVTCartesian+AttEuler')\n                elif self.ID == 'GROUND':\n                    self.mySeptentrioGPS.start_gps_data_retrieval(stream_number=1,  msg_type='SBF', interval=GPS_Stream_Interval, sbf_type='+PVTCartesian+AttEuler')\n                print(\"[DEBUG]: started gps stream\")\n                #self.mySeptentrioGPS.start_gps_data_retrieval(msg_type='NMEA', nmea_type='GGA', interval='sec1')\n                self.mySeptentrioGPS.start_thread_gps()\n                time.sleep(0.5)\n        if IsSignalGenerator:\n            rm = pyvisa.ResourceManager()\n            inst = rm.open_resource('GPIB0::19::INSTR')\n            self.inst = inst\n            self.inst.write('F0 ' + str(F0) + ' GH\\n')\n            self.inst.write('L0 ' + str(L0)+ ' DM\\n')\n            time.sleep(0.5)\n\n    def gimbal_follows_drone(self, heading=None, lat_ground=None, lon_ground=None, height_ground=None, \n                                    lat_drone=None, lon_drone=None, height_drone=None, fmode=0x00):\n        \"\"\"\n        Computes the yaw, pitch and roll angles required to move the gimbal in this node towards the other node.\n\n        The caller of this function must guarantee that if ``self.ID == 'GROUND'``, the arguments passed to this function are drone coords. The ground coords SHOULD NOT be passed as they will be obtained from this node Septentrio's receiver.\n\n        The caller of this function must guarantee that if ``self.ID == 'DRONE'``, the arguments passed to this function are ground coords. The drone coords SHOULD NOT be passed as they will be obtained from this node Septentrio's receiver.\n\n        If ``IsGPS`` is False (no GPS connected), then ``heading``, ``lat_ground``, ``lon_ground``, ``height_ground``, ``lat_drone``, ``lon_drone``, ``height_drone`` must be provided. \n\n        In that case, all coordinates provided must be geodetic (lat, lon, alt).\n\n        Args:\n            heading (float, optional): angle between [0, 2*pi] (rads) corresponding to the heading of the line between the two antennas connected to Septentrio's receiver in this node. Defaults to None.\n            lat_ground (float, optional): latitude of the GPS antenna 1 connected to Septentrio's receiver at the GROUND node. Defaults to None.\n            lon_ground (float, optional): longitude of the GPS antenna 1 connected to Septentrio's receiver at the GROUND node. Defaults to None.\n            height_ground (float, optional): height of the GPS antenna 1 connected to Septentrio's receiver at the GROUND node. Assuming both antennas are placed at the same height, is the altitude (in meters above sea level) of the either of the antennas. Defaults to None.\n            lat_drone (float, optional): latitude of the GPS antenna 1 connected to Septentrio's receiver at the DRONE node. Defaults to None.\n            lon_drone (float, optional): longitude of the GPS antenna 1 connected to Septentrio's receiver at the DRONE node. Defaults to None.\n            height_drone (float, optional): height of the GPS antenna 1 connected to Septentrio's receiver at the DRONE node. Assuming both antennas are placed at the same height, is the altitude (in meters above sea level) of the either of the antennas. Defaults to None.\n            fmode (hexadecimal, optional): defines if the gimbal will follow the other node in Azimuth, elevation or both of them. Options are: 0x00, for Azimuth and elevation; 0x01, for Elevation, 0x02, for Azimuth. Defaults to 0x00.\n\n        Returns:\n            yaw_to_set (int, optional): yaw angle to be set at the gimbal of this node, in degrees multiplied by 10 and rounded to the closest integer (i.e. a yaw to set of 45.78 degrees is returned as the yaw value 458)\n            pitch_to_set(int, optional): pitch angle to be set at the gimbal of this node, to follow the other node. The actual value is the angle value in degrees multiplied by 10 and rounded to the closest integer (i.e. a yaw to set of 45.78 degrees is returned as the yaw value 458).\n        \"\"\"\n\n        if self.IsGPS:\n            if fmode == 0x00 or fmode == 0x02:\n                coords, head_info = self.mySeptentrioGPS.get_last_sbf_buffer_info(what='Both')\n\n                if coords['X'] == self.mySeptentrioGPS.ERR_GPS_CODE_BUFF_NULL:\n                    return self.mySeptentrioGPS.ERR_GPS_CODE_BUFF_NULL, self.mySeptentrioGPS.ERR_GPS_CODE_BUFF_NULL, self.mySeptentrioGPS.ERR_GPS_CODE_BUFF_NULL\n                elif coords['X'] == self.mySeptentrioGPS.ERR_GPS_CODE_SMALL_BUFF_SZ:\n                    return self.mySeptentrioGPS.ERR_GPS_CODE_SMALL_BUFF_SZ, self.mySeptentrioGPS.ERR_GPS_CODE_SMALL_BUFF_SZ, self.mySeptentrioGPS.ERR_GPS_CODE_SMALL_BUFF_SZ\n                else:\n                    heading = head_info['Heading']\n                    time_tag_heading = head_info['TOW']\n                    time_tag_coords = coords['TOW']\n                    datum_coordinates = coords['Datum']\n            elif fmode == 0x01:\n                coords = self.mySeptentrioGPS.get_last_sbf_buffer_info(what='Coordinates')\n\n                if coords['X'] == self.mySeptentrioGPS.ERR_GPS_CODE_BUFF_NULL:\n                    return self.mySeptentrioGPS.ERR_GPS_CODE_BUFF_NULL, self.mySeptentrioGPS.ERR_GPS_CODE_BUFF_NULL, self.mySeptentrioGPS.ERR_GPS_CODE_BUFF_NULL\n                elif coords['X'] == self.mySeptentrioGPS.ERR_GPS_CODE_SMALL_BUFF_SZ:\n                    return self.mySeptentrioGPS.ERR_GPS_CODE_SMALL_BUFF_SZ, self.mySeptentrioGPS.ERR_GPS_CODE_SMALL_BUFF_SZ, self.mySeptentrioGPS.ERR_GPS_CODE_SMALL_BUFF_SZ\n                else:\n                    time_tag_coords = coords['TOW']\n                    datum_coordinates = coords['Datum']\n\n            '''\n            Check if the time difference (ms) between the heading and the coordinates info is less\n            than the time it takes the node to move a predefined distance with the actual speed.           \n            If the node is not moving (self.SPEED = 0) it means the heading info will be always the same\n            and the check is not required.\n            '''\n            if self.SPEED_NODE &gt; 0:\n                time_distance_allowed = 2 # meters\n                if  abs(time_tag_coords - time_tag_heading) &gt; (time_distance_allowed/self.SPEED_NODE)*1000:\n                    print('\\n[WARNING]: for the time_distance_allowed the heading info of the grounde node does not correspond to the coordinates')\n                    return self.ERR_HELPER_CODE_GPS_HEAD_UNRELATED_2_COORD, self.ERR_HELPER_CODE_GPS_HEAD_UNRELATED_2_COORD, self.ERR_HELPER_CODE_GPS_HEAD_UNRELATED_2_COORD\n\n            if self.ID == 'GROUND':\n            # Convert Geocentric WGS84 to Geodetic to compute distance and Inverse Transform Forward Azimuth (ITFA) \n                if datum_coordinates == 0:\n                    lat_ground, lon_ground, height_ground = geocentric2geodetic(coords['X'], coords['Y'], coords['Z'])\n                # Geocentric ETRS89\n                elif datum_coordinates == 30:\n                    lat_ground, lon_ground, height_ground = geocentric2geodetic(coords['X'], coords['Y'], coords['Z'], EPSG_GEOCENTRIC=4346)\n                else:\n                    print('\\n[ERROR]: Not known geocentric datum')\n                    return self.ERR_HELPER_CODE_GPS_NOT_KNOWN_DATUM, self.ERR_HELPER_CODE_GPS_NOT_KNOWN_DATUM, self.ERR_HELPER_CODE_GPS_NOT_KNOWN_DATUM\n\n            elif self.ID == 'DRONE':\n                # Convert Geocentric WGS84 to Geodetic to compute distance and Inverse Transform Forward Azimuth (ITFA) \n                if datum_coordinates == 0:\n                    lat_drone, lon_drone, height_drone = geocentric2geodetic(coords['X'], coords['Y'], coords['Z'])\n                # Geocentric ETRS89\n                elif datum_coordinates == 30:\n                    lat_drone, lon_drone, height_drone = geocentric2geodetic(coords['X'], coords['Y'], coords['Z'], EPSG_GEOCENTRIC=4346)\n                else:\n                    print('\\n[ERROR]: Not known geocentric datum')\n                    return self.ERR_HELPER_CODE_GPS_NOT_KNOWN_DATUM, self.ERR_HELPER_CODE_GPS_NOT_KNOWN_DATUM, self.ERR_HELPER_CODE_GPS_NOT_KNOWN_DATUM\n        # Testing mode\n        elif self.IsGPS == False:\n            # Both coordinates must be provided and must be in geodetic format\n            1\n\n        if (lat_ground is None and lat_drone is None) or (lon_ground is None and lon_drone is None) or (height_ground is None and height_drone is None):\n            print(\"\\n[ERROR]: Either ground or drone coordinates MUST be provided\")\n            return self.ERR_HELPER_CODE_BOTH_NODES_COORDS_CANTBE_EMPTY, self.ERR_HELPER_CODE_BOTH_NODES_COORDS_CANTBE_EMPTY, self.ERR_HELPER_CODE_BOTH_NODES_COORDS_CANTBE_EMPTY       \n\n        if fmode == 0x00: # Azimuth and elevation\n            if self.ID == 'DRONE':\n                yaw_to_set = azimuth_difference_between_coordinates(heading, lat_drone, lon_drone, lat_ground, lon_ground)\n                pitch_to_set = elevation_difference_between_coordinates(lat_drone, lon_drone, height_drone, lat_ground, lon_ground, height_ground)\n            elif self.ID == 'GROUND':\n                yaw_to_set = azimuth_difference_between_coordinates(heading, lat_ground, lon_ground, lat_drone, lon_drone)\n                pitch_to_set = elevation_difference_between_coordinates(lat_ground, lon_ground, height_ground, lat_drone, lon_drone, height_drone)\n        elif fmode == 0x02: # Azimuth\n            if self.ID == 'DRONE':\n                yaw_to_set = azimuth_difference_between_coordinates(heading, lat_drone, lon_drone, lat_ground, lon_ground)\n            elif self.ID == 'GROUND':\n                yaw_to_set = azimuth_difference_between_coordinates(heading, lat_ground, lon_ground, lat_drone, lon_drone)\n        elif fmode == 0x01: # Elevation\n            if self.ID == 'DRONE':\n                pitch_to_set = elevation_difference_between_coordinates(lat_drone, lon_drone, height_drone, lat_ground, lon_ground, height_ground)\n            elif self.ID == 'GROUND':\n                pitch_to_set = elevation_difference_between_coordinates(lat_ground, lon_ground, height_ground, lat_drone, lon_drone, height_drone)\n\n        return yaw_to_set, pitch_to_set\n\n    def do_follow_mode_gimbal(self, fmode=0x00):\n        \"\"\"\n        Callback function when this node receives a ``FOLLOWGIMBAL`` command.\n\n        The ``FOLLOWGIMBAL`` command is sent when the other node asks for this node's GPS information to be able to follow this node's movement.        \n\n        Args:\n            fmode (hexadecimal, optional): specifies whether the other node shall follow this node's movement in: 0x00, Elevation and azimuth; 0x01, Only elevation; 0x02, Only azimuth. Defaults to 0x00.\n        \"\"\"\n\n        self.do_getgps_action(follow_mode_gimbal=True, fmode=0x00)\n\n    def do_getgps_action(self, follow_mode_gimbal=False, fmode=0x00):\n        \"\"\"\n        Callback function when this node receives a ``GETGPS`` command.\n\n        The ``GETGPS`` commmand differentiates from ``FOLLOWGIMBAL`` in that when the other node only request GPS information from this node (i.e. for display the coordinates on a panel of the GUI), the ``follow_mode_gimbal`` is False as well as the ``FMODE`` key of the sent dictionary.\n\n        Args:\n            follow_mode_gimbal (bool, optional): True if other node's gimbal must follow this node's movement. Defaults to False.\n            fmode (hexadecimal, optional): specifies whether the other node shall follow this node's movement in: 0x00, Elevation and azimuth; 0x01, Only elevation; 0x02, Only azimuth. Defaults to 0x00.\n        \"\"\"\n\n        if self.DBG_LVL_1:\n            print(f\"THIS ({self.ID}) receives a GETGPS command\")\n\n        if self.IsGPS:            \n            # Only need to send to the OTHER station our last coordinates, NOT heading.\n            # Heading info required by the OTHER station is Heading info from the OTHER station\n\n            # It has to send over the socket the geocentric/geodetic coordinates\n            # The only way there are no coordinates available is because:\n            # 1) Didn't start gps thread with PVTCart and AttEuler type of messages\n            # 2) Messages interval is too long and the program executed first than the first message arrived\n            # 3) The receiver is not connected to enough satellites or multipath propagation is very strong, so that ERROR == 1\n\n            data_to_send = self.mySeptentrioGPS.get_last_sbf_buffer_info(what='Coordinates')\n\n            if data_to_send['X'] == self.mySeptentrioGPS.ERR_GPS_CODE_BUFF_NULL:\n                # More verbose\n                print(f\"[WARNING]: This {self.ID} has nothing on GPS buffer\")\n                return\n\n            elif data_to_send['X'] == self.mySeptentrioGPS.ERR_GPS_CODE_NO_COORD_AVAIL:\n                # More verbose\n                print(f\"[WARNING]: This {self.ID} does not have GPS or GPS signals are not available\")\n                return\n\n            if follow_mode_gimbal:\n                print('[DEBUG]: Last coordinates retrieved and followgimbal flag set to True to be sent')\n                data_to_send['FOLLOW_GIMBAL'] = 0x01\n                data_to_send['FMODE'] = fmode\n\n            # data_to_send wont be any of the other error codes, because they are not set for 'what'=='Coordinates'\n            else:            \n                data_to_send['FOLLOW_GIMBAL'] = 0x02\n\n            if self.ID == 'GROUND':\n                frame_to_send = self.encode_message(source_id=0x01, destination_id=0x02, message_type=0x03, cmd=0x01, data=data_to_send)\n            elif self.ID == 'DRONE':\n                frame_to_send = self.encode_message(source_id=0x02, destination_id=0x01, message_type=0x03, cmd=0x01, data=data_to_send)\n\n            if self.DBG_LVL_1:\n                print('\\n[DEBUG_1]:Received the GETGPS and read the SBF buffer')\n            if self.ID == 'GROUND':\n                self.a2g_conn.sendall(frame_to_send)\n            if self.ID == 'DRONE':\n                self.socket.sendall(frame_to_send)\n\n            if self.DBG_LVL_1:\n                print('\\n[DEBUG_1]: Sent SBF buffer')\n\n        else:\n            #print('[WARNING]:ASKED for GPS position but no GPS connected: IsGPS is False')\n            1\n\n    def do_setgimbal_action(self, msg_data):\n        \"\"\"\n        Callback function when this node receives a ``SETGIMBAL`` command.\n\n        Args:\n            msg_data (dict): dictionary with keys 'YAW', 'PITCH' and 'MODE'. The 'YAW' values range between [-1800, 1800]. The 'PITCH' values are restricted (by software) to the interval [-600, 600] to avoid hits between the case and the gimbal. The 'MODE' values are: 0x00, consider 'YAW' and/or 'PITCH' values as relative to the actual position of the gimbal; 0x01, consider 'YAW' and/or 'PITCH' values as relative to the absolute 0 (in both azimuth and elevation) position.\n        \"\"\"\n\n        if self.IsGimbal!=0:\n            # Unwrap the dictionary containing the yaw and pitch values to be set.\n            #msg_data = json.loads(msg_data)\n\n            # Error checking\n            #if 'YAW' not in msg_data or 'PITCH' not in msg_data or 'MODE' not in msg_data:\n            if 'YAW' not in msg_data or 'PITCH' not in msg_data:\n                if 'MODE' not in msg_data:\n                    print('[ERROR]: no YAW or PITCH provided')\n                    return\n                else:\n                    self.myGimbal.change_gimbal_mode(mode=msg_data['MODE'])                    \n            elif 'YAW' in msg_data and 'PITCH' in msg_data:\n                if float(msg_data['YAW']) &gt; 1800 or float(msg_data['PITCH']) &gt; 600 or float(msg_data['YAW']) &lt; -1800 or float(msg_data['PITCH']) &lt; -600:\n                    print('[ERROR]: Yaw or pitch angles are outside of range')\n                    return\n                else:\n                    if self.IsGimbal == 1: # RS2\n                        # Cast to int values as a double check, but values are send as numbers and not as strings.\n                        self.myGimbal.setPosControl(yaw=int(msg_data['YAW']), roll=0, pitch=int(msg_data['PITCH']), ctrl_byte=msg_data['MODE'])\n                    if self.IsGimbal == 2: # Gremsy\n                        # Cast to int values as a double check, but values are send as numbers and not as strings.\n                        self.myGimbal.setPosControl(yaw=float(msg_data['YAW']), pitch=float(msg_data['PITCH']), mode=msg_data['MODE'])\n        else:\n            print('\\n[WARNING]: Action to SET Gimbal not posible cause there is no gimbal: IsGimbal is False')\n\n    def do_start_meas_drone_rfsoc(self, msg_data):\n        \"\"\"\n        Callback function when this node receives a ``STARTDRONERFSOC`` command.\n\n        This comand is unidirectional. It is always sent by the ground node to the drone node.\n\n        The purpose is to start the RFSoC thread (created in ``RFSoCRemoteControlFromHost`` class) responsible for retrieving the measured Channel Impulse Response from the RFSoC.\n\n        It is assumed that prior to this callback, the ground rfsoc (tx) has started sending the its sounding signal and there were no issues.\n\n        Args:\n            msg_data (dict): dictionary with keys 'carrier_freq', 'rx_gain_ctrl_bb1', 'rx_gain_ctrl_bb2', 'rx_gain_ctrl_bb3', 'rx_gain_ctrl_bfrf'. More information about these keys can be found in method ``set_rx_rf`` from ``RFSoCRemoteControlFromHost`` class.\n        \"\"\"\n\n        if self.ID == 'DRONE': # double check that we are in the drone\n            print(\"[DEBUG]: Received REQUEST to START measurement\")\n            self.myrfsoc.start_thread_receive_meas_data(msg_data)\n            self.STOP_SEND_SETIRF_FLAG = False\n\n    def do_stop_meas_drone_rfsoc(self):\n        \"\"\"\n        Callback function when this node receives a ``STOPDRONERFSOC`` command.\n\n        This comand is unidirectional. It is always sent by the ground node to the drone node.\n\n        The purpose is to stop the RFSoC thread.\n\n        It is assumed that prior to this function, the ground rfsoc (tx) has started sending the its sounding signal and there were no issues.\n        \"\"\"\n        if self.ID == 'DRONE': # double check that we are in the drone\n            print(\"[DEBUG]: Received REQUEST to STOP measurement\")\n            self.myrfsoc.stop_thread_receive_meas_data()\n            self.STOP_SEND_SETIRF_FLAG = True\n\n    def do_finish_meas_drone_rfsoc(self):\n        \"\"\"\n        Callback function when this node receives a ``FINISHDRONERFSOC`` command.\n\n        This comand is unidirectional. It is always sent by the ground node to the drone node.\n\n        The purpose is to finish the experiment (as defined in \"Manual A2GMeasurements\"). When the experiment is finished the GUI allows the user to end (disconnect) the connection between both nodes.\n        \"\"\"\n        if self.ID == 'DRONE': # double check that we are in the drone\n            print(\"[DEBUG]: Received REQUEST to FINISH measurement\")\n            self.myrfsoc.finish_measurement()\n            self.STOP_SEND_SETIRF_FLAG = True\n\n    def do_set_irf_action(self, msg_data):\n        \"\"\"\n        Callback function when this node receives a ``SETIRF`` command.\n\n        This comand is unidirectional. It is always sent by the drone node to the ground node.\n\n        Receives from the drone a subsampled version of the Power Angular Profile for it to be used by the GUI to continuously plot it in its PAP panel.\n\n        Args:\n            msg_data (numpy.ndarray): attribute value ``data_to_visualize`` from ``RFSoCRemoteControlFromHost`` class.\n        \"\"\"\n\n        if self.ID == 'GROUND': # double checj that we are in the gnd\n            self.PAP_TO_PLOT = np.asarray(msg_data)\n\n    def do_closed_gui_action(self):\n        \"\"\"\n        Callback function when this node receives a ``CLOSEDGUI`` command.\n\n        This comand is unidirectional. It is always sent by the ground node to the drone node.\n\n        Sets a flag indicating (the drone node) that it can end its main script, since the GUI was closed by the user at the ground node.\n        \"\"\"\n\n        if self.ID == 'DRONE':\n            self.CONN_MUST_OVER_FLAG = True\n\n    def do_set_remote_fm_flag(self, data=None):\n        \"\"\"\n        Callback function when this node receives a ``SETREMOTEFMFLAG`` command.\n\n        This comand is unidirectional. It is always sent by the ground node to the drone node.\n\n        Sets the ``drone_fm_flag``. When this flag is set, the drone node can start sending ``FOLLOWGIMBALL`` commands to the ground node to get ground node's coordinates and be able to follow (drone node) it (ground node).\n\n        Args:\n            data (dict, optional): dictionary with keys 'X', 'Y', 'Z', 'FMODE', 'MOBILITY', corresponding to geocentric coordinates. The mentioned keys and their corresponding values refer to the ground node. The coordinates will be available if the ground node ``MOBILITY`` is ``static`` (0x01). The ``FMODE`` key refers to the wheter the drone gimbal follows the ground node in azimuth (0x02), elevation (0x01) or both (0x00) .Defaults to None.\n        \"\"\"\n\n        if self.ID == 'DRONE':\n            self.drone_fm_flag = True\n            self.remote_config_for_drone_fm = data\n\n    def do_set_remote_stop_fm(self):\n        \"\"\"\n        Callback function when this node receives a ``SETREMOTESTOPFM`` command.\n\n        This comand is unidirectional. It is always sent by the ground node to the drone node.\n\n        Unsets the ``drone_fm_flag`` flag.\n        \"\"\"\n\n        if self.ID == 'DRONE':\n            self.drone_fm_flag = False\n\n    def process_answer_get_gps(self, data):\n        \"\"\"\n        Callback function when this node receives an ``ANS`` type of message (the equivalent to an acknowledment) from the other node, after this node sent to the other node a ``GETGPS`` or a ``FOLLOWGIMBAL`` command.\n\n        Args:\n            data (dict): dictionary with keys 'X', 'Y', 'Z', 'FMODE', 'FOLLOW_GIMBAL'. The values of 'X', 'Y', 'Z' are the geocentric coordinates from the other node. 'FMODE' is either 0x00 (Elevation and Azimuth), 0x01 (Elevation) or 0x02 (Azimuth). 'FOLLOW_GIMBAL' is either True (when the sent command by this node was ``FOLLOWGIMBAL``) or False (when the sent command by this node was ``GETGPS``)\n        \"\"\"\n\n        if self.DBG_LVL_1:\n            print(f\"THIS ({self.ID}) receives protocol ANS\")\n\n        if self.ID =='DRONE':\n            y_gnd = data['Y']\n            x_gnd = data['X']\n\n            datum_coordinates = data['Datum']\n\n            if y_gnd == self.mySeptentrioGPS.ERR_GPS_CODE_NO_COORD_AVAIL or x_gnd == self.mySeptentrioGPS.ERR_GPS_CODE_NO_COORD_AVAIL:\n                print('[ERROR]: no GPS coordinates received from DRONE through socket link')\n                return\n\n                # THE HEIGHT VALUE IS THE ALTITUDE VALUE OVER THE SEA LEVEL\n                # Z is in geocentric coordinates and does not correspond to the actual height:\n                # Geocentric WGS84\n            if datum_coordinates == 0:\n                lat_gnd, lon_gnd, height_gnd = geocentric2geodetic(x_gnd, y_gnd, data['Z'])\n                # Geocentric ETRS89\n            elif datum_coordinates == 30:\n                lat_gnd, lon_gnd, height_gnd = geocentric2geodetic(x_gnd, y_gnd, data['Z'], EPSG_GEOCENTRIC=4346)\n            else:\n                print('[ERROR]: Not known geocentric datum')\n                return\n\n            yaw_to_set, pitch_to_set = self.gimbal_follows_drone(lat_ground=lat_gnd, lon_ground=lon_gnd, height_ground=height_gnd, fmode=data['FMODE'])\n\n            while ((yaw_to_set == self.mySeptentrioGPS.ERR_GPS_CODE_SMALL_BUFF_SZ) or (pitch_to_set == self.mySeptentrioGPS.ERR_GPS_CODE_SMALL_BUFF_SZ)):\n                yaw_to_set, pitch_to_set = self.gimbal_follows_drone(lat_ground=lat_gnd, lon_ground=lon_gnd, height_ground=height_gnd, fmode=data['FMODE'])\n        elif self.ID == 'GROUND':\n            y_drone = data['Y']\n            x_drone = data['X']\n\n            datum_coordinates = data['Datum']\n\n            if y_drone == self.mySeptentrioGPS.ERR_GPS_CODE_NO_COORD_AVAIL or x_drone == self.mySeptentrioGPS.ERR_GPS_CODE_NO_COORD_AVAIL:\n                print('[ERROR]: no GPS coordinates received from DRONE through socket link')\n                return\n\n                # Z is in geocentric coordinates and does not correspond to the actual height:\n                # Geocentric WGS84\n            if datum_coordinates == 0:\n                lat_drone, lon_drone, height_drone = geocentric2geodetic(x_drone, y_drone, data['Z'])\n                # Geocentric ETRS89\n            elif datum_coordinates == 30:\n                lat_drone, lon_drone, height_drone = geocentric2geodetic(x_drone, y_drone, data['Z'], EPSG_GEOCENTRIC=4346)\n            else:\n                print('[ERROR]: Not known geocentric datum')\n                return\n\n            # This is for GUI GPS panel to show drone coordinates\n            self.last_drone_coords_requested = {'LAT': lat_drone, 'LON': lon_drone}\n\n            yaw_to_set, pitch_to_set = self.gimbal_follows_drone(lat_drone=lat_drone, lon_drone=lon_drone, height_drone=height_drone, fmode=data['FMODE'])\n\n                # If error [yaw, pitch] values because not enough gps buffer entries (but gps already has entries, meaning is working), call again the gimbal_follows_drone method\n            while ((yaw_to_set == self.mySeptentrioGPS.ERR_GPS_CODE_SMALL_BUFF_SZ) or (pitch_to_set == self.mySeptentrioGPS.ERR_GPS_CODE_SMALL_BUFF_SZ)):\n                yaw_to_set, pitch_to_set = self.gimbal_follows_drone(lat_drone=lat_drone, lon_drone=lon_drone, height_drone=height_drone, fmode=data['FMODE'])\n\n        if yaw_to_set == self.ERR_HELPER_CODE_GPS_HEAD_UNRELATED_2_COORD or yaw_to_set == self.ERR_HELPER_CODE_GPS_NOT_KNOWN_DATUM or yaw_to_set == self.ERR_HELPER_CODE_BOTH_NODES_COORDS_CANTBE_EMPTY or yaw_to_set == self.mySeptentrioGPS.ERR_GPS_CODE_BUFF_NULL:\n            print('[ERROR]: one of the error codes of gimbal_follows_drone persists')\n            print(f\"[DEBUG]: This {self.ID} gimbal will NOT follow its pair node due to ERROR\")\n        else:\n            print(f\"[DEBUG]: This {self.ID} YAW to set is: {yaw_to_set}, and PITCH to set is: {pitch_to_set}\")\n\n            if data['FOLLOW_GIMBAL'] == 0x01: # True, Follow gimbal\n                if self.IsGimbal!=0: # There is a gimbal at the node that receives the answer to its command request.\n                    self.myGimbal.setPosControl(yaw=yaw_to_set, pitch=pitch_to_set) \n                    print(f\"[DEBUG]: This {self.ID} gimbal WILL follow its pair node as stated by user\")\n                else:\n                    print('[WARNING]: No gimbal available, so no rotation will happen')\n            elif data['FOLLOW_GIMBAL'] == 0x02: # False\n                print(f\"[DEBUG]: This {self.ID} gimbal will NOT follow its pair node as stated by user\")\n\n    def decode_message(self, data):\n        \"\"\"\n        Parses an incoming TCP message and calls the appropriate function to handle it. \n\n        This function is called by ``socket_receive`` (the communication thread callback).\n\n        Args:\n            data (bytes): raw data to be decoded\n        \"\"\"\n\n        source_id, destination_id, message_type, cmd, length = struct.unpack('BBBBB', data[:5])\n        data_bytes = data[5:]\n\n        if message_type == 0x01: # SHORT cmd type message\n            if cmd == 0x01 and length == 1: # FOLLOWGIMBAL\n                print(f\"[DEBUG]: THIS {self.ID} receives FOLLOWGIMBAL cmd\")\n                data_bytes = data_bytes[:1]\n                self.do_follow_mode_gimbal(fmode=data_bytes)\n            elif cmd == 0x02 and length == 0: # GETGPS\n                print(f\"[DEBUG]: THIS {self.ID} receives GETGPS cmd\")\n                self.do_getgps_action()\n            elif cmd == 0x03 and length == 4: # SETGIMBAL\n                print(f\"[DEBUG]: THIS {self.ID} receives SETGIMBAL cmd\")\n                data_bytes = data_bytes[:13] # 3 float32 array entries + 1 byte\n                yaw, pitch, roll, mode = struct.unpack('fffB', data_bytes)\n                self.do_setgimbal_action({'YAW': yaw, 'ROLL': roll, 'PITCH': pitch, 'MODE': mode})\n            elif cmd == 0x04 and length == 5: # STARTDRONERFSOC\n                print(f\"[DEBUG]: THIS {self.ID} receives STARTDRONERFSOC cmd\")\n                data_bytes = data_bytes[:12] # 1 float32 and 4 int16\n                carr_freq, rx_1, rx_2, rx_3, rx_bfrf = struct.unpack('fHHHH', data_bytes)\n\n                # float round-error check\n                if carr_freq &gt; 70e9 and np.abs(carr_freq-70e9) &lt; 1500: # float round-error of 1.5 kHz\n                    carr_freq = 70e9\n                elif carr_freq &lt; 57.51e9 and np.abs(carr_freq-57.51e9) &lt; 1500: #float round-error of 1.5 kHz\n                    carr_freq = 57.51e9\n                msg_data = {'carrier_freq': carr_freq,\n                            'rx_gain_ctrl_bb1': rx_1,\n                            'rx_gain_ctrl_bb2': rx_2,\n                            'rx_gain_ctrl_bb3': rx_3,\n                            'rx_gain_ctrl_bfrf': rx_bfrf}\n                self.do_start_meas_drone_rfsoc(msg_data)\n            elif cmd == 0x05 and length == 0: # STOPDRONERFSOC\n                print(f\"[DEBUG]: THIS {self.ID} receives STOPDRONERFSOC cmd\")\n                self.do_stop_meas_drone_rfsoc()\n            elif cmd == 0x06 and length == 0: # FINISHDRONERFSOC\n                print(f\"[DEBUG]: THIS {self.ID} receives FINISHDRONERFSOC cmd\")\n                self.do_finish_meas_drone_rfsoc()\n            elif cmd == 0x07 and length == 0: # CLOSEDGUI\n                print(f\"[DEBUG]: THIS {self.ID} receives CLOSEDGUI cmd\")\n                self.do_closed_gui_action()\n            elif cmd == 0x08 and length == 5: # SETREMOTEFMFLAG\n                print(f\"[DEBUG]: THIS {self.ID} receives SETREMOTEFMFLAG cmd\")\n                data_bytes = data_bytes[:26] # 3 float64, 2 hex\n                x,y,z,fmode,mobility = struct.unpack('dddBB', data_bytes)\n                mydata ={'X':x, 'Y':y, 'Z':z, 'FMODE': fmode, 'MOBILITY': mobility}\n                self.do_set_remote_fm_flag(data=mydata)\n            elif cmd == 0x09 and length == 0: # SETREMOTESTOPFM\n                print(f\"[DEBUG]: THIS {self.ID} receives SETREMOTESTOPFM cmd\")\n                self.do_set_remote_stop_fm()\n            else:\n                print(\"[WARNING]: cmd not known when decoding.  No action will be done\")\n        elif message_type == 0x02: # LONG cmd type msg\n            if cmd == 0x01: # SETIRF\n                print(f\"[DEBUG]: THIS {self.ID} receives SETIRF cmd. Time snaps: {length}\")\n                last = int(4*length*16) # The data type of the array entries is float32 and it will have always 16 beams and variable number of time snapshots\n                data_bytes = data_bytes[:last]\n                data_array = np.frombuffer(data_bytes, dtype=np.float32)\n                data_array = data_array.reshape((length, 16))\n                self.do_set_irf_action(data_array)\n            else:\n                print(\"[WARNING]: cmd not known when decoding.  No action will be done\")\n        elif message_type == 0x03: # ANS type\n            if cmd == 0x01: # Response to GETGPS\n                print(f'[DEBUG]: THIS ({self.ID}) receives ANS to GETGPS cmd')\n                data_bytes = data_bytes[:27]\n                x,y,z,datum,follow_gimbal, fmode = struct.unpack('dddBBB', data_bytes)\n                msg_data = {'X': x, 'Y': y, 'Z': z, 'Datum': datum, 'FOLLOW_GIMBAL': follow_gimbal, 'FMODE': fmode}\n                self.process_answer_get_gps(msg_data)\n            else:\n                print(\"[WARNING]: cmd not known when decoding.  No action will be done\")\n        else:\n            print(\"[WARNING]: message_type not known when decoding. No action will be done\")\n\n    def encode_message(self, source_id, destination_id, message_type, cmd, data=None):\n        \"\"\"\n        Encodes a TCP message to be sent. More information about the specific commands is in the section \"Communication Protocol\" of the \"Manual A2GMeasurements\".\n\n        Args:\n            source_id (int): identifies the sender node with a number (this parameter is provided for -potential- future improvements but does not have any functionality).\n            destination_id (int): identifies the receiver node with a number (this parameter is provided for -potential- future improvements but does not have any functionality).\n            message_type (hexadecimal): 0x01, for a short type of message; 0x02, for a long type of message; 0x03, to answer/acknowledge a received request. More information about this is in \"Manual A2GMeasurements\".\n            cmd (hexadecimal): one of the supported requests/commands for each ``message_type``. The list of commands is provided in \"Manual A2GMeasurements\" (Communication Protocol chapter).\n            data (dict, optional): additional data required by the request/command. The particular data sent depends on the ``message_type`` and the ``cmd``. More information on \"Manual A2GMeasurements\" (Communication Protocol chapter). Defaults to None.\n        Returns:\n            message (bytes): the bytes object representing the message to be sent.\n        \"\"\"\n\n        if message_type == 0x01: # SHORT type of message\n            if cmd == 0x01: # FOLLOWGIMBAL\n                data = struct.pack('B', data['FMODE'])\n                length = 1\n                message = struct.pack('BBBBB', source_id, destination_id, message_type, cmd, length) + data\n            elif cmd == 0x02: # GETGPS\n                length = 0\n                message = struct.pack('BBBBB', source_id, destination_id, message_type, cmd, length)\n            elif cmd == 0x03 and data and len(data) == 4: # SETGIMBAL\n                data = struct.pack('fffB', data['YAW'], data['PITCH'], data['ROLL'], data['MODE'])\n                length = 4\n                message = struct.pack('BBBBB', source_id, destination_id, message_type, cmd, length) + data\n            elif cmd == 0x04 and data and len(data) == 5: # STARTDRONERFSOC\n                data = struct.pack('fHHHH', data['carrier_freq'], data['rx_gain_ctrl_bb1'], data['rx_gain_ctrl_bb2'], data['rx_gain_ctrl_bb3'], data['rx_gain_ctrl_bfrf'])\n                length = 5\n                message = struct.pack('BBBBB', source_id, destination_id, message_type, cmd, length) + data\n            elif cmd == 0x05: # STOPDRONERFSOC\n                length = 0\n                message = struct.pack('BBBBB', source_id, destination_id, message_type, cmd, length)\n            elif cmd == 0x06: # FINISHDRONERFSOC\n                length = 0\n                message = struct.pack('BBBBB', source_id, destination_id, message_type, cmd, length)\n            elif cmd == 0x07: # CLOSEDGUI\n                length = 0\n                message = struct.pack('BBBBB', source_id, destination_id, message_type, cmd, length)\n            elif cmd == 0x08: # SETREMOTEFMFLAG\n                data = struct.pack('dddBB', data['X'], data['Y'], data['Z'], data['FMODE'], data['MOBILITY'])\n                length = 5\n                message = struct.pack('BBBBB', source_id, destination_id, message_type, cmd, length) + data\n            elif cmd == 0x09: # SETREMOTESTOPFM\n                length = 0\n                message = struct.pack('BBBBB', source_id, destination_id, message_type, cmd, length)\n        elif message_type == 0x02: #LONG type message\n            if cmd == 0x01: # SETIRF\n                if data is None:\n                    print(\"[DEBUG]: An array must be provided\")\n                    return\n                data_bytes = data.tobytes()\n                length = len(data)\n                message = struct.pack('BBBBB', source_id, destination_id, message_type, cmd, length) + data_bytes\n        elif message_type == 0x03: # ANS message type\n            if cmd == 0x01: # Response to GETGPS\n                message = struct.pack('dddBBB', data['X'], data['Y'], data['Z'], data['Datum'], data['FOLLOW_GIMBAL'], data['FMODE'])\n        else:\n            print(\"[DEBUG]: message_type not known when encoding.\")\n            return\n\n        return message\n\n    def socket_receive(self, stop_event):\n        \"\"\"\n        The communication thread callback. Calls the parser to decode the most recent TCP message received.\n\n        The time between calls of this function is OS and hardware dependent.\n\n        As both nodes can send and receive messages, this thread\n\n        Args:\n            stop_event (threading.Event): when this is set, this function has nothing to execute.\n        \"\"\"\n\n        # Polling policy for detecting if there has been any message sent.\n        # As th thread is scheduled often in the order of ms, this implementation will raise an exception (if nothing is send) quite often\n        while not stop_event.is_set():\n            try:\n                # Send everything in a json serialized packet\n                if self.ID == 'GROUND':\n                    data = self.a2g_conn.recv(4096) # Up to 1 message of 63 rows and 16 cols of float32 entries\n                elif self.ID == 'DRONE':\n                    data = self.socket.recv(4096)\n                if data:\n                    if self.DBG_LVL_0:\n                        print('\\n[DEBUG_0]: This is the data received: ', data)\n                    #print('[DEBUG]: This is the data received: ', len(data['DATA']), len(data['DATA'][0]))\n                    self.decode_message(data)\n                else:\n                    if self.DBG_LVL_0:\n                        print('\\n[DEBUG_0]: \"data\" in \"if data\" in \"socket_receive\" is None')\n            # i.e.  Didn't receive anything\n            except Exception as e:\n                # Handle the assumed connection lost\n                if self.rxEmptySockCounter &gt; self.MAX_NUM_RX_EMPTY_SOCKETS:\n                    print('\\n[WARNING]:SOCKETS HAVE BEEN EMPTY FOR LONG TIME. DRONE MUST COME CLOSER ', e)\n                    self.rxEmptySockCounter = 0\n\n                self.rxEmptySockCounter = self.rxEmptySockCounter + 1\n\n                #traceback.print_exc()\n                '''\n                Types of known errors:\n                1. 'timed out'\n\n                *This error is reported in the client but not in the server. Happens when the client hasn't received anything in a while, so that 'recv' function raises the exception.\n                *The conn is open and if any node send something again the other node will receive it\n                '''\n\n                if self.DBG_LVL_0:\n                    print('[SOCKET RECEIVE EXCEPTION]: ', e)\n\n    def socket_send_cmd(self, type_cmd=None, data=None):\n        \"\"\"\n        Creates a message by the name of the request/command. Wrapper to ``encode_message``.\n\n        Args:\n            type_cmd (int, optional): refers to the ``cmd`` parameter in ``encode_message``. Defaults to None.\n            data (int, optional): refers to the ``data`` parameter in ``encode_message``. Defaults to None.\n        \"\"\"\n\n        if type_cmd == 'SETGIMBAL':\n            frame = self.encode_message(source_id=0x01, destination_id=0x02, message_type=0x01, cmd=0x03, data=data)\n        elif type_cmd == 'FOLLOWGIMBAL':\n            frame = self.encode_message(source_id=0x01, destination_id=0x02, message_type=0x01, cmd=0x01, data=data)\n        elif type_cmd == 'GETGPS':\n            frame = self.encode_message(source_id=0x01, destination_id=0x02, message_type=0x01, cmd=0x02)\n        elif type_cmd == 'CLOSEDGUI':\n            frame = self.encode_message(source_id=0x01, destination_id=0x02, message_type=0x01, cmd=0x07)\n        elif type_cmd == 'STARTDRONERFSOC':\n            frame = self.encode_message(source_id=0x01, destination_id=0x02, message_type=0x01, cmd=0x04, data=data)\n        elif type_cmd == 'STOPDRONERFSOC':\n            frame = self.encode_message(source_id=0x01, destination_id=0x02, message_type=0x01, cmd=0x05)\n        elif type_cmd == 'FINISHDRONERFSOC':\n            frame = self.encode_message(source_id=0x01, destination_id=0x02, message_type=0x01, cmd=0x06)\n        elif type_cmd == 'SETIRF':\n            frame = self.encode_message(source_id=0x01, destination_id=0x02, message_type=0x02, cmd=0x01, data=data)\n        elif type_cmd == 'SETREMOTEFMFLAG':\n            frame = self.encode_message(source_id=0x01, destination_id=0x02, message_type=0x01, cmd=0x08, data=data)\n        elif type_cmd == 'SETREMOTESTOPFM':\n            frame = self.encode_message(source_id=0x01, destination_id=0x02, message_type=0x01, cmd=0x09)\n        if self.ID == 'DRONE':\n            self.socket.sendall(frame)\n        elif self.ID == 'GROUND':\n            self.a2g_conn.sendall(frame)\n        print(f\"[DEBUG]: This {self.ID} node sends {type_cmd} cmd\")\n\n    def az_rot_gnd_gimbal_toggle_sig_generator(self, Naz, meas_time=10, filename=None):\n        \"\"\"\n        Rotates the ground gimbal into \"Naz\" azimuth steps, while stopping at each angle step, to turn on the signal generator,\n        wait for it \"meas_time\"[seconds] to send signal, and turn it off again.\n\n        Args:\n            az_now (int): angle where to start the count. It lies between -1800 and 1800\n            Naz (int): number of sectors in azimuth circle\n        \"\"\"\n\n        def fcn_to_execute(state):\n            \"\"\"\n            This local function template must be replaced with the instruction to execute when the ground gimbal\n            stops for 'meas_time' seconds in a given position. \n\n            The instruction to execute has to have 2 states: \n                'On') What to execute when ground gimbal just stopped at a new position\n                'Off') What to execute when 'meas_time' finishes, and ground gimbal must start again to move to the next position\n\n            Args:\n                state (str): ``On`` or ``Off``\n            \"\"\"\n\n            if state == 'On': # 'On' state\n                #self.inst.write('RF1\\n')\n                print('\\nOn state... just print')\n            elif state == 'Off': # 'Off' state\n                #self.inst.write('RF0\\n')\n                print('\\nOff state... just print')\n            else:\n                print('\\n[ERROR]: function to execute must toggle between two states')\n\n        aux_ang_buff = []\n        file_to_save = []\n        if self.IsGimbal!=0 and self.IsGPS:\n\n            if self.DBG_LVL_1:\n                # Remember that reques_current_position is a blocking function\n                self.myGimbal.request_current_position()\n                az_now = int(round(self.myGimbal.yaw))*10\n                pitch_now = int(round(self.myGimbal.pitch))*10\n                print('\\nYAW NOW: ', az_now, ' PITCH NOW: ', pitch_now)\n\n            ang_step = int(3600/Naz)\n            for i in range(Naz):                \n                self.myGimbal.setPosControl(yaw=ang_step, roll=0, pitch=0, ctrl_byte=0x00)\n\n                # 1. Sleep until ground gimbal reaches the position, before the instruction gets executed\n                # Approximate gimbal speed of 56 deg/s: Max angular movement is 1800 which is done in 3.5 at the actual speed \n                time.sleep(self.myGimbal.TIME2MOVE_180_DEG_YAW) \n\n                # 2. Execute instruction state 1\n                fcn_to_execute('On')\n\n                if self.DBG_LVL_1:\n                    print('\\n[WARNING]: in iteration ' + str(i+1) + ' of ' + str(Naz)  +', instruction executed, now block thread for ' + str(meas_time) + '  [s]')\n\n                # 3. Sleep for 'meas_time', waiting for instruction to be executed\n                time.sleep(meas_time)\n\n                # 4. Execute instruction state 0\n                fcn_to_execute('Off')\n\n                # 5. Get last gps coordinates and save them with gimbal info\n                coords = self.mySeptentrioGPS.get_last_sbf_buffer_info(what='Coordinates')\n\n                if coords['X'] == self.mySeptentrioGPS.ERR_GPS_CODE_BUFF_NULL:\n                    print('\\n[ERROR]: gps sbf stream not started or not a single entry in buffer yet')\n                    return \n                elif coords['X'] == self.mySeptentrioGPS.ERR_GPS_CODE_NO_COORD_AVAIL:\n                    print('\\n[ERROR]: gps stream started but not enough satellites or strong multipath propagation interference')\n                    return \n                else:                    \n                    self.myGimbal.request_current_position()\n\n                    coords['GROUND_GIMBAL_YAW'] = self.myGimbal.yaw\n                    coords['GROUND_GIMBAL_PITCH'] = self.myGimbal.pitch\n                    file_to_save.append(coords)\n        else:\n            print('\\n[ERROR]: To call this function, IsGimbal and IsGPS have to be set')\n            print('\\n[WARNING]: No file with coordinates and gimbal yaw, pitch saved')\n            return \n\n        file_to_save = json.dumps(file_to_save)\n        fid = open(filename + '.json', 'w') # this overwrites the file\n        fid.write(file_to_save)\n        fid.close()\n\n        if self.DBG_LVL_1:\n            print('\\nFile ' + filename + ' saved')\n\n        for i in range(Naz):\n            self.myGimbal.setPosControl(yaw=-ang_step, pitch=0, roll=0, ctrl_byte=0x00)\n            time.sleep(self.myGimbal.TIME2MOVE_180_DEG_YAW)\n\n    def HelperStartA2GCom(self, PORT=10000):\n        \"\"\"\n        Starts the socket binding, listening and accepting for server side, or connecting for client side. The ground node works as the server while the drone as the client.\n\n        Creates and starts the thread handling the socket messages.\n\n        Args:\n            PORT (int, optional): TCP port. Defaults to 10000.\n        \"\"\"\n\n        socket_poll_cnt = 1\n\n        # If we know for sure that there will be a client request for connection, we can keep this number low\n        MAX_NUM_SOCKET_POLLS = 100\n\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.socket = s\n\n        # We need to use a timeout, because otherwise socket.accept() will block the GUI\n        self.socket.settimeout(5) \n\n        # CLIENT\n        if self.ID == 'DRONE':\n            self.socket.connect((self.SERVER_ADDRESS, PORT))\n            if self.DBG_LVL_1:\n                print('CONNECTION ESTABLISHED with SERVER ', self.SERVER_ADDRESS)\n\n        # SERVER\n        elif self.ID == 'GROUND':            \n\n            # Bind the socket to the port\n            self.socket.bind(('', PORT))\n\n            # Listen for incoming connections. As there is one and only one client, we don't need a loop of ``socket.listen()`` calls.\n            self.socket.listen()\n\n            # There is no need for an endless loop\n            while(socket_poll_cnt &lt; MAX_NUM_SOCKET_POLLS):\n                try: \n                    # Blocks until timeout\n                    a2g_connection, client_address = self.socket.accept()\n                except Exception as es:\n                    print(\"[DEBUG]: No client has been seen there. Poll again for a connection. POLL NUMBER: \", socket_poll_cnt)\n                    socket_poll_cnt += 1\n                else:\n                    break    \n\n            if self.DBG_LVL_1:\n                print('CONNECTION ESTABLISHED with CLIENT ', client_address)\n\n            self.a2g_conn = a2g_connection\n            self.CLIENT_ADDRESS = client_address\n\n        # This runs a thread that constantly checks for received messages\n        # If there are no messages thre will be an error\n        # The error might be because there is no sent package(but there is still connection) or because there is no connection anymore\n        self.event_stop_thread_helper = threading.Event()\n        thread_rx_helper = threading.Thread(target=self.socket_receive, args=(self.event_stop_thread_helper,))\n        thread_rx_helper.start()\n\n    def HelperA2GStopCom(self, DISC_WHAT='ALL', stream=1):\n        \"\"\"\n        Stops connection with all the devices or the specified ones in the variable 'DISC_WHAT.\n\n        When called, no matter which is the value of ``DISC_WHAT``, always close the TCP socket.\n\n        Args:\n            DISC_WHAT (str, optional): specifies with which/s device/s the connection must be ended. Options are: ``GIMBAL``, ``GPS``, ``RFSOC``, ``SG``, ``ALL``. Defaults to ``ALL``.\n            stream (int, optional): gps stream to be closed. Assuming there is only one gps stream created at ``__init__`` of this class (which is the default operation) when creating the instance of the ``GpsSignaling`` class, this will close all the gps streams. Defaults to 1.\n        \"\"\"\n\n        try:   \n            self.event_stop_thread_helper.set()\n\n            if self.ID == 'DRONE':\n                if hasattr(self, 'socket'):\n                    self.socket.close()\n            elif self.ID == 'GROUND':\n                if hasattr(self, 'a2g_conn'):\n                    self.a2g_conn.close()\n        except:\n            print('\\n[DEBUG]: ERROR closing connection: probably NO SOCKET created')         \n\n        if type(DISC_WHAT) == list:\n            for i in DISC_WHAT:\n                if self.IsGimbal!=0 and (i == 'GIMBAL'):  \n                    self.myGimbal.stop_thread_gimbal()\n                    print('[DEBUG]: Disconnecting gimbal')\n                    time.sleep(0.05)\n                    if self.ID == 'GROUND':\n                        self.myGimbal.actual_bus.shutdown()\n\n                if self.IsGPS and (i == 'GPS'):  \n                    for stream_info in self.mySeptentrioGPS.stream_info:\n                        if int(stream) == int(stream_info['stream_number']):\n                            msg_type = stream_info['msg_type']\n                            interface = stream_info['interface']\n\n                        self.mySeptentrioGPS.stop_gps_data_retrieval(stream_number=stream, msg_type=msg_type, interface=interface)\n                        print('\\n[DEBUG]: Stoping GPS stream')\n                        self.mySeptentrioGPS.stop_thread_gps()      \n\n                if self.IsSignalGenerator and (i == 'SG'):\n                    self.inst.write('RF0\\n')   \n\n                if self.IsRFSoC and (i == 'RFSOC'):\n                    self.myrfsoc.radio_control.close()\n                    self.myrfsoc.radio_data.close()\n        else: # backwards compatibility\n            if self.IsGimbal!=0 and (DISC_WHAT=='ALL' or DISC_WHAT == 'GIMBAL'):  \n                self.myGimbal.stop_thread_gimbal()\n                print('\\n[DEBUG]: Disconnecting gimbal')\n                time.sleep(0.05)\n                if self.ID == 'GROUND':\n                    self.myGimbal.actual_bus.shutdown()\n\n            if self.IsGPS and (DISC_WHAT=='ALL' or DISC_WHAT == 'GPS'):  \n                for stream_info in self.mySeptentrioGPS.stream_info:\n                    if int(stream) == int(stream_info['stream_number']):\n                        msg_type = stream_info['msg_type']\n                        interface = stream_info['interface']\n\n                self.mySeptentrioGPS.stop_gps_data_retrieval(stream_number=stream, msg_type=msg_type, interface=interface)\n                print('\\n[DEBUG]: Stoping GPS stream')\n                self.mySeptentrioGPS.stop_thread_gps()      \n\n            if self.IsSignalGenerator and (DISC_WHAT=='ALL' or DISC_WHAT == 'SG'): \n                self.inst.write('RF0\\n')   \n\n            if self.IsRFSoC and (DISC_WHAT=='ALL' or DISC_WHAT == 'RFSOC'):\n                self.myrfsoc.radio_control.close()\n                self.myrfsoc.radio_data.close()\n</code></pre>"},{"location":"NodesCommunication/#a2gmeasurements.HelperA2GMeasurements.HelperA2GStopCom","title":"<code>HelperA2GStopCom(DISC_WHAT='ALL', stream=1)</code>","text":"<p>Stops connection with all the devices or the specified ones in the variable 'DISC_WHAT.</p> <p>When called, no matter which is the value of <code>DISC_WHAT</code>, always close the TCP socket.</p> <p>Parameters:</p> Name Type Description Default <code>DISC_WHAT</code> <code>str</code> <p>specifies with which/s device/s the connection must be ended. Options are: <code>GIMBAL</code>, <code>GPS</code>, <code>RFSOC</code>, <code>SG</code>, <code>ALL</code>. Defaults to <code>ALL</code>.</p> <code>'ALL'</code> <code>stream</code> <code>int</code> <p>gps stream to be closed. Assuming there is only one gps stream created at <code>__init__</code> of this class (which is the default operation) when creating the instance of the <code>GpsSignaling</code> class, this will close all the gps streams. Defaults to 1.</p> <code>1</code> Source code in <code>a2gmeasurements.py</code> <pre><code>def HelperA2GStopCom(self, DISC_WHAT='ALL', stream=1):\n    \"\"\"\n    Stops connection with all the devices or the specified ones in the variable 'DISC_WHAT.\n\n    When called, no matter which is the value of ``DISC_WHAT``, always close the TCP socket.\n\n    Args:\n        DISC_WHAT (str, optional): specifies with which/s device/s the connection must be ended. Options are: ``GIMBAL``, ``GPS``, ``RFSOC``, ``SG``, ``ALL``. Defaults to ``ALL``.\n        stream (int, optional): gps stream to be closed. Assuming there is only one gps stream created at ``__init__`` of this class (which is the default operation) when creating the instance of the ``GpsSignaling`` class, this will close all the gps streams. Defaults to 1.\n    \"\"\"\n\n    try:   \n        self.event_stop_thread_helper.set()\n\n        if self.ID == 'DRONE':\n            if hasattr(self, 'socket'):\n                self.socket.close()\n        elif self.ID == 'GROUND':\n            if hasattr(self, 'a2g_conn'):\n                self.a2g_conn.close()\n    except:\n        print('\\n[DEBUG]: ERROR closing connection: probably NO SOCKET created')         \n\n    if type(DISC_WHAT) == list:\n        for i in DISC_WHAT:\n            if self.IsGimbal!=0 and (i == 'GIMBAL'):  \n                self.myGimbal.stop_thread_gimbal()\n                print('[DEBUG]: Disconnecting gimbal')\n                time.sleep(0.05)\n                if self.ID == 'GROUND':\n                    self.myGimbal.actual_bus.shutdown()\n\n            if self.IsGPS and (i == 'GPS'):  \n                for stream_info in self.mySeptentrioGPS.stream_info:\n                    if int(stream) == int(stream_info['stream_number']):\n                        msg_type = stream_info['msg_type']\n                        interface = stream_info['interface']\n\n                    self.mySeptentrioGPS.stop_gps_data_retrieval(stream_number=stream, msg_type=msg_type, interface=interface)\n                    print('\\n[DEBUG]: Stoping GPS stream')\n                    self.mySeptentrioGPS.stop_thread_gps()      \n\n            if self.IsSignalGenerator and (i == 'SG'):\n                self.inst.write('RF0\\n')   \n\n            if self.IsRFSoC and (i == 'RFSOC'):\n                self.myrfsoc.radio_control.close()\n                self.myrfsoc.radio_data.close()\n    else: # backwards compatibility\n        if self.IsGimbal!=0 and (DISC_WHAT=='ALL' or DISC_WHAT == 'GIMBAL'):  \n            self.myGimbal.stop_thread_gimbal()\n            print('\\n[DEBUG]: Disconnecting gimbal')\n            time.sleep(0.05)\n            if self.ID == 'GROUND':\n                self.myGimbal.actual_bus.shutdown()\n\n        if self.IsGPS and (DISC_WHAT=='ALL' or DISC_WHAT == 'GPS'):  \n            for stream_info in self.mySeptentrioGPS.stream_info:\n                if int(stream) == int(stream_info['stream_number']):\n                    msg_type = stream_info['msg_type']\n                    interface = stream_info['interface']\n\n            self.mySeptentrioGPS.stop_gps_data_retrieval(stream_number=stream, msg_type=msg_type, interface=interface)\n            print('\\n[DEBUG]: Stoping GPS stream')\n            self.mySeptentrioGPS.stop_thread_gps()      \n\n        if self.IsSignalGenerator and (DISC_WHAT=='ALL' or DISC_WHAT == 'SG'): \n            self.inst.write('RF0\\n')   \n\n        if self.IsRFSoC and (DISC_WHAT=='ALL' or DISC_WHAT == 'RFSOC'):\n            self.myrfsoc.radio_control.close()\n            self.myrfsoc.radio_data.close()\n</code></pre>"},{"location":"NodesCommunication/#a2gmeasurements.HelperA2GMeasurements.HelperStartA2GCom","title":"<code>HelperStartA2GCom(PORT=10000)</code>","text":"<p>Starts the socket binding, listening and accepting for server side, or connecting for client side. The ground node works as the server while the drone as the client.</p> <p>Creates and starts the thread handling the socket messages.</p> <p>Parameters:</p> Name Type Description Default <code>PORT</code> <code>int</code> <p>TCP port. Defaults to 10000.</p> <code>10000</code> Source code in <code>a2gmeasurements.py</code> <pre><code>def HelperStartA2GCom(self, PORT=10000):\n    \"\"\"\n    Starts the socket binding, listening and accepting for server side, or connecting for client side. The ground node works as the server while the drone as the client.\n\n    Creates and starts the thread handling the socket messages.\n\n    Args:\n        PORT (int, optional): TCP port. Defaults to 10000.\n    \"\"\"\n\n    socket_poll_cnt = 1\n\n    # If we know for sure that there will be a client request for connection, we can keep this number low\n    MAX_NUM_SOCKET_POLLS = 100\n\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    self.socket = s\n\n    # We need to use a timeout, because otherwise socket.accept() will block the GUI\n    self.socket.settimeout(5) \n\n    # CLIENT\n    if self.ID == 'DRONE':\n        self.socket.connect((self.SERVER_ADDRESS, PORT))\n        if self.DBG_LVL_1:\n            print('CONNECTION ESTABLISHED with SERVER ', self.SERVER_ADDRESS)\n\n    # SERVER\n    elif self.ID == 'GROUND':            \n\n        # Bind the socket to the port\n        self.socket.bind(('', PORT))\n\n        # Listen for incoming connections. As there is one and only one client, we don't need a loop of ``socket.listen()`` calls.\n        self.socket.listen()\n\n        # There is no need for an endless loop\n        while(socket_poll_cnt &lt; MAX_NUM_SOCKET_POLLS):\n            try: \n                # Blocks until timeout\n                a2g_connection, client_address = self.socket.accept()\n            except Exception as es:\n                print(\"[DEBUG]: No client has been seen there. Poll again for a connection. POLL NUMBER: \", socket_poll_cnt)\n                socket_poll_cnt += 1\n            else:\n                break    \n\n        if self.DBG_LVL_1:\n            print('CONNECTION ESTABLISHED with CLIENT ', client_address)\n\n        self.a2g_conn = a2g_connection\n        self.CLIENT_ADDRESS = client_address\n\n    # This runs a thread that constantly checks for received messages\n    # If there are no messages thre will be an error\n    # The error might be because there is no sent package(but there is still connection) or because there is no connection anymore\n    self.event_stop_thread_helper = threading.Event()\n    thread_rx_helper = threading.Thread(target=self.socket_receive, args=(self.event_stop_thread_helper,))\n    thread_rx_helper.start()\n</code></pre>"},{"location":"NodesCommunication/#a2gmeasurements.HelperA2GMeasurements.__init__","title":"<code>__init__(ID, SERVER_ADDRESS, DBG_LVL_0=False, DBG_LVL_1=False, IsGimbal=False, IsGPS=False, IsSignalGenerator=False, IsRFSoC=False, rfsoc_static_ip_address=None, F0=None, L0=None, SPEED=0, GPS_Stream_Interval='msec500', AVG_CALLBACK_TIME_SOCKET_RECEIVE_FCN=0.001, operating_freq=57510000000.0, heading_offset=0)</code>","text":"<p>Creates instances of classes <code>GimbalRS2</code> (or <code>GimbalGremsyH16</code>), <code>GpsSignaling</code>, <code>RFSoCRemoteControlFromHost</code> to control these devices.</p> <p>Parameters:</p> Name Type Description Default <code>ID</code> <code>str</code> <p>either 'DRONE' or 'GND'.</p> required <code>SERVER_ADDRESS</code> <code>str</code> <p>the IP address of the ground station.</p> required <code>DBG_LVL_0</code> <code>bool</code> <p>if set, prints some low-level messages usefull for debugging. Defaults to False.</p> <code>False</code> <code>DBG_LVL_1</code> <code>bool</code> <p>if set, prints some higher-level messages usefull for debugging. Defaults to False.</p> <code>False</code> <code>IsGimbal</code> <code>bool</code> <p>0 or FALSE, when no gimbal is physically connected to this host computer; 1, when a Ronin RS2 is physically connected; 2, when a Gremsy H16 is physically connected. Defaults to False.</p> <code>False</code> <code>IsGPS</code> <code>bool</code> <p>True if a gps is physically connected to this host computer. False otherwise. Defaults to False.</p> <code>False</code> <code>IsSignalGenerator</code> <code>bool</code> <p>True if a signal generator controlled by pyvisa commands is physically connected to this host computer. False otherwise. Defaults to False.</p> <code>False</code> <code>IsRFSoC</code> <code>bool</code> <p>True if an RFSoC is physically connected to this host computer. False otherwise. Defaults to False.</p> <code>False</code> <code>rfsoc_static_ip_address</code> <code>str</code> <p>IP address of the RFSoC connected to this host computer. Defaults to None.</p> <code>None</code> <code>L0</code> <code>float</code> <p>parameter of the signal generator. Defaults to None.</p> <code>None</code> <code>SPEED</code> <code>int</code> <p>the speed of the node in m/s. If this node is GROUND it should be 0 (gnd node does not move) as it is by default. This parameter ONLY incides in raising a warning debug print when the speed of the node is higher than the time difference between consecutive SBF sentences. NOT a crutial parameter at all. Stays here for back compatibility. Defaults to 0.</p> <code>0</code> <code>GPS_Stream_Interval</code> <code>str</code> <p>time interval used for the retrieving of the configured SBF sentences in Septentrio's receiver connected to this host computer. A list of available options is shown in <code>start_gps_data_retrieval</code> of class <code>GpsSignaling</code>. Defaults to 'msec500'.</p> <code>'msec500'</code> <code>AVG_CALLBACK_TIME_SOCKET_RECEIVE_FCN</code> <code>float</code> <p>approximated time between calls of the communication thread. This parameter is used in conjunction with <code>MAX_TIME_EMPTY_SOCKETS</code> to raise an exception when neither side of the communication link is sending any message. Unfortunately, this is a very simple estimate, since the actual time between calls depends on many factors and is does not remain constant between calls. Defaults to 0.001.</p> <code>0.001</code> <code>operating_freq</code> <code>_type_</code> <p>operating frequency of the Sivers RF-frontend. The range of defined frequencies is defined in the \"User Manual EVK06002\" of the Sivers EVK (57-71 GHz). Defaults to 57.51e9.</p> <code>57510000000.0</code> <code>heading_offset</code> <code>int</code> <p>heading offset (check its definition in the <code>GpsSignaling.setHeadingOffset</code> method). Defaults to 0.</p> <code>0</code> Source code in <code>a2gmeasurements.py</code> <pre><code>def __init__(self, ID, SERVER_ADDRESS, \n             DBG_LVL_0=False, DBG_LVL_1=False, \n             IsGimbal=False, IsGPS=False, IsSignalGenerator=False, IsRFSoC=False,\n             rfsoc_static_ip_address=None, #uses the default ip_adress\n             F0=None, L0=None,\n             SPEED=0,\n             GPS_Stream_Interval='msec500', AVG_CALLBACK_TIME_SOCKET_RECEIVE_FCN=0.001,\n             operating_freq=57.51e9,\n             heading_offset=0):\n    \"\"\"\n    Creates instances of classes ``GimbalRS2`` (or ``GimbalGremsyH16``), ``GpsSignaling``, ``RFSoCRemoteControlFromHost`` to control these devices.\n\n    Args:\n        ID (str): either 'DRONE' or 'GND'.\n        SERVER_ADDRESS (str): the IP address of the ground station.\n        DBG_LVL_0 (bool, optional): if set, prints some low-level messages usefull for debugging. Defaults to False.\n        DBG_LVL_1 (bool, optional): if set, prints some higher-level messages usefull for debugging. Defaults to False.\n        IsGimbal (bool, optional): 0 or FALSE, when no gimbal is physically connected to this host computer; 1, when a Ronin RS2 is physically connected; 2, when a Gremsy H16 is physically connected. Defaults to False.\n        IsGPS (bool, optional): True if a gps is physically connected to this host computer. False otherwise. Defaults to False.\n        IsSignalGenerator (bool, optional): True if a signal generator controlled by pyvisa commands is physically connected to this host computer. False otherwise. Defaults to False.\n        IsRFSoC (bool, optional): True if an RFSoC is physically connected to this host computer. False otherwise. Defaults to False.\n        rfsoc_static_ip_address (str, optional): IP address of the RFSoC connected to this host computer. Defaults to None.\n        L0 (float, optional): parameter of the signal generator. Defaults to None.\n        SPEED (int, optional): the speed of the node in m/s. If this node is GROUND it should be 0 (gnd node does not move) as it is by default. This parameter ONLY incides in raising a warning debug print when the speed of the node is higher than the time difference between consecutive SBF sentences. NOT a crutial parameter at all. Stays here for back compatibility. Defaults to 0.\n        GPS_Stream_Interval (str, optional): time interval used for the retrieving of the configured SBF sentences in Septentrio's receiver connected to this host computer. A list of available options is shown in ``start_gps_data_retrieval`` of class ``GpsSignaling``. Defaults to 'msec500'.\n        AVG_CALLBACK_TIME_SOCKET_RECEIVE_FCN (float, optional): approximated time between calls of the communication thread. This parameter is used in conjunction with ``MAX_TIME_EMPTY_SOCKETS`` to raise an exception when neither side of the communication link is sending any message. Unfortunately, this is a very simple estimate, since the actual time between calls depends on many factors and is does not remain constant between calls. Defaults to 0.001.\n        operating_freq (_type_, optional): operating frequency of the Sivers RF-frontend. The range of defined frequencies is defined in the \"User Manual EVK06002\" of the Sivers EVK (57-71 GHz). Defaults to 57.51e9.\n        heading_offset (int, optional): heading offset (check its definition in the ``GpsSignaling.setHeadingOffset`` method). Defaults to 0.\n    \"\"\"\n\n    self.AVG_CALLBACK_TIME_SOCKET_RECEIVE_FCN = AVG_CALLBACK_TIME_SOCKET_RECEIVE_FCN\n    self.MAX_TIME_EMPTY_SOCKETS = 20 # in [s]\n    self.MAX_NUM_RX_EMPTY_SOCKETS = round(self.MAX_TIME_EMPTY_SOCKETS / self.AVG_CALLBACK_TIME_SOCKET_RECEIVE_FCN)\n    self.rxEmptySockCounter = 0\n\n    self.ID = ID\n    self.SERVER_ADDRESS = SERVER_ADDRESS  \n    self.SOCKET_BUFFER = []\n    self.DBG_LVL_0 = DBG_LVL_0\n    self.DBG_LVL_1 = DBG_LVL_1\n    self.IsGimbal = IsGimbal\n    self.IsGPS = IsGPS\n    self.IsRFSoC = IsRFSoC\n    self.IsSignalGenerator = IsSignalGenerator\n    self.ERR_HELPER_CODE_GPS_HEAD_UNRELATED_2_COORD = -7.5e3 \n    self.ERR_HELPER_CODE_GPS_NOT_KNOWN_DATUM = -8.5e3\n    self.ERR_HELPER_CODE_BOTH_NODES_COORDS_CANTBE_EMPTY = -9.5e3\n    self.SPEED_NODE = SPEED # m/s\n    self.CONN_MUST_OVER_FLAG = False # Usefull for drone side, as its script will poll for looking if this is True\n    self.PAP_TO_PLOT = []\n    self.drone_fm_flag = False\n\n    print(IsGPS, self.IsGPS)\n\n    if IsRFSoC:\n        self.myrfsoc = RFSoCRemoteControlFromHost(operating_freq=operating_freq, rfsoc_static_ip_address=rfsoc_static_ip_address)\n        print(\"[DEBUG]: Created RFSoC class\")\n    if IsGimbal == 1: # By default, the TRUE value is GimbalRS2\n        self.myGimbal = GimbalRS2()\n        self.myGimbal.start_thread_gimbal()\n        time.sleep(0.5)\n        print(\"[DEBUG]: Created Gimbal class\")\n    elif IsGimbal == 2:\n        self.myGimbal = GimbalGremsyH16()\n        self.myGimbal.start_thread_gimbal()\n        print(\"[DEBUG]: Created Gimbal class\")\n    else: # IsGimbal = False\n        print(\"[DEBUG]: No gimbal class is created\")\n    if IsGPS:\n        self.mySeptentrioGPS = GpsSignaling(DBG_LVL_2=True, DBG_LVL_1=False, DBG_LVL_0=False)\n        print(\"[DEBUG]: Created GPS class\")\n        self.mySeptentrioGPS.serial_connect()\n\n        if self.mySeptentrioGPS.GPS_CONN_SUCCESS:\n            self.mySeptentrioGPS.serial_instance.reset_input_buffer()\n\n            # Set the heading offset if any\n            self.mySeptentrioGPS.setHeadingOffset(heading_offset)\n\n            if self.ID == 'DRONE':\n                self.mySeptentrioGPS.start_gps_data_retrieval(stream_number=1,  msg_type='SBF', interval=GPS_Stream_Interval, sbf_type='+PVTCartesian+AttEuler')\n            elif self.ID == 'GROUND':\n                self.mySeptentrioGPS.start_gps_data_retrieval(stream_number=1,  msg_type='SBF', interval=GPS_Stream_Interval, sbf_type='+PVTCartesian+AttEuler')\n            print(\"[DEBUG]: started gps stream\")\n            #self.mySeptentrioGPS.start_gps_data_retrieval(msg_type='NMEA', nmea_type='GGA', interval='sec1')\n            self.mySeptentrioGPS.start_thread_gps()\n            time.sleep(0.5)\n    if IsSignalGenerator:\n        rm = pyvisa.ResourceManager()\n        inst = rm.open_resource('GPIB0::19::INSTR')\n        self.inst = inst\n        self.inst.write('F0 ' + str(F0) + ' GH\\n')\n        self.inst.write('L0 ' + str(L0)+ ' DM\\n')\n        time.sleep(0.5)\n</code></pre>"},{"location":"NodesCommunication/#a2gmeasurements.HelperA2GMeasurements.az_rot_gnd_gimbal_toggle_sig_generator","title":"<code>az_rot_gnd_gimbal_toggle_sig_generator(Naz, meas_time=10, filename=None)</code>","text":"<p>Rotates the ground gimbal into \"Naz\" azimuth steps, while stopping at each angle step, to turn on the signal generator, wait for it \"meas_time\"[seconds] to send signal, and turn it off again.</p> <p>Parameters:</p> Name Type Description Default <code>az_now</code> <code>int</code> <p>angle where to start the count. It lies between -1800 and 1800</p> required <code>Naz</code> <code>int</code> <p>number of sectors in azimuth circle</p> required Source code in <code>a2gmeasurements.py</code> <pre><code>def az_rot_gnd_gimbal_toggle_sig_generator(self, Naz, meas_time=10, filename=None):\n    \"\"\"\n    Rotates the ground gimbal into \"Naz\" azimuth steps, while stopping at each angle step, to turn on the signal generator,\n    wait for it \"meas_time\"[seconds] to send signal, and turn it off again.\n\n    Args:\n        az_now (int): angle where to start the count. It lies between -1800 and 1800\n        Naz (int): number of sectors in azimuth circle\n    \"\"\"\n\n    def fcn_to_execute(state):\n        \"\"\"\n        This local function template must be replaced with the instruction to execute when the ground gimbal\n        stops for 'meas_time' seconds in a given position. \n\n        The instruction to execute has to have 2 states: \n            'On') What to execute when ground gimbal just stopped at a new position\n            'Off') What to execute when 'meas_time' finishes, and ground gimbal must start again to move to the next position\n\n        Args:\n            state (str): ``On`` or ``Off``\n        \"\"\"\n\n        if state == 'On': # 'On' state\n            #self.inst.write('RF1\\n')\n            print('\\nOn state... just print')\n        elif state == 'Off': # 'Off' state\n            #self.inst.write('RF0\\n')\n            print('\\nOff state... just print')\n        else:\n            print('\\n[ERROR]: function to execute must toggle between two states')\n\n    aux_ang_buff = []\n    file_to_save = []\n    if self.IsGimbal!=0 and self.IsGPS:\n\n        if self.DBG_LVL_1:\n            # Remember that reques_current_position is a blocking function\n            self.myGimbal.request_current_position()\n            az_now = int(round(self.myGimbal.yaw))*10\n            pitch_now = int(round(self.myGimbal.pitch))*10\n            print('\\nYAW NOW: ', az_now, ' PITCH NOW: ', pitch_now)\n\n        ang_step = int(3600/Naz)\n        for i in range(Naz):                \n            self.myGimbal.setPosControl(yaw=ang_step, roll=0, pitch=0, ctrl_byte=0x00)\n\n            # 1. Sleep until ground gimbal reaches the position, before the instruction gets executed\n            # Approximate gimbal speed of 56 deg/s: Max angular movement is 1800 which is done in 3.5 at the actual speed \n            time.sleep(self.myGimbal.TIME2MOVE_180_DEG_YAW) \n\n            # 2. Execute instruction state 1\n            fcn_to_execute('On')\n\n            if self.DBG_LVL_1:\n                print('\\n[WARNING]: in iteration ' + str(i+1) + ' of ' + str(Naz)  +', instruction executed, now block thread for ' + str(meas_time) + '  [s]')\n\n            # 3. Sleep for 'meas_time', waiting for instruction to be executed\n            time.sleep(meas_time)\n\n            # 4. Execute instruction state 0\n            fcn_to_execute('Off')\n\n            # 5. Get last gps coordinates and save them with gimbal info\n            coords = self.mySeptentrioGPS.get_last_sbf_buffer_info(what='Coordinates')\n\n            if coords['X'] == self.mySeptentrioGPS.ERR_GPS_CODE_BUFF_NULL:\n                print('\\n[ERROR]: gps sbf stream not started or not a single entry in buffer yet')\n                return \n            elif coords['X'] == self.mySeptentrioGPS.ERR_GPS_CODE_NO_COORD_AVAIL:\n                print('\\n[ERROR]: gps stream started but not enough satellites or strong multipath propagation interference')\n                return \n            else:                    \n                self.myGimbal.request_current_position()\n\n                coords['GROUND_GIMBAL_YAW'] = self.myGimbal.yaw\n                coords['GROUND_GIMBAL_PITCH'] = self.myGimbal.pitch\n                file_to_save.append(coords)\n    else:\n        print('\\n[ERROR]: To call this function, IsGimbal and IsGPS have to be set')\n        print('\\n[WARNING]: No file with coordinates and gimbal yaw, pitch saved')\n        return \n\n    file_to_save = json.dumps(file_to_save)\n    fid = open(filename + '.json', 'w') # this overwrites the file\n    fid.write(file_to_save)\n    fid.close()\n\n    if self.DBG_LVL_1:\n        print('\\nFile ' + filename + ' saved')\n\n    for i in range(Naz):\n        self.myGimbal.setPosControl(yaw=-ang_step, pitch=0, roll=0, ctrl_byte=0x00)\n        time.sleep(self.myGimbal.TIME2MOVE_180_DEG_YAW)\n</code></pre>"},{"location":"NodesCommunication/#a2gmeasurements.HelperA2GMeasurements.decode_message","title":"<code>decode_message(data)</code>","text":"<p>Parses an incoming TCP message and calls the appropriate function to handle it. </p> <p>This function is called by <code>socket_receive</code> (the communication thread callback).</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>raw data to be decoded</p> required Source code in <code>a2gmeasurements.py</code> <pre><code>def decode_message(self, data):\n    \"\"\"\n    Parses an incoming TCP message and calls the appropriate function to handle it. \n\n    This function is called by ``socket_receive`` (the communication thread callback).\n\n    Args:\n        data (bytes): raw data to be decoded\n    \"\"\"\n\n    source_id, destination_id, message_type, cmd, length = struct.unpack('BBBBB', data[:5])\n    data_bytes = data[5:]\n\n    if message_type == 0x01: # SHORT cmd type message\n        if cmd == 0x01 and length == 1: # FOLLOWGIMBAL\n            print(f\"[DEBUG]: THIS {self.ID} receives FOLLOWGIMBAL cmd\")\n            data_bytes = data_bytes[:1]\n            self.do_follow_mode_gimbal(fmode=data_bytes)\n        elif cmd == 0x02 and length == 0: # GETGPS\n            print(f\"[DEBUG]: THIS {self.ID} receives GETGPS cmd\")\n            self.do_getgps_action()\n        elif cmd == 0x03 and length == 4: # SETGIMBAL\n            print(f\"[DEBUG]: THIS {self.ID} receives SETGIMBAL cmd\")\n            data_bytes = data_bytes[:13] # 3 float32 array entries + 1 byte\n            yaw, pitch, roll, mode = struct.unpack('fffB', data_bytes)\n            self.do_setgimbal_action({'YAW': yaw, 'ROLL': roll, 'PITCH': pitch, 'MODE': mode})\n        elif cmd == 0x04 and length == 5: # STARTDRONERFSOC\n            print(f\"[DEBUG]: THIS {self.ID} receives STARTDRONERFSOC cmd\")\n            data_bytes = data_bytes[:12] # 1 float32 and 4 int16\n            carr_freq, rx_1, rx_2, rx_3, rx_bfrf = struct.unpack('fHHHH', data_bytes)\n\n            # float round-error check\n            if carr_freq &gt; 70e9 and np.abs(carr_freq-70e9) &lt; 1500: # float round-error of 1.5 kHz\n                carr_freq = 70e9\n            elif carr_freq &lt; 57.51e9 and np.abs(carr_freq-57.51e9) &lt; 1500: #float round-error of 1.5 kHz\n                carr_freq = 57.51e9\n            msg_data = {'carrier_freq': carr_freq,\n                        'rx_gain_ctrl_bb1': rx_1,\n                        'rx_gain_ctrl_bb2': rx_2,\n                        'rx_gain_ctrl_bb3': rx_3,\n                        'rx_gain_ctrl_bfrf': rx_bfrf}\n            self.do_start_meas_drone_rfsoc(msg_data)\n        elif cmd == 0x05 and length == 0: # STOPDRONERFSOC\n            print(f\"[DEBUG]: THIS {self.ID} receives STOPDRONERFSOC cmd\")\n            self.do_stop_meas_drone_rfsoc()\n        elif cmd == 0x06 and length == 0: # FINISHDRONERFSOC\n            print(f\"[DEBUG]: THIS {self.ID} receives FINISHDRONERFSOC cmd\")\n            self.do_finish_meas_drone_rfsoc()\n        elif cmd == 0x07 and length == 0: # CLOSEDGUI\n            print(f\"[DEBUG]: THIS {self.ID} receives CLOSEDGUI cmd\")\n            self.do_closed_gui_action()\n        elif cmd == 0x08 and length == 5: # SETREMOTEFMFLAG\n            print(f\"[DEBUG]: THIS {self.ID} receives SETREMOTEFMFLAG cmd\")\n            data_bytes = data_bytes[:26] # 3 float64, 2 hex\n            x,y,z,fmode,mobility = struct.unpack('dddBB', data_bytes)\n            mydata ={'X':x, 'Y':y, 'Z':z, 'FMODE': fmode, 'MOBILITY': mobility}\n            self.do_set_remote_fm_flag(data=mydata)\n        elif cmd == 0x09 and length == 0: # SETREMOTESTOPFM\n            print(f\"[DEBUG]: THIS {self.ID} receives SETREMOTESTOPFM cmd\")\n            self.do_set_remote_stop_fm()\n        else:\n            print(\"[WARNING]: cmd not known when decoding.  No action will be done\")\n    elif message_type == 0x02: # LONG cmd type msg\n        if cmd == 0x01: # SETIRF\n            print(f\"[DEBUG]: THIS {self.ID} receives SETIRF cmd. Time snaps: {length}\")\n            last = int(4*length*16) # The data type of the array entries is float32 and it will have always 16 beams and variable number of time snapshots\n            data_bytes = data_bytes[:last]\n            data_array = np.frombuffer(data_bytes, dtype=np.float32)\n            data_array = data_array.reshape((length, 16))\n            self.do_set_irf_action(data_array)\n        else:\n            print(\"[WARNING]: cmd not known when decoding.  No action will be done\")\n    elif message_type == 0x03: # ANS type\n        if cmd == 0x01: # Response to GETGPS\n            print(f'[DEBUG]: THIS ({self.ID}) receives ANS to GETGPS cmd')\n            data_bytes = data_bytes[:27]\n            x,y,z,datum,follow_gimbal, fmode = struct.unpack('dddBBB', data_bytes)\n            msg_data = {'X': x, 'Y': y, 'Z': z, 'Datum': datum, 'FOLLOW_GIMBAL': follow_gimbal, 'FMODE': fmode}\n            self.process_answer_get_gps(msg_data)\n        else:\n            print(\"[WARNING]: cmd not known when decoding.  No action will be done\")\n    else:\n        print(\"[WARNING]: message_type not known when decoding. No action will be done\")\n</code></pre>"},{"location":"NodesCommunication/#a2gmeasurements.HelperA2GMeasurements.do_closed_gui_action","title":"<code>do_closed_gui_action()</code>","text":"<p>Callback function when this node receives a <code>CLOSEDGUI</code> command.</p> <p>This comand is unidirectional. It is always sent by the ground node to the drone node.</p> <p>Sets a flag indicating (the drone node) that it can end its main script, since the GUI was closed by the user at the ground node.</p> Source code in <code>a2gmeasurements.py</code> <pre><code>def do_closed_gui_action(self):\n    \"\"\"\n    Callback function when this node receives a ``CLOSEDGUI`` command.\n\n    This comand is unidirectional. It is always sent by the ground node to the drone node.\n\n    Sets a flag indicating (the drone node) that it can end its main script, since the GUI was closed by the user at the ground node.\n    \"\"\"\n\n    if self.ID == 'DRONE':\n        self.CONN_MUST_OVER_FLAG = True\n</code></pre>"},{"location":"NodesCommunication/#a2gmeasurements.HelperA2GMeasurements.do_finish_meas_drone_rfsoc","title":"<code>do_finish_meas_drone_rfsoc()</code>","text":"<p>Callback function when this node receives a <code>FINISHDRONERFSOC</code> command.</p> <p>This comand is unidirectional. It is always sent by the ground node to the drone node.</p> <p>The purpose is to finish the experiment (as defined in \"Manual A2GMeasurements\"). When the experiment is finished the GUI allows the user to end (disconnect) the connection between both nodes.</p> Source code in <code>a2gmeasurements.py</code> <pre><code>def do_finish_meas_drone_rfsoc(self):\n    \"\"\"\n    Callback function when this node receives a ``FINISHDRONERFSOC`` command.\n\n    This comand is unidirectional. It is always sent by the ground node to the drone node.\n\n    The purpose is to finish the experiment (as defined in \"Manual A2GMeasurements\"). When the experiment is finished the GUI allows the user to end (disconnect) the connection between both nodes.\n    \"\"\"\n    if self.ID == 'DRONE': # double check that we are in the drone\n        print(\"[DEBUG]: Received REQUEST to FINISH measurement\")\n        self.myrfsoc.finish_measurement()\n        self.STOP_SEND_SETIRF_FLAG = True\n</code></pre>"},{"location":"NodesCommunication/#a2gmeasurements.HelperA2GMeasurements.do_follow_mode_gimbal","title":"<code>do_follow_mode_gimbal(fmode=0)</code>","text":"<p>Callback function when this node receives a <code>FOLLOWGIMBAL</code> command.</p> <p>The <code>FOLLOWGIMBAL</code> command is sent when the other node asks for this node's GPS information to be able to follow this node's movement.        </p> <p>Parameters:</p> Name Type Description Default <code>fmode</code> <code>hexadecimal</code> <p>specifies whether the other node shall follow this node's movement in: 0x00, Elevation and azimuth; 0x01, Only elevation; 0x02, Only azimuth. Defaults to 0x00.</p> <code>0</code> Source code in <code>a2gmeasurements.py</code> <pre><code>def do_follow_mode_gimbal(self, fmode=0x00):\n    \"\"\"\n    Callback function when this node receives a ``FOLLOWGIMBAL`` command.\n\n    The ``FOLLOWGIMBAL`` command is sent when the other node asks for this node's GPS information to be able to follow this node's movement.        \n\n    Args:\n        fmode (hexadecimal, optional): specifies whether the other node shall follow this node's movement in: 0x00, Elevation and azimuth; 0x01, Only elevation; 0x02, Only azimuth. Defaults to 0x00.\n    \"\"\"\n\n    self.do_getgps_action(follow_mode_gimbal=True, fmode=0x00)\n</code></pre>"},{"location":"NodesCommunication/#a2gmeasurements.HelperA2GMeasurements.do_getgps_action","title":"<code>do_getgps_action(follow_mode_gimbal=False, fmode=0)</code>","text":"<p>Callback function when this node receives a <code>GETGPS</code> command.</p> <p>The <code>GETGPS</code> commmand differentiates from <code>FOLLOWGIMBAL</code> in that when the other node only request GPS information from this node (i.e. for display the coordinates on a panel of the GUI), the <code>follow_mode_gimbal</code> is False as well as the <code>FMODE</code> key of the sent dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>follow_mode_gimbal</code> <code>bool</code> <p>True if other node's gimbal must follow this node's movement. Defaults to False.</p> <code>False</code> <code>fmode</code> <code>hexadecimal</code> <p>specifies whether the other node shall follow this node's movement in: 0x00, Elevation and azimuth; 0x01, Only elevation; 0x02, Only azimuth. Defaults to 0x00.</p> <code>0</code> Source code in <code>a2gmeasurements.py</code> <pre><code>def do_getgps_action(self, follow_mode_gimbal=False, fmode=0x00):\n    \"\"\"\n    Callback function when this node receives a ``GETGPS`` command.\n\n    The ``GETGPS`` commmand differentiates from ``FOLLOWGIMBAL`` in that when the other node only request GPS information from this node (i.e. for display the coordinates on a panel of the GUI), the ``follow_mode_gimbal`` is False as well as the ``FMODE`` key of the sent dictionary.\n\n    Args:\n        follow_mode_gimbal (bool, optional): True if other node's gimbal must follow this node's movement. Defaults to False.\n        fmode (hexadecimal, optional): specifies whether the other node shall follow this node's movement in: 0x00, Elevation and azimuth; 0x01, Only elevation; 0x02, Only azimuth. Defaults to 0x00.\n    \"\"\"\n\n    if self.DBG_LVL_1:\n        print(f\"THIS ({self.ID}) receives a GETGPS command\")\n\n    if self.IsGPS:            \n        # Only need to send to the OTHER station our last coordinates, NOT heading.\n        # Heading info required by the OTHER station is Heading info from the OTHER station\n\n        # It has to send over the socket the geocentric/geodetic coordinates\n        # The only way there are no coordinates available is because:\n        # 1) Didn't start gps thread with PVTCart and AttEuler type of messages\n        # 2) Messages interval is too long and the program executed first than the first message arrived\n        # 3) The receiver is not connected to enough satellites or multipath propagation is very strong, so that ERROR == 1\n\n        data_to_send = self.mySeptentrioGPS.get_last_sbf_buffer_info(what='Coordinates')\n\n        if data_to_send['X'] == self.mySeptentrioGPS.ERR_GPS_CODE_BUFF_NULL:\n            # More verbose\n            print(f\"[WARNING]: This {self.ID} has nothing on GPS buffer\")\n            return\n\n        elif data_to_send['X'] == self.mySeptentrioGPS.ERR_GPS_CODE_NO_COORD_AVAIL:\n            # More verbose\n            print(f\"[WARNING]: This {self.ID} does not have GPS or GPS signals are not available\")\n            return\n\n        if follow_mode_gimbal:\n            print('[DEBUG]: Last coordinates retrieved and followgimbal flag set to True to be sent')\n            data_to_send['FOLLOW_GIMBAL'] = 0x01\n            data_to_send['FMODE'] = fmode\n\n        # data_to_send wont be any of the other error codes, because they are not set for 'what'=='Coordinates'\n        else:            \n            data_to_send['FOLLOW_GIMBAL'] = 0x02\n\n        if self.ID == 'GROUND':\n            frame_to_send = self.encode_message(source_id=0x01, destination_id=0x02, message_type=0x03, cmd=0x01, data=data_to_send)\n        elif self.ID == 'DRONE':\n            frame_to_send = self.encode_message(source_id=0x02, destination_id=0x01, message_type=0x03, cmd=0x01, data=data_to_send)\n\n        if self.DBG_LVL_1:\n            print('\\n[DEBUG_1]:Received the GETGPS and read the SBF buffer')\n        if self.ID == 'GROUND':\n            self.a2g_conn.sendall(frame_to_send)\n        if self.ID == 'DRONE':\n            self.socket.sendall(frame_to_send)\n\n        if self.DBG_LVL_1:\n            print('\\n[DEBUG_1]: Sent SBF buffer')\n\n    else:\n        #print('[WARNING]:ASKED for GPS position but no GPS connected: IsGPS is False')\n        1\n</code></pre>"},{"location":"NodesCommunication/#a2gmeasurements.HelperA2GMeasurements.do_set_irf_action","title":"<code>do_set_irf_action(msg_data)</code>","text":"<p>Callback function when this node receives a <code>SETIRF</code> command.</p> <p>This comand is unidirectional. It is always sent by the drone node to the ground node.</p> <p>Receives from the drone a subsampled version of the Power Angular Profile for it to be used by the GUI to continuously plot it in its PAP panel.</p> <p>Parameters:</p> Name Type Description Default <code>msg_data</code> <code>ndarray</code> <p>attribute value <code>data_to_visualize</code> from <code>RFSoCRemoteControlFromHost</code> class.</p> required Source code in <code>a2gmeasurements.py</code> <pre><code>def do_set_irf_action(self, msg_data):\n    \"\"\"\n    Callback function when this node receives a ``SETIRF`` command.\n\n    This comand is unidirectional. It is always sent by the drone node to the ground node.\n\n    Receives from the drone a subsampled version of the Power Angular Profile for it to be used by the GUI to continuously plot it in its PAP panel.\n\n    Args:\n        msg_data (numpy.ndarray): attribute value ``data_to_visualize`` from ``RFSoCRemoteControlFromHost`` class.\n    \"\"\"\n\n    if self.ID == 'GROUND': # double checj that we are in the gnd\n        self.PAP_TO_PLOT = np.asarray(msg_data)\n</code></pre>"},{"location":"NodesCommunication/#a2gmeasurements.HelperA2GMeasurements.do_set_remote_fm_flag","title":"<code>do_set_remote_fm_flag(data=None)</code>","text":"<p>Callback function when this node receives a <code>SETREMOTEFMFLAG</code> command.</p> <p>This comand is unidirectional. It is always sent by the ground node to the drone node.</p> <p>Sets the <code>drone_fm_flag</code>. When this flag is set, the drone node can start sending <code>FOLLOWGIMBALL</code> commands to the ground node to get ground node's coordinates and be able to follow (drone node) it (ground node).</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>dictionary with keys 'X', 'Y', 'Z', 'FMODE', 'MOBILITY', corresponding to geocentric coordinates. The mentioned keys and their corresponding values refer to the ground node. The coordinates will be available if the ground node <code>MOBILITY</code> is <code>static</code> (0x01). The <code>FMODE</code> key refers to the wheter the drone gimbal follows the ground node in azimuth (0x02), elevation (0x01) or both (0x00) .Defaults to None.</p> <code>None</code> Source code in <code>a2gmeasurements.py</code> <pre><code>def do_set_remote_fm_flag(self, data=None):\n    \"\"\"\n    Callback function when this node receives a ``SETREMOTEFMFLAG`` command.\n\n    This comand is unidirectional. It is always sent by the ground node to the drone node.\n\n    Sets the ``drone_fm_flag``. When this flag is set, the drone node can start sending ``FOLLOWGIMBALL`` commands to the ground node to get ground node's coordinates and be able to follow (drone node) it (ground node).\n\n    Args:\n        data (dict, optional): dictionary with keys 'X', 'Y', 'Z', 'FMODE', 'MOBILITY', corresponding to geocentric coordinates. The mentioned keys and their corresponding values refer to the ground node. The coordinates will be available if the ground node ``MOBILITY`` is ``static`` (0x01). The ``FMODE`` key refers to the wheter the drone gimbal follows the ground node in azimuth (0x02), elevation (0x01) or both (0x00) .Defaults to None.\n    \"\"\"\n\n    if self.ID == 'DRONE':\n        self.drone_fm_flag = True\n        self.remote_config_for_drone_fm = data\n</code></pre>"},{"location":"NodesCommunication/#a2gmeasurements.HelperA2GMeasurements.do_set_remote_stop_fm","title":"<code>do_set_remote_stop_fm()</code>","text":"<p>Callback function when this node receives a <code>SETREMOTESTOPFM</code> command.</p> <p>This comand is unidirectional. It is always sent by the ground node to the drone node.</p> <p>Unsets the <code>drone_fm_flag</code> flag.</p> Source code in <code>a2gmeasurements.py</code> <pre><code>def do_set_remote_stop_fm(self):\n    \"\"\"\n    Callback function when this node receives a ``SETREMOTESTOPFM`` command.\n\n    This comand is unidirectional. It is always sent by the ground node to the drone node.\n\n    Unsets the ``drone_fm_flag`` flag.\n    \"\"\"\n\n    if self.ID == 'DRONE':\n        self.drone_fm_flag = False\n</code></pre>"},{"location":"NodesCommunication/#a2gmeasurements.HelperA2GMeasurements.do_setgimbal_action","title":"<code>do_setgimbal_action(msg_data)</code>","text":"<p>Callback function when this node receives a <code>SETGIMBAL</code> command.</p> <p>Parameters:</p> Name Type Description Default <code>msg_data</code> <code>dict</code> <p>dictionary with keys 'YAW', 'PITCH' and 'MODE'. The 'YAW' values range between [-1800, 1800]. The 'PITCH' values are restricted (by software) to the interval [-600, 600] to avoid hits between the case and the gimbal. The 'MODE' values are: 0x00, consider 'YAW' and/or 'PITCH' values as relative to the actual position of the gimbal; 0x01, consider 'YAW' and/or 'PITCH' values as relative to the absolute 0 (in both azimuth and elevation) position.</p> required Source code in <code>a2gmeasurements.py</code> <pre><code>def do_setgimbal_action(self, msg_data):\n    \"\"\"\n    Callback function when this node receives a ``SETGIMBAL`` command.\n\n    Args:\n        msg_data (dict): dictionary with keys 'YAW', 'PITCH' and 'MODE'. The 'YAW' values range between [-1800, 1800]. The 'PITCH' values are restricted (by software) to the interval [-600, 600] to avoid hits between the case and the gimbal. The 'MODE' values are: 0x00, consider 'YAW' and/or 'PITCH' values as relative to the actual position of the gimbal; 0x01, consider 'YAW' and/or 'PITCH' values as relative to the absolute 0 (in both azimuth and elevation) position.\n    \"\"\"\n\n    if self.IsGimbal!=0:\n        # Unwrap the dictionary containing the yaw and pitch values to be set.\n        #msg_data = json.loads(msg_data)\n\n        # Error checking\n        #if 'YAW' not in msg_data or 'PITCH' not in msg_data or 'MODE' not in msg_data:\n        if 'YAW' not in msg_data or 'PITCH' not in msg_data:\n            if 'MODE' not in msg_data:\n                print('[ERROR]: no YAW or PITCH provided')\n                return\n            else:\n                self.myGimbal.change_gimbal_mode(mode=msg_data['MODE'])                    \n        elif 'YAW' in msg_data and 'PITCH' in msg_data:\n            if float(msg_data['YAW']) &gt; 1800 or float(msg_data['PITCH']) &gt; 600 or float(msg_data['YAW']) &lt; -1800 or float(msg_data['PITCH']) &lt; -600:\n                print('[ERROR]: Yaw or pitch angles are outside of range')\n                return\n            else:\n                if self.IsGimbal == 1: # RS2\n                    # Cast to int values as a double check, but values are send as numbers and not as strings.\n                    self.myGimbal.setPosControl(yaw=int(msg_data['YAW']), roll=0, pitch=int(msg_data['PITCH']), ctrl_byte=msg_data['MODE'])\n                if self.IsGimbal == 2: # Gremsy\n                    # Cast to int values as a double check, but values are send as numbers and not as strings.\n                    self.myGimbal.setPosControl(yaw=float(msg_data['YAW']), pitch=float(msg_data['PITCH']), mode=msg_data['MODE'])\n    else:\n        print('\\n[WARNING]: Action to SET Gimbal not posible cause there is no gimbal: IsGimbal is False')\n</code></pre>"},{"location":"NodesCommunication/#a2gmeasurements.HelperA2GMeasurements.do_start_meas_drone_rfsoc","title":"<code>do_start_meas_drone_rfsoc(msg_data)</code>","text":"<p>Callback function when this node receives a <code>STARTDRONERFSOC</code> command.</p> <p>This comand is unidirectional. It is always sent by the ground node to the drone node.</p> <p>The purpose is to start the RFSoC thread (created in <code>RFSoCRemoteControlFromHost</code> class) responsible for retrieving the measured Channel Impulse Response from the RFSoC.</p> <p>It is assumed that prior to this callback, the ground rfsoc (tx) has started sending the its sounding signal and there were no issues.</p> <p>Parameters:</p> Name Type Description Default <code>msg_data</code> <code>dict</code> <p>dictionary with keys 'carrier_freq', 'rx_gain_ctrl_bb1', 'rx_gain_ctrl_bb2', 'rx_gain_ctrl_bb3', 'rx_gain_ctrl_bfrf'. More information about these keys can be found in method <code>set_rx_rf</code> from <code>RFSoCRemoteControlFromHost</code> class.</p> required Source code in <code>a2gmeasurements.py</code> <pre><code>def do_start_meas_drone_rfsoc(self, msg_data):\n    \"\"\"\n    Callback function when this node receives a ``STARTDRONERFSOC`` command.\n\n    This comand is unidirectional. It is always sent by the ground node to the drone node.\n\n    The purpose is to start the RFSoC thread (created in ``RFSoCRemoteControlFromHost`` class) responsible for retrieving the measured Channel Impulse Response from the RFSoC.\n\n    It is assumed that prior to this callback, the ground rfsoc (tx) has started sending the its sounding signal and there were no issues.\n\n    Args:\n        msg_data (dict): dictionary with keys 'carrier_freq', 'rx_gain_ctrl_bb1', 'rx_gain_ctrl_bb2', 'rx_gain_ctrl_bb3', 'rx_gain_ctrl_bfrf'. More information about these keys can be found in method ``set_rx_rf`` from ``RFSoCRemoteControlFromHost`` class.\n    \"\"\"\n\n    if self.ID == 'DRONE': # double check that we are in the drone\n        print(\"[DEBUG]: Received REQUEST to START measurement\")\n        self.myrfsoc.start_thread_receive_meas_data(msg_data)\n        self.STOP_SEND_SETIRF_FLAG = False\n</code></pre>"},{"location":"NodesCommunication/#a2gmeasurements.HelperA2GMeasurements.do_stop_meas_drone_rfsoc","title":"<code>do_stop_meas_drone_rfsoc()</code>","text":"<p>Callback function when this node receives a <code>STOPDRONERFSOC</code> command.</p> <p>This comand is unidirectional. It is always sent by the ground node to the drone node.</p> <p>The purpose is to stop the RFSoC thread.</p> <p>It is assumed that prior to this function, the ground rfsoc (tx) has started sending the its sounding signal and there were no issues.</p> Source code in <code>a2gmeasurements.py</code> <pre><code>def do_stop_meas_drone_rfsoc(self):\n    \"\"\"\n    Callback function when this node receives a ``STOPDRONERFSOC`` command.\n\n    This comand is unidirectional. It is always sent by the ground node to the drone node.\n\n    The purpose is to stop the RFSoC thread.\n\n    It is assumed that prior to this function, the ground rfsoc (tx) has started sending the its sounding signal and there were no issues.\n    \"\"\"\n    if self.ID == 'DRONE': # double check that we are in the drone\n        print(\"[DEBUG]: Received REQUEST to STOP measurement\")\n        self.myrfsoc.stop_thread_receive_meas_data()\n        self.STOP_SEND_SETIRF_FLAG = True\n</code></pre>"},{"location":"NodesCommunication/#a2gmeasurements.HelperA2GMeasurements.encode_message","title":"<code>encode_message(source_id, destination_id, message_type, cmd, data=None)</code>","text":"<p>Encodes a TCP message to be sent. More information about the specific commands is in the section \"Communication Protocol\" of the \"Manual A2GMeasurements\".</p> <p>Parameters:</p> Name Type Description Default <code>source_id</code> <code>int</code> <p>identifies the sender node with a number (this parameter is provided for -potential- future improvements but does not have any functionality).</p> required <code>destination_id</code> <code>int</code> <p>identifies the receiver node with a number (this parameter is provided for -potential- future improvements but does not have any functionality).</p> required <code>message_type</code> <code>hexadecimal</code> <p>0x01, for a short type of message; 0x02, for a long type of message; 0x03, to answer/acknowledge a received request. More information about this is in \"Manual A2GMeasurements\".</p> required <code>cmd</code> <code>hexadecimal</code> <p>one of the supported requests/commands for each <code>message_type</code>. The list of commands is provided in \"Manual A2GMeasurements\" (Communication Protocol chapter).</p> required <code>data</code> <code>dict</code> <p>additional data required by the request/command. The particular data sent depends on the <code>message_type</code> and the <code>cmd</code>. More information on \"Manual A2GMeasurements\" (Communication Protocol chapter). Defaults to None.</p> <code>None</code> <p>Returns:     message (bytes): the bytes object representing the message to be sent.</p> Source code in <code>a2gmeasurements.py</code> <pre><code>def encode_message(self, source_id, destination_id, message_type, cmd, data=None):\n    \"\"\"\n    Encodes a TCP message to be sent. More information about the specific commands is in the section \"Communication Protocol\" of the \"Manual A2GMeasurements\".\n\n    Args:\n        source_id (int): identifies the sender node with a number (this parameter is provided for -potential- future improvements but does not have any functionality).\n        destination_id (int): identifies the receiver node with a number (this parameter is provided for -potential- future improvements but does not have any functionality).\n        message_type (hexadecimal): 0x01, for a short type of message; 0x02, for a long type of message; 0x03, to answer/acknowledge a received request. More information about this is in \"Manual A2GMeasurements\".\n        cmd (hexadecimal): one of the supported requests/commands for each ``message_type``. The list of commands is provided in \"Manual A2GMeasurements\" (Communication Protocol chapter).\n        data (dict, optional): additional data required by the request/command. The particular data sent depends on the ``message_type`` and the ``cmd``. More information on \"Manual A2GMeasurements\" (Communication Protocol chapter). Defaults to None.\n    Returns:\n        message (bytes): the bytes object representing the message to be sent.\n    \"\"\"\n\n    if message_type == 0x01: # SHORT type of message\n        if cmd == 0x01: # FOLLOWGIMBAL\n            data = struct.pack('B', data['FMODE'])\n            length = 1\n            message = struct.pack('BBBBB', source_id, destination_id, message_type, cmd, length) + data\n        elif cmd == 0x02: # GETGPS\n            length = 0\n            message = struct.pack('BBBBB', source_id, destination_id, message_type, cmd, length)\n        elif cmd == 0x03 and data and len(data) == 4: # SETGIMBAL\n            data = struct.pack('fffB', data['YAW'], data['PITCH'], data['ROLL'], data['MODE'])\n            length = 4\n            message = struct.pack('BBBBB', source_id, destination_id, message_type, cmd, length) + data\n        elif cmd == 0x04 and data and len(data) == 5: # STARTDRONERFSOC\n            data = struct.pack('fHHHH', data['carrier_freq'], data['rx_gain_ctrl_bb1'], data['rx_gain_ctrl_bb2'], data['rx_gain_ctrl_bb3'], data['rx_gain_ctrl_bfrf'])\n            length = 5\n            message = struct.pack('BBBBB', source_id, destination_id, message_type, cmd, length) + data\n        elif cmd == 0x05: # STOPDRONERFSOC\n            length = 0\n            message = struct.pack('BBBBB', source_id, destination_id, message_type, cmd, length)\n        elif cmd == 0x06: # FINISHDRONERFSOC\n            length = 0\n            message = struct.pack('BBBBB', source_id, destination_id, message_type, cmd, length)\n        elif cmd == 0x07: # CLOSEDGUI\n            length = 0\n            message = struct.pack('BBBBB', source_id, destination_id, message_type, cmd, length)\n        elif cmd == 0x08: # SETREMOTEFMFLAG\n            data = struct.pack('dddBB', data['X'], data['Y'], data['Z'], data['FMODE'], data['MOBILITY'])\n            length = 5\n            message = struct.pack('BBBBB', source_id, destination_id, message_type, cmd, length) + data\n        elif cmd == 0x09: # SETREMOTESTOPFM\n            length = 0\n            message = struct.pack('BBBBB', source_id, destination_id, message_type, cmd, length)\n    elif message_type == 0x02: #LONG type message\n        if cmd == 0x01: # SETIRF\n            if data is None:\n                print(\"[DEBUG]: An array must be provided\")\n                return\n            data_bytes = data.tobytes()\n            length = len(data)\n            message = struct.pack('BBBBB', source_id, destination_id, message_type, cmd, length) + data_bytes\n    elif message_type == 0x03: # ANS message type\n        if cmd == 0x01: # Response to GETGPS\n            message = struct.pack('dddBBB', data['X'], data['Y'], data['Z'], data['Datum'], data['FOLLOW_GIMBAL'], data['FMODE'])\n    else:\n        print(\"[DEBUG]: message_type not known when encoding.\")\n        return\n\n    return message\n</code></pre>"},{"location":"NodesCommunication/#a2gmeasurements.HelperA2GMeasurements.gimbal_follows_drone","title":"<code>gimbal_follows_drone(heading=None, lat_ground=None, lon_ground=None, height_ground=None, lat_drone=None, lon_drone=None, height_drone=None, fmode=0)</code>","text":"<p>Computes the yaw, pitch and roll angles required to move the gimbal in this node towards the other node.</p> <p>The caller of this function must guarantee that if <code>self.ID == 'GROUND'</code>, the arguments passed to this function are drone coords. The ground coords SHOULD NOT be passed as they will be obtained from this node Septentrio's receiver.</p> <p>The caller of this function must guarantee that if <code>self.ID == 'DRONE'</code>, the arguments passed to this function are ground coords. The drone coords SHOULD NOT be passed as they will be obtained from this node Septentrio's receiver.</p> <p>If <code>IsGPS</code> is False (no GPS connected), then <code>heading</code>, <code>lat_ground</code>, <code>lon_ground</code>, <code>height_ground</code>, <code>lat_drone</code>, <code>lon_drone</code>, <code>height_drone</code> must be provided. </p> <p>In that case, all coordinates provided must be geodetic (lat, lon, alt).</p> <p>Parameters:</p> Name Type Description Default <code>heading</code> <code>float</code> <p>angle between [0, 2*pi] (rads) corresponding to the heading of the line between the two antennas connected to Septentrio's receiver in this node. Defaults to None.</p> <code>None</code> <code>lat_ground</code> <code>float</code> <p>latitude of the GPS antenna 1 connected to Septentrio's receiver at the GROUND node. Defaults to None.</p> <code>None</code> <code>lon_ground</code> <code>float</code> <p>longitude of the GPS antenna 1 connected to Septentrio's receiver at the GROUND node. Defaults to None.</p> <code>None</code> <code>height_ground</code> <code>float</code> <p>height of the GPS antenna 1 connected to Septentrio's receiver at the GROUND node. Assuming both antennas are placed at the same height, is the altitude (in meters above sea level) of the either of the antennas. Defaults to None.</p> <code>None</code> <code>lat_drone</code> <code>float</code> <p>latitude of the GPS antenna 1 connected to Septentrio's receiver at the DRONE node. Defaults to None.</p> <code>None</code> <code>lon_drone</code> <code>float</code> <p>longitude of the GPS antenna 1 connected to Septentrio's receiver at the DRONE node. Defaults to None.</p> <code>None</code> <code>height_drone</code> <code>float</code> <p>height of the GPS antenna 1 connected to Septentrio's receiver at the DRONE node. Assuming both antennas are placed at the same height, is the altitude (in meters above sea level) of the either of the antennas. Defaults to None.</p> <code>None</code> <code>fmode</code> <code>hexadecimal</code> <p>defines if the gimbal will follow the other node in Azimuth, elevation or both of them. Options are: 0x00, for Azimuth and elevation; 0x01, for Elevation, 0x02, for Azimuth. Defaults to 0x00.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>yaw_to_set</code> <code>(int, optional)</code> <p>yaw angle to be set at the gimbal of this node, in degrees multiplied by 10 and rounded to the closest integer (i.e. a yaw to set of 45.78 degrees is returned as the yaw value 458)</p> <code>pitch_to_set</code> <code>(int, optional)</code> <p>pitch angle to be set at the gimbal of this node, to follow the other node. The actual value is the angle value in degrees multiplied by 10 and rounded to the closest integer (i.e. a yaw to set of 45.78 degrees is returned as the yaw value 458).</p> Source code in <code>a2gmeasurements.py</code> <pre><code>def gimbal_follows_drone(self, heading=None, lat_ground=None, lon_ground=None, height_ground=None, \n                                lat_drone=None, lon_drone=None, height_drone=None, fmode=0x00):\n    \"\"\"\n    Computes the yaw, pitch and roll angles required to move the gimbal in this node towards the other node.\n\n    The caller of this function must guarantee that if ``self.ID == 'GROUND'``, the arguments passed to this function are drone coords. The ground coords SHOULD NOT be passed as they will be obtained from this node Septentrio's receiver.\n\n    The caller of this function must guarantee that if ``self.ID == 'DRONE'``, the arguments passed to this function are ground coords. The drone coords SHOULD NOT be passed as they will be obtained from this node Septentrio's receiver.\n\n    If ``IsGPS`` is False (no GPS connected), then ``heading``, ``lat_ground``, ``lon_ground``, ``height_ground``, ``lat_drone``, ``lon_drone``, ``height_drone`` must be provided. \n\n    In that case, all coordinates provided must be geodetic (lat, lon, alt).\n\n    Args:\n        heading (float, optional): angle between [0, 2*pi] (rads) corresponding to the heading of the line between the two antennas connected to Septentrio's receiver in this node. Defaults to None.\n        lat_ground (float, optional): latitude of the GPS antenna 1 connected to Septentrio's receiver at the GROUND node. Defaults to None.\n        lon_ground (float, optional): longitude of the GPS antenna 1 connected to Septentrio's receiver at the GROUND node. Defaults to None.\n        height_ground (float, optional): height of the GPS antenna 1 connected to Septentrio's receiver at the GROUND node. Assuming both antennas are placed at the same height, is the altitude (in meters above sea level) of the either of the antennas. Defaults to None.\n        lat_drone (float, optional): latitude of the GPS antenna 1 connected to Septentrio's receiver at the DRONE node. Defaults to None.\n        lon_drone (float, optional): longitude of the GPS antenna 1 connected to Septentrio's receiver at the DRONE node. Defaults to None.\n        height_drone (float, optional): height of the GPS antenna 1 connected to Septentrio's receiver at the DRONE node. Assuming both antennas are placed at the same height, is the altitude (in meters above sea level) of the either of the antennas. Defaults to None.\n        fmode (hexadecimal, optional): defines if the gimbal will follow the other node in Azimuth, elevation or both of them. Options are: 0x00, for Azimuth and elevation; 0x01, for Elevation, 0x02, for Azimuth. Defaults to 0x00.\n\n    Returns:\n        yaw_to_set (int, optional): yaw angle to be set at the gimbal of this node, in degrees multiplied by 10 and rounded to the closest integer (i.e. a yaw to set of 45.78 degrees is returned as the yaw value 458)\n        pitch_to_set(int, optional): pitch angle to be set at the gimbal of this node, to follow the other node. The actual value is the angle value in degrees multiplied by 10 and rounded to the closest integer (i.e. a yaw to set of 45.78 degrees is returned as the yaw value 458).\n    \"\"\"\n\n    if self.IsGPS:\n        if fmode == 0x00 or fmode == 0x02:\n            coords, head_info = self.mySeptentrioGPS.get_last_sbf_buffer_info(what='Both')\n\n            if coords['X'] == self.mySeptentrioGPS.ERR_GPS_CODE_BUFF_NULL:\n                return self.mySeptentrioGPS.ERR_GPS_CODE_BUFF_NULL, self.mySeptentrioGPS.ERR_GPS_CODE_BUFF_NULL, self.mySeptentrioGPS.ERR_GPS_CODE_BUFF_NULL\n            elif coords['X'] == self.mySeptentrioGPS.ERR_GPS_CODE_SMALL_BUFF_SZ:\n                return self.mySeptentrioGPS.ERR_GPS_CODE_SMALL_BUFF_SZ, self.mySeptentrioGPS.ERR_GPS_CODE_SMALL_BUFF_SZ, self.mySeptentrioGPS.ERR_GPS_CODE_SMALL_BUFF_SZ\n            else:\n                heading = head_info['Heading']\n                time_tag_heading = head_info['TOW']\n                time_tag_coords = coords['TOW']\n                datum_coordinates = coords['Datum']\n        elif fmode == 0x01:\n            coords = self.mySeptentrioGPS.get_last_sbf_buffer_info(what='Coordinates')\n\n            if coords['X'] == self.mySeptentrioGPS.ERR_GPS_CODE_BUFF_NULL:\n                return self.mySeptentrioGPS.ERR_GPS_CODE_BUFF_NULL, self.mySeptentrioGPS.ERR_GPS_CODE_BUFF_NULL, self.mySeptentrioGPS.ERR_GPS_CODE_BUFF_NULL\n            elif coords['X'] == self.mySeptentrioGPS.ERR_GPS_CODE_SMALL_BUFF_SZ:\n                return self.mySeptentrioGPS.ERR_GPS_CODE_SMALL_BUFF_SZ, self.mySeptentrioGPS.ERR_GPS_CODE_SMALL_BUFF_SZ, self.mySeptentrioGPS.ERR_GPS_CODE_SMALL_BUFF_SZ\n            else:\n                time_tag_coords = coords['TOW']\n                datum_coordinates = coords['Datum']\n\n        '''\n        Check if the time difference (ms) between the heading and the coordinates info is less\n        than the time it takes the node to move a predefined distance with the actual speed.           \n        If the node is not moving (self.SPEED = 0) it means the heading info will be always the same\n        and the check is not required.\n        '''\n        if self.SPEED_NODE &gt; 0:\n            time_distance_allowed = 2 # meters\n            if  abs(time_tag_coords - time_tag_heading) &gt; (time_distance_allowed/self.SPEED_NODE)*1000:\n                print('\\n[WARNING]: for the time_distance_allowed the heading info of the grounde node does not correspond to the coordinates')\n                return self.ERR_HELPER_CODE_GPS_HEAD_UNRELATED_2_COORD, self.ERR_HELPER_CODE_GPS_HEAD_UNRELATED_2_COORD, self.ERR_HELPER_CODE_GPS_HEAD_UNRELATED_2_COORD\n\n        if self.ID == 'GROUND':\n        # Convert Geocentric WGS84 to Geodetic to compute distance and Inverse Transform Forward Azimuth (ITFA) \n            if datum_coordinates == 0:\n                lat_ground, lon_ground, height_ground = geocentric2geodetic(coords['X'], coords['Y'], coords['Z'])\n            # Geocentric ETRS89\n            elif datum_coordinates == 30:\n                lat_ground, lon_ground, height_ground = geocentric2geodetic(coords['X'], coords['Y'], coords['Z'], EPSG_GEOCENTRIC=4346)\n            else:\n                print('\\n[ERROR]: Not known geocentric datum')\n                return self.ERR_HELPER_CODE_GPS_NOT_KNOWN_DATUM, self.ERR_HELPER_CODE_GPS_NOT_KNOWN_DATUM, self.ERR_HELPER_CODE_GPS_NOT_KNOWN_DATUM\n\n        elif self.ID == 'DRONE':\n            # Convert Geocentric WGS84 to Geodetic to compute distance and Inverse Transform Forward Azimuth (ITFA) \n            if datum_coordinates == 0:\n                lat_drone, lon_drone, height_drone = geocentric2geodetic(coords['X'], coords['Y'], coords['Z'])\n            # Geocentric ETRS89\n            elif datum_coordinates == 30:\n                lat_drone, lon_drone, height_drone = geocentric2geodetic(coords['X'], coords['Y'], coords['Z'], EPSG_GEOCENTRIC=4346)\n            else:\n                print('\\n[ERROR]: Not known geocentric datum')\n                return self.ERR_HELPER_CODE_GPS_NOT_KNOWN_DATUM, self.ERR_HELPER_CODE_GPS_NOT_KNOWN_DATUM, self.ERR_HELPER_CODE_GPS_NOT_KNOWN_DATUM\n    # Testing mode\n    elif self.IsGPS == False:\n        # Both coordinates must be provided and must be in geodetic format\n        1\n\n    if (lat_ground is None and lat_drone is None) or (lon_ground is None and lon_drone is None) or (height_ground is None and height_drone is None):\n        print(\"\\n[ERROR]: Either ground or drone coordinates MUST be provided\")\n        return self.ERR_HELPER_CODE_BOTH_NODES_COORDS_CANTBE_EMPTY, self.ERR_HELPER_CODE_BOTH_NODES_COORDS_CANTBE_EMPTY, self.ERR_HELPER_CODE_BOTH_NODES_COORDS_CANTBE_EMPTY       \n\n    if fmode == 0x00: # Azimuth and elevation\n        if self.ID == 'DRONE':\n            yaw_to_set = azimuth_difference_between_coordinates(heading, lat_drone, lon_drone, lat_ground, lon_ground)\n            pitch_to_set = elevation_difference_between_coordinates(lat_drone, lon_drone, height_drone, lat_ground, lon_ground, height_ground)\n        elif self.ID == 'GROUND':\n            yaw_to_set = azimuth_difference_between_coordinates(heading, lat_ground, lon_ground, lat_drone, lon_drone)\n            pitch_to_set = elevation_difference_between_coordinates(lat_ground, lon_ground, height_ground, lat_drone, lon_drone, height_drone)\n    elif fmode == 0x02: # Azimuth\n        if self.ID == 'DRONE':\n            yaw_to_set = azimuth_difference_between_coordinates(heading, lat_drone, lon_drone, lat_ground, lon_ground)\n        elif self.ID == 'GROUND':\n            yaw_to_set = azimuth_difference_between_coordinates(heading, lat_ground, lon_ground, lat_drone, lon_drone)\n    elif fmode == 0x01: # Elevation\n        if self.ID == 'DRONE':\n            pitch_to_set = elevation_difference_between_coordinates(lat_drone, lon_drone, height_drone, lat_ground, lon_ground, height_ground)\n        elif self.ID == 'GROUND':\n            pitch_to_set = elevation_difference_between_coordinates(lat_ground, lon_ground, height_ground, lat_drone, lon_drone, height_drone)\n\n    return yaw_to_set, pitch_to_set\n</code></pre>"},{"location":"NodesCommunication/#a2gmeasurements.HelperA2GMeasurements.process_answer_get_gps","title":"<code>process_answer_get_gps(data)</code>","text":"<p>Callback function when this node receives an <code>ANS</code> type of message (the equivalent to an acknowledment) from the other node, after this node sent to the other node a <code>GETGPS</code> or a <code>FOLLOWGIMBAL</code> command.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>dictionary with keys 'X', 'Y', 'Z', 'FMODE', 'FOLLOW_GIMBAL'. The values of 'X', 'Y', 'Z' are the geocentric coordinates from the other node. 'FMODE' is either 0x00 (Elevation and Azimuth), 0x01 (Elevation) or 0x02 (Azimuth). 'FOLLOW_GIMBAL' is either True (when the sent command by this node was <code>FOLLOWGIMBAL</code>) or False (when the sent command by this node was <code>GETGPS</code>)</p> required Source code in <code>a2gmeasurements.py</code> <pre><code>def process_answer_get_gps(self, data):\n    \"\"\"\n    Callback function when this node receives an ``ANS`` type of message (the equivalent to an acknowledment) from the other node, after this node sent to the other node a ``GETGPS`` or a ``FOLLOWGIMBAL`` command.\n\n    Args:\n        data (dict): dictionary with keys 'X', 'Y', 'Z', 'FMODE', 'FOLLOW_GIMBAL'. The values of 'X', 'Y', 'Z' are the geocentric coordinates from the other node. 'FMODE' is either 0x00 (Elevation and Azimuth), 0x01 (Elevation) or 0x02 (Azimuth). 'FOLLOW_GIMBAL' is either True (when the sent command by this node was ``FOLLOWGIMBAL``) or False (when the sent command by this node was ``GETGPS``)\n    \"\"\"\n\n    if self.DBG_LVL_1:\n        print(f\"THIS ({self.ID}) receives protocol ANS\")\n\n    if self.ID =='DRONE':\n        y_gnd = data['Y']\n        x_gnd = data['X']\n\n        datum_coordinates = data['Datum']\n\n        if y_gnd == self.mySeptentrioGPS.ERR_GPS_CODE_NO_COORD_AVAIL or x_gnd == self.mySeptentrioGPS.ERR_GPS_CODE_NO_COORD_AVAIL:\n            print('[ERROR]: no GPS coordinates received from DRONE through socket link')\n            return\n\n            # THE HEIGHT VALUE IS THE ALTITUDE VALUE OVER THE SEA LEVEL\n            # Z is in geocentric coordinates and does not correspond to the actual height:\n            # Geocentric WGS84\n        if datum_coordinates == 0:\n            lat_gnd, lon_gnd, height_gnd = geocentric2geodetic(x_gnd, y_gnd, data['Z'])\n            # Geocentric ETRS89\n        elif datum_coordinates == 30:\n            lat_gnd, lon_gnd, height_gnd = geocentric2geodetic(x_gnd, y_gnd, data['Z'], EPSG_GEOCENTRIC=4346)\n        else:\n            print('[ERROR]: Not known geocentric datum')\n            return\n\n        yaw_to_set, pitch_to_set = self.gimbal_follows_drone(lat_ground=lat_gnd, lon_ground=lon_gnd, height_ground=height_gnd, fmode=data['FMODE'])\n\n        while ((yaw_to_set == self.mySeptentrioGPS.ERR_GPS_CODE_SMALL_BUFF_SZ) or (pitch_to_set == self.mySeptentrioGPS.ERR_GPS_CODE_SMALL_BUFF_SZ)):\n            yaw_to_set, pitch_to_set = self.gimbal_follows_drone(lat_ground=lat_gnd, lon_ground=lon_gnd, height_ground=height_gnd, fmode=data['FMODE'])\n    elif self.ID == 'GROUND':\n        y_drone = data['Y']\n        x_drone = data['X']\n\n        datum_coordinates = data['Datum']\n\n        if y_drone == self.mySeptentrioGPS.ERR_GPS_CODE_NO_COORD_AVAIL or x_drone == self.mySeptentrioGPS.ERR_GPS_CODE_NO_COORD_AVAIL:\n            print('[ERROR]: no GPS coordinates received from DRONE through socket link')\n            return\n\n            # Z is in geocentric coordinates and does not correspond to the actual height:\n            # Geocentric WGS84\n        if datum_coordinates == 0:\n            lat_drone, lon_drone, height_drone = geocentric2geodetic(x_drone, y_drone, data['Z'])\n            # Geocentric ETRS89\n        elif datum_coordinates == 30:\n            lat_drone, lon_drone, height_drone = geocentric2geodetic(x_drone, y_drone, data['Z'], EPSG_GEOCENTRIC=4346)\n        else:\n            print('[ERROR]: Not known geocentric datum')\n            return\n\n        # This is for GUI GPS panel to show drone coordinates\n        self.last_drone_coords_requested = {'LAT': lat_drone, 'LON': lon_drone}\n\n        yaw_to_set, pitch_to_set = self.gimbal_follows_drone(lat_drone=lat_drone, lon_drone=lon_drone, height_drone=height_drone, fmode=data['FMODE'])\n\n            # If error [yaw, pitch] values because not enough gps buffer entries (but gps already has entries, meaning is working), call again the gimbal_follows_drone method\n        while ((yaw_to_set == self.mySeptentrioGPS.ERR_GPS_CODE_SMALL_BUFF_SZ) or (pitch_to_set == self.mySeptentrioGPS.ERR_GPS_CODE_SMALL_BUFF_SZ)):\n            yaw_to_set, pitch_to_set = self.gimbal_follows_drone(lat_drone=lat_drone, lon_drone=lon_drone, height_drone=height_drone, fmode=data['FMODE'])\n\n    if yaw_to_set == self.ERR_HELPER_CODE_GPS_HEAD_UNRELATED_2_COORD or yaw_to_set == self.ERR_HELPER_CODE_GPS_NOT_KNOWN_DATUM or yaw_to_set == self.ERR_HELPER_CODE_BOTH_NODES_COORDS_CANTBE_EMPTY or yaw_to_set == self.mySeptentrioGPS.ERR_GPS_CODE_BUFF_NULL:\n        print('[ERROR]: one of the error codes of gimbal_follows_drone persists')\n        print(f\"[DEBUG]: This {self.ID} gimbal will NOT follow its pair node due to ERROR\")\n    else:\n        print(f\"[DEBUG]: This {self.ID} YAW to set is: {yaw_to_set}, and PITCH to set is: {pitch_to_set}\")\n\n        if data['FOLLOW_GIMBAL'] == 0x01: # True, Follow gimbal\n            if self.IsGimbal!=0: # There is a gimbal at the node that receives the answer to its command request.\n                self.myGimbal.setPosControl(yaw=yaw_to_set, pitch=pitch_to_set) \n                print(f\"[DEBUG]: This {self.ID} gimbal WILL follow its pair node as stated by user\")\n            else:\n                print('[WARNING]: No gimbal available, so no rotation will happen')\n        elif data['FOLLOW_GIMBAL'] == 0x02: # False\n            print(f\"[DEBUG]: This {self.ID} gimbal will NOT follow its pair node as stated by user\")\n</code></pre>"},{"location":"NodesCommunication/#a2gmeasurements.HelperA2GMeasurements.socket_receive","title":"<code>socket_receive(stop_event)</code>","text":"<p>The communication thread callback. Calls the parser to decode the most recent TCP message received.</p> <p>The time between calls of this function is OS and hardware dependent.</p> <p>As both nodes can send and receive messages, this thread</p> <p>Parameters:</p> Name Type Description Default <code>stop_event</code> <code>Event</code> <p>when this is set, this function has nothing to execute.</p> required Source code in <code>a2gmeasurements.py</code> <pre><code>def socket_receive(self, stop_event):\n    \"\"\"\n    The communication thread callback. Calls the parser to decode the most recent TCP message received.\n\n    The time between calls of this function is OS and hardware dependent.\n\n    As both nodes can send and receive messages, this thread\n\n    Args:\n        stop_event (threading.Event): when this is set, this function has nothing to execute.\n    \"\"\"\n\n    # Polling policy for detecting if there has been any message sent.\n    # As th thread is scheduled often in the order of ms, this implementation will raise an exception (if nothing is send) quite often\n    while not stop_event.is_set():\n        try:\n            # Send everything in a json serialized packet\n            if self.ID == 'GROUND':\n                data = self.a2g_conn.recv(4096) # Up to 1 message of 63 rows and 16 cols of float32 entries\n            elif self.ID == 'DRONE':\n                data = self.socket.recv(4096)\n            if data:\n                if self.DBG_LVL_0:\n                    print('\\n[DEBUG_0]: This is the data received: ', data)\n                #print('[DEBUG]: This is the data received: ', len(data['DATA']), len(data['DATA'][0]))\n                self.decode_message(data)\n            else:\n                if self.DBG_LVL_0:\n                    print('\\n[DEBUG_0]: \"data\" in \"if data\" in \"socket_receive\" is None')\n        # i.e.  Didn't receive anything\n        except Exception as e:\n            # Handle the assumed connection lost\n            if self.rxEmptySockCounter &gt; self.MAX_NUM_RX_EMPTY_SOCKETS:\n                print('\\n[WARNING]:SOCKETS HAVE BEEN EMPTY FOR LONG TIME. DRONE MUST COME CLOSER ', e)\n                self.rxEmptySockCounter = 0\n\n            self.rxEmptySockCounter = self.rxEmptySockCounter + 1\n\n            #traceback.print_exc()\n            '''\n            Types of known errors:\n            1. 'timed out'\n\n            *This error is reported in the client but not in the server. Happens when the client hasn't received anything in a while, so that 'recv' function raises the exception.\n            *The conn is open and if any node send something again the other node will receive it\n            '''\n\n            if self.DBG_LVL_0:\n                print('[SOCKET RECEIVE EXCEPTION]: ', e)\n</code></pre>"},{"location":"NodesCommunication/#a2gmeasurements.HelperA2GMeasurements.socket_send_cmd","title":"<code>socket_send_cmd(type_cmd=None, data=None)</code>","text":"<p>Creates a message by the name of the request/command. Wrapper to <code>encode_message</code>.</p> <p>Parameters:</p> Name Type Description Default <code>type_cmd</code> <code>int</code> <p>refers to the <code>cmd</code> parameter in <code>encode_message</code>. Defaults to None.</p> <code>None</code> <code>data</code> <code>int</code> <p>refers to the <code>data</code> parameter in <code>encode_message</code>. Defaults to None.</p> <code>None</code> Source code in <code>a2gmeasurements.py</code> <pre><code>def socket_send_cmd(self, type_cmd=None, data=None):\n    \"\"\"\n    Creates a message by the name of the request/command. Wrapper to ``encode_message``.\n\n    Args:\n        type_cmd (int, optional): refers to the ``cmd`` parameter in ``encode_message``. Defaults to None.\n        data (int, optional): refers to the ``data`` parameter in ``encode_message``. Defaults to None.\n    \"\"\"\n\n    if type_cmd == 'SETGIMBAL':\n        frame = self.encode_message(source_id=0x01, destination_id=0x02, message_type=0x01, cmd=0x03, data=data)\n    elif type_cmd == 'FOLLOWGIMBAL':\n        frame = self.encode_message(source_id=0x01, destination_id=0x02, message_type=0x01, cmd=0x01, data=data)\n    elif type_cmd == 'GETGPS':\n        frame = self.encode_message(source_id=0x01, destination_id=0x02, message_type=0x01, cmd=0x02)\n    elif type_cmd == 'CLOSEDGUI':\n        frame = self.encode_message(source_id=0x01, destination_id=0x02, message_type=0x01, cmd=0x07)\n    elif type_cmd == 'STARTDRONERFSOC':\n        frame = self.encode_message(source_id=0x01, destination_id=0x02, message_type=0x01, cmd=0x04, data=data)\n    elif type_cmd == 'STOPDRONERFSOC':\n        frame = self.encode_message(source_id=0x01, destination_id=0x02, message_type=0x01, cmd=0x05)\n    elif type_cmd == 'FINISHDRONERFSOC':\n        frame = self.encode_message(source_id=0x01, destination_id=0x02, message_type=0x01, cmd=0x06)\n    elif type_cmd == 'SETIRF':\n        frame = self.encode_message(source_id=0x01, destination_id=0x02, message_type=0x02, cmd=0x01, data=data)\n    elif type_cmd == 'SETREMOTEFMFLAG':\n        frame = self.encode_message(source_id=0x01, destination_id=0x02, message_type=0x01, cmd=0x08, data=data)\n    elif type_cmd == 'SETREMOTESTOPFM':\n        frame = self.encode_message(source_id=0x01, destination_id=0x02, message_type=0x01, cmd=0x09)\n    if self.ID == 'DRONE':\n        self.socket.sendall(frame)\n    elif self.ID == 'GROUND':\n        self.a2g_conn.sendall(frame)\n    print(f\"[DEBUG]: This {self.ID} node sends {type_cmd} cmd\")\n</code></pre>"},{"location":"PanelsGUI/","title":"Main window","text":"<p>Following Figure shows the main window where the user controls the different devices:</p> Main window of the A2GMeasurements app <p>The enumerated panels of the main window are:</p> <ol> <li>Check connections panel (section Check connections)</li> <li>Ground gimbal control panel (section Ground gimbal)</li> <li>Drone gimbal control panel (section Drone gimbal)</li> <li>Sivers settings configuration panel (section Sivers settings)</li> <li>Power Angular Profile visualization panel (section Visualize PAP)</li> <li>GPS visualization panel (section Visualize GPS)</li> <li>Control measurements panel (section Control measurements)</li> <li>Terminal panel (section Terminal)</li> </ol>"},{"location":"PanelsGUI/#check-connections-panel","title":"Check connections panel","text":"<p>This panel shows which of the devices of each node (ground and air) are connected to their respective host computers. The state for the connection between the device and the host computer could be <code>False</code>, <code>True</code> or <code>None</code>, and is assessed by the <code>Check</code> button. </p> <p>The <code>None</code> value is used when a connection could not be checked and so the state of the connection is not known. </p> <p>A wireless connection won't be allowed (the Connect button will not be available) until the user presses the <code>Check</code> button a first time.</p> <p>The <code>Connect</code> button will be available for the user to establish a wireless connection between both nodes, even if no devices are connected to either host computer. However, no functionality will be available as no devices are detected by the host computers of each node. </p> <p>As a consequence of this, after the user sees the state of the connections under the <code>Check connections</code> Panel, any device that is not connected won't be available, and it is thus the choice of the user to press the <code>Connect</code> button immediately or review again the proper connections between the devices and their hosts and press the <code>Connect</code> button after the desired devices are connected to their host.</p> <p>For implement changes to this behaviour of the GUI, see the section Dev connections.</p>"},{"location":"PanelsGUI/#ground-gimbal-panel","title":"Ground gimbal panel","text":""},{"location":"PanelsGUI/#drone-gimbal-panel","title":"Drone gimbal panel","text":""},{"location":"PanelsGUI/#sivers-settings-panel","title":"Sivers settings panel","text":"<p>It is not possible to change the Sivers settings during a measurement. To change Sivers settings, first stop a measurement by pressing <code>STOP</code>, then press <code>FINISH</code>, and then procede to change the Sivers settings.</p>"},{"location":"PanelsGUI/#power-angular-profile-panel","title":"Power Angular Profile panel","text":"<p>The Power Angular Profile (PAP) is computed from the sensed Channel Impulse Response (CIR). The power of each and all delay bins is added to obtain the PAP. This is done for each of the beam angles.</p> <p>The actual rate at which the PAP changes depends on the rate at which the channel changes. The visualization panel updates the displayed image each 100 ms, meaning that changes faster than 10 Hz will not be seen in the visualization panel.</p>"},{"location":"PanelsGUI/#gps-visualization-panel","title":"GPS visualization panel","text":""},{"location":"PanelsGUI/#control-measurements-panel","title":"Control measurements panel","text":""},{"location":"PanelsGUI/#terminal-panel","title":"Terminal panel","text":""},{"location":"PlanningMeasurements/","title":"Wireless Channel Measuremnets Planner","text":"<p>This tool provides the user a way of placing candidate coordinates for the air node through the use of markers in a map.</p> <p>The order in which the markers are placed in the map is assumed to be the order in which the air node will arrive at those marker locations.</p>"},{"location":"PlanningMeasurements/#note-on-the-wireless-channel-measurements-planner","title":"Note on the Wireless Channel Measurements Planner","text":"<p>Thye purpose of this web app is to place the points where both the receiver and the transmitter will be placed on a map.</p> <p>Ulitmately the placing of the transceivers depends on observing candidate locations in a map source (i.e. Google Maps, OpenStreetMap, etc). Therefore it is easier to have a tool to read the candidate locations input by the user using a map service, for post processing them in whichever task has been thought.</p> <p>Unfortunately, neither <code>Folium</code>, nor <code>Ipyleaflet</code> or similar python packages provide support to retrieve the marker coordinates, since they use as the core technology to interact with OpenStreetMaps a <code>javascript</code> library called <code>Leaflet.js</code>, which handles the user interactions with the map. </p>"},{"location":"RFSoCHandler/","title":"Communication with the RFSoC","text":"<p>Python class that implements all functionality for the communication between a host computer (client) and the RFSoC (server) connected through Ethernet to it. </p> <p>Configures the antenna front end (Sivers EVK) parameters. The antenna front end is responsible for upconverting the frequency, beamforming and providing the physical interface with the air.</p> <p>Implements the client side (host computer) functionality of the TCP connection. </p> <p>Most of the methods of this class were developed by Panagiotis Skrimponis. They were integrated in a class and extended by Julian D. Villegas G.</p> Source code in <code>a2gmeasurements.py</code> <pre><code>class RFSoCRemoteControlFromHost():\n    \"\"\"\n    Python class that implements all functionality for the communication between a host computer (client) and the RFSoC (server) connected through Ethernet to it. \n\n    Configures the antenna front end (Sivers EVK) parameters. The antenna front end is responsible for upconverting the frequency, beamforming and providing the physical interface with the air.\n\n    Implements the client side (host computer) functionality of the TCP connection. \n\n    Most of the methods of this class were developed by Panagiotis Skrimponis. They were integrated in a class and extended by Julian D. Villegas G.\n    \"\"\"\n    def __init__(self, radio_control_port=8080, radio_data_port=8081, rfsoc_static_ip_address='10.1.1.40', filename='PDAPs', operating_freq=57.51e9):\n        \"\"\"\n        Creates two sockets: one for control commands and another for transfer data.\n\n        Establish the connection between the client and the RFSoC.\n\n        Some important attributes of this class are:\n\n         1. ``beam_idx_for_vis``: this attribute sets the index of the beams of the measured Channel Impulse Response (CIR) that are sent from the drone node to the ground node to be displayed in the GUI.\n\n         2. ``TIME_SNAPS_TO_SAVE``: number of CIR snapshots to collect before save them on disk.\n\n         3. ``TIME_SNAPS_TO_VIS``: number of CIR snapshots to be displayed. This value is set depending on the max bytes that can be send through Ethernet in a single message (i.e. 22 time snaps * 16 beams * 4 bytes-per-PAP-entry = 1408 bytes)\n\n         4. ``nbeams``: number of beams of the CIR to be retrieved from the server.\n\n         5. ``nread``: number of delay taps of the CIR to be retrieved from the server.\n\n         6. ``nbytes``: number of bytes of a full CIR (1 time snapshot, 64 beams, 1024 delay taps)\n\n         7. ``beam_angles``: list of beam angles used in beamforming. Beam angle at index 0 corresponds to the omnidirectional case.\n\n        Args:\n            radio_control_port (int, optional): port for \"control socket\". Defaults to 8080.\n            radio_data_port (int, optional): port for \"data socket\". Defaults to 8081.\n            rfsoc_static_ip_address (str, optional): static IP address of the rfsoc ethernet interface. Defaults to '10.1.1.40'.\n            filename (str, optional): name to be used when saving the CIRs. Defaults to 'PDAPs'.\n            operating_freq (_type_, optional): operating frequency for the antenna array front end. Defaults to 57.51e9.\n        \"\"\"\n\n        self.operating_freq = operating_freq\n        self.radio_control_port = radio_control_port\n        self.radio_data_port = radio_data_port\n        self.filename_to_save = filename\n        self.hest = []\n        self.meas_time_tag = []\n        self.RFSoCSuccessExecutionAns = \"Successully executed\"\n        self.RFSoCSuccessAns = \"Success\"\n        self.n_receive_calls = 0\n        self.time_begin_receive_call = 0\n        self.time_finish_receive_call = 0\n        self.time_begin_receive_thread = 0\n        self.time_finish_receive_thread = 0\n        self.beam_idx_for_vis = [i*4 for i in range(0, 16)]\n        self.bytes_per_irf = 64*1024*16 # Exactly 1 MB\n        self.irfs_per_second = 7 # THIS MUST BE FOUND IN BETTER A WAY\n        self.TIME_SNAPS_TO_SAVE = 220  \n        self.MAX_PAP_BUF_SIZE_BYTES = self.TIME_SNAPS_TO_SAVE * self.bytes_per_irf\n        self.TIME_SNAPS_TO_VIS = 22\n        self.TIME_GET_IRF = 0.14\n        self.nbeams = 64\n        nbytes_per_item = 2\n        self.nread = 1024\n        self.nbytes = self.nbeams * nbytes_per_item * self.nread * 2 # Beams x SubCarriers(delay taps) x 2Bytes from  INT16 x 2 frpm Real and Imaginary\n\n        beamforming_angles_file = \"C:\\\\Users\\\\jvjulian\\\\OneDrive - Teknologian Tutkimuskeskus VTT\\\\Documents\\\\Aerial\\\\Repos\\\\a2gMeasurements\\\\data\\\\rx_sivers_beam_index_mapping.csv\"\n\n        self.beam_angles = [0]*64\n\n        # Get the beamforming angles\n        with open(beamforming_angles_file, 'r') as f:\n            reader = csv.reader(f, delimiter=\",\")\n            for cnt, row in enumerate(reader):\n                self.beam_angles[cnt] = float(row[1])\n\n        self.radio_control = socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM)\n        self.radio_control.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        self.radio_data = socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM)\n        self.radio_data.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n\n        try:\n            self.radio_control.connect((rfsoc_static_ip_address, radio_control_port))\n            self.radio_data.connect((rfsoc_static_ip_address, radio_data_port))\n        except Exception as e:\n            print(\"[DEBUG]: Error in rfsoc socket connection: \", e)\n            print(\"[DEBUG]: Check RFSoC ETH, and Power it Off and On\")\n\n    def send_cmd(self, cmd, cmd_arg=None):\n        \"\"\"\n        Sends a command to the RFSoC server. \n\n        These commands control the Sivers EVK mode, carrier frequncy, tx gain and rx gain.\n\n        Args:\n            cmd (str): available commands are: ``setModeSivers``, ``setCarrierFrequencySivers``, ``setGainTxSivers``, ``setGainRxSivers``.\n            cmd_arg (str | float | dict, optional): supported parameters for 'setModeSivers' are 'RXen_0_TXen1', 'RXen1_TXen0', 'RXen0_TXen0'; supported parameters for 'setCarrierFrequencySivers' are float number, i.e.: 57.51e9; supported parameters for 'setGainTxSivers' are dict with this structure {'tx_bb_gain': 0x00, 'tx_bb_phase': 0x00, 'tx_bb_iq_gain': 0x00, 'tx_bfrf_gain': 0x00}; supported parameters for 'setGainRxSivers' are dict with this structure {'rx_gain_ctrl_bb1':0x00, 'rx_gain_ctrl_bb2':0x00, 'rx_gain_ctrl_bb3':0x00, 'rx_gain_ctrl_bfrf':0x00}. Defaults to None.\n        \"\"\"\n\n        try:\n            if cmd == 'setModeSivers':\n                if cmd_arg == 'RXen0_TXen1' or cmd_arg == 'RXen1_TXen0' or cmd_arg == 'RXen0_TXen0':\n                    self.radio_control.sendall(b\"setModeSiver \"+str.encode(str(cmd_arg)))\n                else:\n                    print(\"[DEBUG]: Unknown Sivers mode\")\n            elif cmd == 'setCarrierFrequencySivers':\n                self.radio_control.sendall(b\"setCarrierFrequency \"+str.encode(str(cmd_arg)))\n            elif cmd == 'setGainTxSivers':\n                tx_bb_gain = cmd_arg['tx_bb_gain']\n                tx_bb_phase = cmd_arg['tx_bb_phase']\n                tx_bb_iq_gain = cmd_arg['tx_bb_iq_gain']\n                tx_bfrf_gain = cmd_arg['tx_bfrf_gain']\n\n                self.radio_control.sendall(b\"setGainTX \" + str.encode(str(int(tx_bb_gain)) + \" \") \\\n                                                            + str.encode(str(int(tx_bb_phase)) + \" \") \\\n                                                            + str.encode(str(int(tx_bb_iq_gain)) + \" \") \\\n                                                            + str.encode(str(int(tx_bfrf_gain))))\n            elif cmd == 'setGainRxSivers':\n                rx_gain_ctrl_bb1 = cmd_arg['rx_gain_ctrl_bb1']\n                rx_gain_ctrl_bb2 = cmd_arg['rx_gain_ctrl_bb2']\n                rx_gain_ctrl_bb3 = cmd_arg['rx_gain_ctrl_bb3']\n                rx_gain_ctrl_bfrf = cmd_arg['rx_gain_ctrl_bfrf']\n\n                self.radio_control.sendall(b\"setGainRX \" + str.encode(str(int(rx_gain_ctrl_bb1)) + \" \") \\\n                                                            + str.encode(str(int(rx_gain_ctrl_bb2)) + \" \") \\\n                                                            + str.encode(str(int(rx_gain_ctrl_bb3)) + \" \") \\\n                                                            + str.encode(str(int(rx_gain_ctrl_bfrf))))\n            elif cmd == 'transmitSamples':\n                self.radio_control.sendall(b\"transmitSamples\")\n            else: \n                print(\"[DEBUG]: Unknown command to send to RFSoC\")\n                return\n        except IOError as e:\n            if e.errno == errno.EPIPE:\n                print(\"[ERROR]: RFSoC to Host connection has problems: \", e)\n        else:\n            data = self.radio_control.recv(1024)\n            data = data.decode('utf-8')\n\n            if self.RFSoCSuccessExecutionAns in data or self.RFSoCSuccessAns in data:\n                print(\"[DEBUG]: Command \", cmd, \" executed succesfully on Sivers or RFSoC\")\n            else:\n                print(\"[DEBUG]: Command \", cmd, \" was not successfully executed on Sivers or RFSoC. The following error appears: \", data)\n\n    def transmit_signal(self, tx_bb_gain=0x3, tx_bb_phase=0, tx_bb_iq_gain=0x77, tx_bfrf_gain=0x40, carrier_freq=57.51e9):\n        \"\"\"\n        Sets Tx gains and frequency of operation. Wrapper function of ``send_cmd``.\n\n        More about TX gains is found in the Sivers EVK manual/reference guides.\n\n        Args:\n            tx_bb_gain (hexadecimal, optional): sets baseband gain according to: 0x00  = 0 dB, 0x01  = 3.5 dB, 0x02  = 3.5 dB, 0x03  = 6 dB (when sivers register tx_ctrl bit 3 (BB Ibias set) = 1). Defaults to 0x3.\n            tx_bb_phase (int, optional): _description_. Defaults to 0.\n            tx_bb_iq_gain (hexadecimal, optional): sets baseband I, Q gain according to: [0:3, I gain]: 0-6 dB, 16 steps; [4:7, Q gain]: 0-6 dB, 16 steps. Defaults to 0x77.\n            tx_bfrf_gain (hexadecimal, optional): sets gain after RF mixer according to: [0:3, RF gain]: 0-15 dB, 16 steps; [4:7, BF gain]: 0-15 dB, 16 steps. Defaults to 0x40.\n            carrier_freq (_type_, optional): carrier frequency from the available frequency range for the Sivers EVK 06002/3 (in this case: 57-71 GHz). Defaults to 57.51e9.\n        \"\"\"\n\n        dict_tx_gains = {'tx_bb_gain': tx_bb_gain, 'tx_bb_phase': tx_bb_phase, 'tx_bb_iq_gain': tx_bb_iq_gain, 'tx_bfrf_gain': tx_bfrf_gain}\n\n        self.send_cmd('transmitSamples')\n        self.send_cmd('setModeSivers', cmd_arg='RXen0_TXen1')\n        self.send_cmd('setCarrierFrequencySivers', cmd_arg=carrier_freq)\n        self.send_cmd('setGainTxSivers', cmd_arg=dict_tx_gains)\n\n    def set_rx_rf(self, rx_gain_ctrl_bb1=0x77, rx_gain_ctrl_bb2=0x00, rx_gain_ctrl_bb3=0x99, rx_gain_ctrl_bfrf=0xFF, carrier_freq=57.51e9):\n        \"\"\"\n        Sets rx gains and frequency of operation. Wrapper function of ``send_cmd``.\n\n        Args:\n            rx_gain_ctrl_bb1 (hexadecimal, optional): sets the first rx gain for the I,Q according to: I[0:3]:[0,1,3,7,F]:-6:0 dB, 4 steps; Q[0:3]:[0,1,3,7,F]:-6:0 dB, 4 steps. Defaults to 0x77.\n            rx_gain_ctrl_bb2 (hexadecimal, optional): sets the second rx gain for the I,Q according to: I[0:3]:[0,1,3,7,F]:-6:0 dB, 4 steps; Q[0:3]:[0,1,3,7,F]:-6:0 dB, 4 steps. Defaults to 0x00.\n            rx_gain_ctrl_bb3 (hexadecimal, optional): sets the third rx gain for the I,Q according to: I[0:3]:[0,1,3,7,F]:-6:0 dB, 4 steps; Q[0:3]:[0,1,3,7,F]:-6:0 dB, 4 steps. Defaults to 0x99.\n            rx_gain_ctrl_bfrf (_type_, optional): sets gain after the mixer according to; [0:3,RF gain]: 0-15 dB, 16 steps; [4:7, BF gain]: 0-15 dB, 16 steps. Defaults to 0xFF.\n            carrier_freq (_type_, optional): carrier frequency from the available frequency range for the Sivers EVK 06002/3 (in this case: 57-71 GHz). Defaults to 57.51e9.\n        \"\"\"\n\n        dict_rx_gains = {'rx_gain_ctrl_bb1':rx_gain_ctrl_bb1, 'rx_gain_ctrl_bb2':rx_gain_ctrl_bb2, 'rx_gain_ctrl_bb3':rx_gain_ctrl_bb3, 'rx_gain_ctrl_bfrf':rx_gain_ctrl_bfrf}\n\n        self.send_cmd('setModeSivers', cmd_arg='RXen1_TXen0')\n        self.send_cmd('setCarrierFrequencySivers', cmd_arg=carrier_freq)\n        self.send_cmd('setGainRxSivers', cmd_arg=dict_rx_gains)\n\n    def receive_signal_async(self, stop_event):\n        \"\"\"\n        Callback for the thread responsible for retrieving CIRs from RFSoC server (rfsoc thread).\n\n        When enough (``self.TIME_SNAPS_TO_VIS``) CIR time snapshots are available, computes the Power Angular Profile to be sent to the ground node for displaying it in the GUI.\n\n        When enough (``self.TIME_SNAPS_TO_SAVE``) CIR time snapshots are available, saves the CIRs on disk.\n\n        Args:\n            stop_event (threading.Event): when set, this function does nothing (the thread can be alived but does nothing)\n        \"\"\"\n\n        while not stop_event.is_set():\n            self.n_receive_calls = self.n_receive_calls + 1\n            self.radio_control.sendall(b\"receiveSamples\")\n            buf = bytearray()\n\n            while len(buf) &lt; self.nbytes:\n                data = self.radio_data.recv(self.nbytes)\n                buf.extend(data)\n            data = np.frombuffer(buf, dtype=np.int16)\n            rxtd = data[:self.nread*self.nbeams] + 1j*data[self.nread*self.nbeams:]\n            rxtd = rxtd.reshape(self.nbeams, self.nread)\n\n            self.hest.append(rxtd)\n\n            if len(self.hest) == self.TIME_SNAPS_TO_VIS:\n                self.data_to_visualize = self.pipeline_operations_rfsoc_rx_ndarray(np.array(self.hest), 2)\n\n            if len(self.hest) &gt; self.TIME_SNAPS_TO_VIS: # maximum packet size to send over the tcp connection\n                tmp = self.pipeline_operations_rfsoc_rx_ndarray(rxtd, 1)\n                self.data_to_visualize = np.roll(self.data_to_visualize, -1, axis=0) \n                self.data_to_visualize[-1, :] = tmp \n\n            if len(self.hest) &gt;= self.TIME_SNAPS_TO_SAVE:\n                print(f\"[DEBUG]: Time between save callbacks: {time.time() - self.start_time_pap_callback}\")\n                self.save_hest_buffer()      \n\n    def maximum_power_direction(self, array):\n        \"\"\"\n        Computes the beamforming angle (azimuth) of maximum power at the receiver.\n\n        The time under consideration should be short or less than the inverse of the rate of change of the direction of maximum power.\n\n        The rate of change of the direction of maximum power is not easy to compute or assume, but we can restrict the computation of the direction to a window of a given ms.\n\n        Args:\n            array (numpy.ndarray): this is the array having the IRFs. Its dimensionality is Time x 64 x 2044.\n\n        Returns:\n            angleMaxPower (list): contains the (azimuth) angles for maximum power across all the time snapshots considered. Has 64 entries.\n        \"\"\"\n        aux = np.abs(array) \n        aux = aux * aux # faster pow 2\n        aux = np.sum(aux, axis=2)\n\n        # This is an Nbeams array\n        idx_max_power = np.argmax(aux, axis=0)\n        return self.beam_angles[idx_max_power]        \n\n    def pipeline_operations_rfsoc_rx_ndarray(self, array, axis, each_n_beams=4):\n        \"\"\"\n        Computes the PAP for a single snapshot CIR (64 beams * 1024 delay taps) or the PAPs of multiple snapshots CIR (snaps * 64 beams * 1024 delay taps).\n\n        Args:\n            array (numpy.ndarray): CIRs. If it has 2 dimensions the CIR correspond to a single snapshot, if it has 3 dimensions, the CIR correspond to multiple snapshots.\n            axis (int): delay tap axis, either 0, 1 and 2.\n            each_n_beams (int, optional): subsample the 64 beams by this value. Defaults to 4.\n\n        Returns:\n            aux (numpy.ndarray): computed PAP \"subsampled\" version.\n        \"\"\"\n\n        if axis &gt;= len(array.shape):\n            print(f\"[DEBUG]: Invalid axis over which to add entries. The array has: {len(array.shape)} dimensions\")\n            return 0\n\n        aux = np.abs(array) \n        aux = aux * aux # faster pow 2\n        aux = np.sum(aux, axis=axis)\n        if axis==1:\n            aux = aux[::each_n_beams]\n        elif axis==2:\n            aux = aux[:, ::each_n_beams]\n        else:\n            print(\"[ERROR]: Wrong axis over which to do pipeline_operations_rfsoc_rx_ndarray\")\n        # Compute 10-time-snaps block mean\n        #self.data_to_visualize = compute_block_mean_2d_array(self.data_to_visualize, 10)\n\n        aux = np.asarray(aux, dtype=np.float32)\n        return aux\n\n    def save_hest_buffer(self, register_time=True):\n        \"\"\"\n        Saves the raw (time-snaps, n_beams, n_delay_taps) CIR array.\n\n        Args:\n            register_time (bool, optional): parameter used for debugging purposes. Defaults to True.\n        \"\"\"\n\n        datestr = datetime.datetime.now()\n        datestr = datestr.strftime('%Y-%m-%d-%H-%M-%S-%f')\n\n        # Double check that there is something in the array\n        if len(self.hest) &gt; 0:\n            with open('../Measurement Files/' + datestr + '-' + self.filename_to_save + '.npy', 'wb') as f:\n                #np.save(f, np.stack(self.hest, axis=0))\n                np.save(f, np.array(self.hest))\n\n            print(\"[DEBUG]: Saved file \", datestr + self.filename_to_save + '.npy')\n            print(\"[DEBUG]: Saved file \", datestr + self.filename_to_save + '-TIMETAGS' + '.npy')\n            self.hest = []\n\n        if register_time:\n            self.start_time_pap_callback = time.time()\n\n    def start_thread_receive_meas_data(self, msg_data):\n        \"\"\"\n        Creates and starts the rfsoc thread.\n\n        A thread -instead of a subprocess- is good enough since the computational expense of the task is not donde in the host computer but in the RFSoC. The host just reads the data through Ethernet.\n\n        A new thread is started each time this function is called. It is required for the developer to call 'stop_thread_receive_meas_data' before calling again this function in order to close the actual thread before creating a new one.\n\n        Args:\n            msg_data (dict): dictionary containing the parameters required by ``set_rx_rf`` to set a Sivers EVK configuration. \n        \"\"\"\n\n        self.event_stop_thread_rx_irf = threading.Event()                \n        self.thread_rx_irf = threading.Thread(target=self.receive_signal_async, args=(self.event_stop_thread_rx_irf,))\n        self.set_rx_rf(carrier_freq=msg_data['carrier_freq'],\n                       rx_gain_ctrl_bb1=msg_data['rx_gain_ctrl_bb1'],\n                       rx_gain_ctrl_bb2=msg_data['rx_gain_ctrl_bb2'],\n                       rx_gain_ctrl_bb3=msg_data['rx_gain_ctrl_bb3'],\n                       rx_gain_ctrl_bfrf=msg_data['rx_gain_ctrl_bfrf'])\n        time.sleep(0.1)\n        self.time_begin_receive_thread = time.time()\n        self.thread_rx_irf.start()\n        self.start_time_pap_callback = time.time()\n\n        print(\"[DEBUG]: receive_signal_async thread STARTED\")\n\n    def stop_thread_receive_meas_data(self):\n        \"\"\"\n        Stops the rfsoc thread and saves remaining CIRs.\n        \"\"\"\n\n        self.event_stop_thread_rx_irf.set()\n        self.time_finish_receive_thread = time.time()\n        print(\"[DEBUG]: receive_signal_async thread STOPPED\")\n        print(\"[DEBUG]: Received calls: \", self.n_receive_calls)\n        print(\"[DEBUG]: Avg. time of execution of 'receive_signal' callback is \", ((self.time_finish_receive_thread - self.time_begin_receive_thread)/self.n_receive_calls))\n\n        self.save_hest_buffer(self, register_time=False)\n\n        self.n_receive_calls = 0\n\n    def finish_measurement(self):\n        \"\"\"\n        Kills the rfsoc if it is still alive and saves the remaining CIRs.\n        \"\"\"\n        # Check if the thread is finished and if not stop it\n        if self.thread_rx_irf.is_alive():\n            self.stop_thread_receive_meas_data()\n\n        self.save_hest_buffer(self, register_time=False)\n</code></pre>"},{"location":"RFSoCHandler/#a2gmeasurements.RFSoCRemoteControlFromHost.__init__","title":"<code>__init__(radio_control_port=8080, radio_data_port=8081, rfsoc_static_ip_address='10.1.1.40', filename='PDAPs', operating_freq=57510000000.0)</code>","text":"<p>Creates two sockets: one for control commands and another for transfer data.</p> <p>Establish the connection between the client and the RFSoC.</p> <p>Some important attributes of this class are:</p> <ol> <li> <p><code>beam_idx_for_vis</code>: this attribute sets the index of the beams of the measured Channel Impulse Response (CIR) that are sent from the drone node to the ground node to be displayed in the GUI.</p> </li> <li> <p><code>TIME_SNAPS_TO_SAVE</code>: number of CIR snapshots to collect before save them on disk.</p> </li> <li> <p><code>TIME_SNAPS_TO_VIS</code>: number of CIR snapshots to be displayed. This value is set depending on the max bytes that can be send through Ethernet in a single message (i.e. 22 time snaps * 16 beams * 4 bytes-per-PAP-entry = 1408 bytes)</p> </li> <li> <p><code>nbeams</code>: number of beams of the CIR to be retrieved from the server.</p> </li> <li> <p><code>nread</code>: number of delay taps of the CIR to be retrieved from the server.</p> </li> <li> <p><code>nbytes</code>: number of bytes of a full CIR (1 time snapshot, 64 beams, 1024 delay taps)</p> </li> <li> <p><code>beam_angles</code>: list of beam angles used in beamforming. Beam angle at index 0 corresponds to the omnidirectional case.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>radio_control_port</code> <code>int</code> <p>port for \"control socket\". Defaults to 8080.</p> <code>8080</code> <code>radio_data_port</code> <code>int</code> <p>port for \"data socket\". Defaults to 8081.</p> <code>8081</code> <code>rfsoc_static_ip_address</code> <code>str</code> <p>static IP address of the rfsoc ethernet interface. Defaults to '10.1.1.40'.</p> <code>'10.1.1.40'</code> <code>filename</code> <code>str</code> <p>name to be used when saving the CIRs. Defaults to 'PDAPs'.</p> <code>'PDAPs'</code> <code>operating_freq</code> <code>_type_</code> <p>operating frequency for the antenna array front end. Defaults to 57.51e9.</p> <code>57510000000.0</code> Source code in <code>a2gmeasurements.py</code> <pre><code>def __init__(self, radio_control_port=8080, radio_data_port=8081, rfsoc_static_ip_address='10.1.1.40', filename='PDAPs', operating_freq=57.51e9):\n    \"\"\"\n    Creates two sockets: one for control commands and another for transfer data.\n\n    Establish the connection between the client and the RFSoC.\n\n    Some important attributes of this class are:\n\n     1. ``beam_idx_for_vis``: this attribute sets the index of the beams of the measured Channel Impulse Response (CIR) that are sent from the drone node to the ground node to be displayed in the GUI.\n\n     2. ``TIME_SNAPS_TO_SAVE``: number of CIR snapshots to collect before save them on disk.\n\n     3. ``TIME_SNAPS_TO_VIS``: number of CIR snapshots to be displayed. This value is set depending on the max bytes that can be send through Ethernet in a single message (i.e. 22 time snaps * 16 beams * 4 bytes-per-PAP-entry = 1408 bytes)\n\n     4. ``nbeams``: number of beams of the CIR to be retrieved from the server.\n\n     5. ``nread``: number of delay taps of the CIR to be retrieved from the server.\n\n     6. ``nbytes``: number of bytes of a full CIR (1 time snapshot, 64 beams, 1024 delay taps)\n\n     7. ``beam_angles``: list of beam angles used in beamforming. Beam angle at index 0 corresponds to the omnidirectional case.\n\n    Args:\n        radio_control_port (int, optional): port for \"control socket\". Defaults to 8080.\n        radio_data_port (int, optional): port for \"data socket\". Defaults to 8081.\n        rfsoc_static_ip_address (str, optional): static IP address of the rfsoc ethernet interface. Defaults to '10.1.1.40'.\n        filename (str, optional): name to be used when saving the CIRs. Defaults to 'PDAPs'.\n        operating_freq (_type_, optional): operating frequency for the antenna array front end. Defaults to 57.51e9.\n    \"\"\"\n\n    self.operating_freq = operating_freq\n    self.radio_control_port = radio_control_port\n    self.radio_data_port = radio_data_port\n    self.filename_to_save = filename\n    self.hest = []\n    self.meas_time_tag = []\n    self.RFSoCSuccessExecutionAns = \"Successully executed\"\n    self.RFSoCSuccessAns = \"Success\"\n    self.n_receive_calls = 0\n    self.time_begin_receive_call = 0\n    self.time_finish_receive_call = 0\n    self.time_begin_receive_thread = 0\n    self.time_finish_receive_thread = 0\n    self.beam_idx_for_vis = [i*4 for i in range(0, 16)]\n    self.bytes_per_irf = 64*1024*16 # Exactly 1 MB\n    self.irfs_per_second = 7 # THIS MUST BE FOUND IN BETTER A WAY\n    self.TIME_SNAPS_TO_SAVE = 220  \n    self.MAX_PAP_BUF_SIZE_BYTES = self.TIME_SNAPS_TO_SAVE * self.bytes_per_irf\n    self.TIME_SNAPS_TO_VIS = 22\n    self.TIME_GET_IRF = 0.14\n    self.nbeams = 64\n    nbytes_per_item = 2\n    self.nread = 1024\n    self.nbytes = self.nbeams * nbytes_per_item * self.nread * 2 # Beams x SubCarriers(delay taps) x 2Bytes from  INT16 x 2 frpm Real and Imaginary\n\n    beamforming_angles_file = \"C:\\\\Users\\\\jvjulian\\\\OneDrive - Teknologian Tutkimuskeskus VTT\\\\Documents\\\\Aerial\\\\Repos\\\\a2gMeasurements\\\\data\\\\rx_sivers_beam_index_mapping.csv\"\n\n    self.beam_angles = [0]*64\n\n    # Get the beamforming angles\n    with open(beamforming_angles_file, 'r') as f:\n        reader = csv.reader(f, delimiter=\",\")\n        for cnt, row in enumerate(reader):\n            self.beam_angles[cnt] = float(row[1])\n\n    self.radio_control = socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM)\n    self.radio_control.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    self.radio_data = socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM)\n    self.radio_data.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n\n    try:\n        self.radio_control.connect((rfsoc_static_ip_address, radio_control_port))\n        self.radio_data.connect((rfsoc_static_ip_address, radio_data_port))\n    except Exception as e:\n        print(\"[DEBUG]: Error in rfsoc socket connection: \", e)\n        print(\"[DEBUG]: Check RFSoC ETH, and Power it Off and On\")\n</code></pre>"},{"location":"RFSoCHandler/#a2gmeasurements.RFSoCRemoteControlFromHost.finish_measurement","title":"<code>finish_measurement()</code>","text":"<p>Kills the rfsoc if it is still alive and saves the remaining CIRs.</p> Source code in <code>a2gmeasurements.py</code> <pre><code>def finish_measurement(self):\n    \"\"\"\n    Kills the rfsoc if it is still alive and saves the remaining CIRs.\n    \"\"\"\n    # Check if the thread is finished and if not stop it\n    if self.thread_rx_irf.is_alive():\n        self.stop_thread_receive_meas_data()\n\n    self.save_hest_buffer(self, register_time=False)\n</code></pre>"},{"location":"RFSoCHandler/#a2gmeasurements.RFSoCRemoteControlFromHost.maximum_power_direction","title":"<code>maximum_power_direction(array)</code>","text":"<p>Computes the beamforming angle (azimuth) of maximum power at the receiver.</p> <p>The time under consideration should be short or less than the inverse of the rate of change of the direction of maximum power.</p> <p>The rate of change of the direction of maximum power is not easy to compute or assume, but we can restrict the computation of the direction to a window of a given ms.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>this is the array having the IRFs. Its dimensionality is Time x 64 x 2044.</p> required <p>Returns:</p> Name Type Description <code>angleMaxPower</code> <code>list</code> <p>contains the (azimuth) angles for maximum power across all the time snapshots considered. Has 64 entries.</p> Source code in <code>a2gmeasurements.py</code> <pre><code>def maximum_power_direction(self, array):\n    \"\"\"\n    Computes the beamforming angle (azimuth) of maximum power at the receiver.\n\n    The time under consideration should be short or less than the inverse of the rate of change of the direction of maximum power.\n\n    The rate of change of the direction of maximum power is not easy to compute or assume, but we can restrict the computation of the direction to a window of a given ms.\n\n    Args:\n        array (numpy.ndarray): this is the array having the IRFs. Its dimensionality is Time x 64 x 2044.\n\n    Returns:\n        angleMaxPower (list): contains the (azimuth) angles for maximum power across all the time snapshots considered. Has 64 entries.\n    \"\"\"\n    aux = np.abs(array) \n    aux = aux * aux # faster pow 2\n    aux = np.sum(aux, axis=2)\n\n    # This is an Nbeams array\n    idx_max_power = np.argmax(aux, axis=0)\n    return self.beam_angles[idx_max_power]        \n</code></pre>"},{"location":"RFSoCHandler/#a2gmeasurements.RFSoCRemoteControlFromHost.pipeline_operations_rfsoc_rx_ndarray","title":"<code>pipeline_operations_rfsoc_rx_ndarray(array, axis, each_n_beams=4)</code>","text":"<p>Computes the PAP for a single snapshot CIR (64 beams * 1024 delay taps) or the PAPs of multiple snapshots CIR (snaps * 64 beams * 1024 delay taps).</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>CIRs. If it has 2 dimensions the CIR correspond to a single snapshot, if it has 3 dimensions, the CIR correspond to multiple snapshots.</p> required <code>axis</code> <code>int</code> <p>delay tap axis, either 0, 1 and 2.</p> required <code>each_n_beams</code> <code>int</code> <p>subsample the 64 beams by this value. Defaults to 4.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>aux</code> <code>ndarray</code> <p>computed PAP \"subsampled\" version.</p> Source code in <code>a2gmeasurements.py</code> <pre><code>def pipeline_operations_rfsoc_rx_ndarray(self, array, axis, each_n_beams=4):\n    \"\"\"\n    Computes the PAP for a single snapshot CIR (64 beams * 1024 delay taps) or the PAPs of multiple snapshots CIR (snaps * 64 beams * 1024 delay taps).\n\n    Args:\n        array (numpy.ndarray): CIRs. If it has 2 dimensions the CIR correspond to a single snapshot, if it has 3 dimensions, the CIR correspond to multiple snapshots.\n        axis (int): delay tap axis, either 0, 1 and 2.\n        each_n_beams (int, optional): subsample the 64 beams by this value. Defaults to 4.\n\n    Returns:\n        aux (numpy.ndarray): computed PAP \"subsampled\" version.\n    \"\"\"\n\n    if axis &gt;= len(array.shape):\n        print(f\"[DEBUG]: Invalid axis over which to add entries. The array has: {len(array.shape)} dimensions\")\n        return 0\n\n    aux = np.abs(array) \n    aux = aux * aux # faster pow 2\n    aux = np.sum(aux, axis=axis)\n    if axis==1:\n        aux = aux[::each_n_beams]\n    elif axis==2:\n        aux = aux[:, ::each_n_beams]\n    else:\n        print(\"[ERROR]: Wrong axis over which to do pipeline_operations_rfsoc_rx_ndarray\")\n    # Compute 10-time-snaps block mean\n    #self.data_to_visualize = compute_block_mean_2d_array(self.data_to_visualize, 10)\n\n    aux = np.asarray(aux, dtype=np.float32)\n    return aux\n</code></pre>"},{"location":"RFSoCHandler/#a2gmeasurements.RFSoCRemoteControlFromHost.receive_signal_async","title":"<code>receive_signal_async(stop_event)</code>","text":"<p>Callback for the thread responsible for retrieving CIRs from RFSoC server (rfsoc thread).</p> <p>When enough (<code>self.TIME_SNAPS_TO_VIS</code>) CIR time snapshots are available, computes the Power Angular Profile to be sent to the ground node for displaying it in the GUI.</p> <p>When enough (<code>self.TIME_SNAPS_TO_SAVE</code>) CIR time snapshots are available, saves the CIRs on disk.</p> <p>Parameters:</p> Name Type Description Default <code>stop_event</code> <code>Event</code> <p>when set, this function does nothing (the thread can be alived but does nothing)</p> required Source code in <code>a2gmeasurements.py</code> <pre><code>def receive_signal_async(self, stop_event):\n    \"\"\"\n    Callback for the thread responsible for retrieving CIRs from RFSoC server (rfsoc thread).\n\n    When enough (``self.TIME_SNAPS_TO_VIS``) CIR time snapshots are available, computes the Power Angular Profile to be sent to the ground node for displaying it in the GUI.\n\n    When enough (``self.TIME_SNAPS_TO_SAVE``) CIR time snapshots are available, saves the CIRs on disk.\n\n    Args:\n        stop_event (threading.Event): when set, this function does nothing (the thread can be alived but does nothing)\n    \"\"\"\n\n    while not stop_event.is_set():\n        self.n_receive_calls = self.n_receive_calls + 1\n        self.radio_control.sendall(b\"receiveSamples\")\n        buf = bytearray()\n\n        while len(buf) &lt; self.nbytes:\n            data = self.radio_data.recv(self.nbytes)\n            buf.extend(data)\n        data = np.frombuffer(buf, dtype=np.int16)\n        rxtd = data[:self.nread*self.nbeams] + 1j*data[self.nread*self.nbeams:]\n        rxtd = rxtd.reshape(self.nbeams, self.nread)\n\n        self.hest.append(rxtd)\n\n        if len(self.hest) == self.TIME_SNAPS_TO_VIS:\n            self.data_to_visualize = self.pipeline_operations_rfsoc_rx_ndarray(np.array(self.hest), 2)\n\n        if len(self.hest) &gt; self.TIME_SNAPS_TO_VIS: # maximum packet size to send over the tcp connection\n            tmp = self.pipeline_operations_rfsoc_rx_ndarray(rxtd, 1)\n            self.data_to_visualize = np.roll(self.data_to_visualize, -1, axis=0) \n            self.data_to_visualize[-1, :] = tmp \n\n        if len(self.hest) &gt;= self.TIME_SNAPS_TO_SAVE:\n            print(f\"[DEBUG]: Time between save callbacks: {time.time() - self.start_time_pap_callback}\")\n            self.save_hest_buffer()      \n</code></pre>"},{"location":"RFSoCHandler/#a2gmeasurements.RFSoCRemoteControlFromHost.save_hest_buffer","title":"<code>save_hest_buffer(register_time=True)</code>","text":"<p>Saves the raw (time-snaps, n_beams, n_delay_taps) CIR array.</p> <p>Parameters:</p> Name Type Description Default <code>register_time</code> <code>bool</code> <p>parameter used for debugging purposes. Defaults to True.</p> <code>True</code> Source code in <code>a2gmeasurements.py</code> <pre><code>def save_hest_buffer(self, register_time=True):\n    \"\"\"\n    Saves the raw (time-snaps, n_beams, n_delay_taps) CIR array.\n\n    Args:\n        register_time (bool, optional): parameter used for debugging purposes. Defaults to True.\n    \"\"\"\n\n    datestr = datetime.datetime.now()\n    datestr = datestr.strftime('%Y-%m-%d-%H-%M-%S-%f')\n\n    # Double check that there is something in the array\n    if len(self.hest) &gt; 0:\n        with open('../Measurement Files/' + datestr + '-' + self.filename_to_save + '.npy', 'wb') as f:\n            #np.save(f, np.stack(self.hest, axis=0))\n            np.save(f, np.array(self.hest))\n\n        print(\"[DEBUG]: Saved file \", datestr + self.filename_to_save + '.npy')\n        print(\"[DEBUG]: Saved file \", datestr + self.filename_to_save + '-TIMETAGS' + '.npy')\n        self.hest = []\n\n    if register_time:\n        self.start_time_pap_callback = time.time()\n</code></pre>"},{"location":"RFSoCHandler/#a2gmeasurements.RFSoCRemoteControlFromHost.send_cmd","title":"<code>send_cmd(cmd, cmd_arg=None)</code>","text":"<p>Sends a command to the RFSoC server. </p> <p>These commands control the Sivers EVK mode, carrier frequncy, tx gain and rx gain.</p> <p>Parameters:</p> Name Type Description Default <code>cmd</code> <code>str</code> <p>available commands are: <code>setModeSivers</code>, <code>setCarrierFrequencySivers</code>, <code>setGainTxSivers</code>, <code>setGainRxSivers</code>.</p> required <code>cmd_arg</code> <code>str | float | dict</code> <p>supported parameters for 'setModeSivers' are 'RXen_0_TXen1', 'RXen1_TXen0', 'RXen0_TXen0'; supported parameters for 'setCarrierFrequencySivers' are float number, i.e.: 57.51e9; supported parameters for 'setGainTxSivers' are dict with this structure {'tx_bb_gain': 0x00, 'tx_bb_phase': 0x00, 'tx_bb_iq_gain': 0x00, 'tx_bfrf_gain': 0x00}; supported parameters for 'setGainRxSivers' are dict with this structure {'rx_gain_ctrl_bb1':0x00, 'rx_gain_ctrl_bb2':0x00, 'rx_gain_ctrl_bb3':0x00, 'rx_gain_ctrl_bfrf':0x00}. Defaults to None.</p> <code>None</code> Source code in <code>a2gmeasurements.py</code> <pre><code>def send_cmd(self, cmd, cmd_arg=None):\n    \"\"\"\n    Sends a command to the RFSoC server. \n\n    These commands control the Sivers EVK mode, carrier frequncy, tx gain and rx gain.\n\n    Args:\n        cmd (str): available commands are: ``setModeSivers``, ``setCarrierFrequencySivers``, ``setGainTxSivers``, ``setGainRxSivers``.\n        cmd_arg (str | float | dict, optional): supported parameters for 'setModeSivers' are 'RXen_0_TXen1', 'RXen1_TXen0', 'RXen0_TXen0'; supported parameters for 'setCarrierFrequencySivers' are float number, i.e.: 57.51e9; supported parameters for 'setGainTxSivers' are dict with this structure {'tx_bb_gain': 0x00, 'tx_bb_phase': 0x00, 'tx_bb_iq_gain': 0x00, 'tx_bfrf_gain': 0x00}; supported parameters for 'setGainRxSivers' are dict with this structure {'rx_gain_ctrl_bb1':0x00, 'rx_gain_ctrl_bb2':0x00, 'rx_gain_ctrl_bb3':0x00, 'rx_gain_ctrl_bfrf':0x00}. Defaults to None.\n    \"\"\"\n\n    try:\n        if cmd == 'setModeSivers':\n            if cmd_arg == 'RXen0_TXen1' or cmd_arg == 'RXen1_TXen0' or cmd_arg == 'RXen0_TXen0':\n                self.radio_control.sendall(b\"setModeSiver \"+str.encode(str(cmd_arg)))\n            else:\n                print(\"[DEBUG]: Unknown Sivers mode\")\n        elif cmd == 'setCarrierFrequencySivers':\n            self.radio_control.sendall(b\"setCarrierFrequency \"+str.encode(str(cmd_arg)))\n        elif cmd == 'setGainTxSivers':\n            tx_bb_gain = cmd_arg['tx_bb_gain']\n            tx_bb_phase = cmd_arg['tx_bb_phase']\n            tx_bb_iq_gain = cmd_arg['tx_bb_iq_gain']\n            tx_bfrf_gain = cmd_arg['tx_bfrf_gain']\n\n            self.radio_control.sendall(b\"setGainTX \" + str.encode(str(int(tx_bb_gain)) + \" \") \\\n                                                        + str.encode(str(int(tx_bb_phase)) + \" \") \\\n                                                        + str.encode(str(int(tx_bb_iq_gain)) + \" \") \\\n                                                        + str.encode(str(int(tx_bfrf_gain))))\n        elif cmd == 'setGainRxSivers':\n            rx_gain_ctrl_bb1 = cmd_arg['rx_gain_ctrl_bb1']\n            rx_gain_ctrl_bb2 = cmd_arg['rx_gain_ctrl_bb2']\n            rx_gain_ctrl_bb3 = cmd_arg['rx_gain_ctrl_bb3']\n            rx_gain_ctrl_bfrf = cmd_arg['rx_gain_ctrl_bfrf']\n\n            self.radio_control.sendall(b\"setGainRX \" + str.encode(str(int(rx_gain_ctrl_bb1)) + \" \") \\\n                                                        + str.encode(str(int(rx_gain_ctrl_bb2)) + \" \") \\\n                                                        + str.encode(str(int(rx_gain_ctrl_bb3)) + \" \") \\\n                                                        + str.encode(str(int(rx_gain_ctrl_bfrf))))\n        elif cmd == 'transmitSamples':\n            self.radio_control.sendall(b\"transmitSamples\")\n        else: \n            print(\"[DEBUG]: Unknown command to send to RFSoC\")\n            return\n    except IOError as e:\n        if e.errno == errno.EPIPE:\n            print(\"[ERROR]: RFSoC to Host connection has problems: \", e)\n    else:\n        data = self.radio_control.recv(1024)\n        data = data.decode('utf-8')\n\n        if self.RFSoCSuccessExecutionAns in data or self.RFSoCSuccessAns in data:\n            print(\"[DEBUG]: Command \", cmd, \" executed succesfully on Sivers or RFSoC\")\n        else:\n            print(\"[DEBUG]: Command \", cmd, \" was not successfully executed on Sivers or RFSoC. The following error appears: \", data)\n</code></pre>"},{"location":"RFSoCHandler/#a2gmeasurements.RFSoCRemoteControlFromHost.set_rx_rf","title":"<code>set_rx_rf(rx_gain_ctrl_bb1=119, rx_gain_ctrl_bb2=0, rx_gain_ctrl_bb3=153, rx_gain_ctrl_bfrf=255, carrier_freq=57510000000.0)</code>","text":"<p>Sets rx gains and frequency of operation. Wrapper function of <code>send_cmd</code>.</p> <p>Parameters:</p> Name Type Description Default <code>rx_gain_ctrl_bb1</code> <code>hexadecimal</code> <p>sets the first rx gain for the I,Q according to: I[0:3]:[0,1,3,7,F]:-6:0 dB, 4 steps; Q[0:3]:[0,1,3,7,F]:-6:0 dB, 4 steps. Defaults to 0x77.</p> <code>119</code> <code>rx_gain_ctrl_bb2</code> <code>hexadecimal</code> <p>sets the second rx gain for the I,Q according to: I[0:3]:[0,1,3,7,F]:-6:0 dB, 4 steps; Q[0:3]:[0,1,3,7,F]:-6:0 dB, 4 steps. Defaults to 0x00.</p> <code>0</code> <code>rx_gain_ctrl_bb3</code> <code>hexadecimal</code> <p>sets the third rx gain for the I,Q according to: I[0:3]:[0,1,3,7,F]:-6:0 dB, 4 steps; Q[0:3]:[0,1,3,7,F]:-6:0 dB, 4 steps. Defaults to 0x99.</p> <code>153</code> <code>rx_gain_ctrl_bfrf</code> <code>_type_</code> <p>sets gain after the mixer according to; [0:3,RF gain]: 0-15 dB, 16 steps; [4:7, BF gain]: 0-15 dB, 16 steps. Defaults to 0xFF.</p> <code>255</code> <code>carrier_freq</code> <code>_type_</code> <p>carrier frequency from the available frequency range for the Sivers EVK 06002/3 (in this case: 57-71 GHz). Defaults to 57.51e9.</p> <code>57510000000.0</code> Source code in <code>a2gmeasurements.py</code> <pre><code>def set_rx_rf(self, rx_gain_ctrl_bb1=0x77, rx_gain_ctrl_bb2=0x00, rx_gain_ctrl_bb3=0x99, rx_gain_ctrl_bfrf=0xFF, carrier_freq=57.51e9):\n    \"\"\"\n    Sets rx gains and frequency of operation. Wrapper function of ``send_cmd``.\n\n    Args:\n        rx_gain_ctrl_bb1 (hexadecimal, optional): sets the first rx gain for the I,Q according to: I[0:3]:[0,1,3,7,F]:-6:0 dB, 4 steps; Q[0:3]:[0,1,3,7,F]:-6:0 dB, 4 steps. Defaults to 0x77.\n        rx_gain_ctrl_bb2 (hexadecimal, optional): sets the second rx gain for the I,Q according to: I[0:3]:[0,1,3,7,F]:-6:0 dB, 4 steps; Q[0:3]:[0,1,3,7,F]:-6:0 dB, 4 steps. Defaults to 0x00.\n        rx_gain_ctrl_bb3 (hexadecimal, optional): sets the third rx gain for the I,Q according to: I[0:3]:[0,1,3,7,F]:-6:0 dB, 4 steps; Q[0:3]:[0,1,3,7,F]:-6:0 dB, 4 steps. Defaults to 0x99.\n        rx_gain_ctrl_bfrf (_type_, optional): sets gain after the mixer according to; [0:3,RF gain]: 0-15 dB, 16 steps; [4:7, BF gain]: 0-15 dB, 16 steps. Defaults to 0xFF.\n        carrier_freq (_type_, optional): carrier frequency from the available frequency range for the Sivers EVK 06002/3 (in this case: 57-71 GHz). Defaults to 57.51e9.\n    \"\"\"\n\n    dict_rx_gains = {'rx_gain_ctrl_bb1':rx_gain_ctrl_bb1, 'rx_gain_ctrl_bb2':rx_gain_ctrl_bb2, 'rx_gain_ctrl_bb3':rx_gain_ctrl_bb3, 'rx_gain_ctrl_bfrf':rx_gain_ctrl_bfrf}\n\n    self.send_cmd('setModeSivers', cmd_arg='RXen1_TXen0')\n    self.send_cmd('setCarrierFrequencySivers', cmd_arg=carrier_freq)\n    self.send_cmd('setGainRxSivers', cmd_arg=dict_rx_gains)\n</code></pre>"},{"location":"RFSoCHandler/#a2gmeasurements.RFSoCRemoteControlFromHost.start_thread_receive_meas_data","title":"<code>start_thread_receive_meas_data(msg_data)</code>","text":"<p>Creates and starts the rfsoc thread.</p> <p>A thread -instead of a subprocess- is good enough since the computational expense of the task is not donde in the host computer but in the RFSoC. The host just reads the data through Ethernet.</p> <p>A new thread is started each time this function is called. It is required for the developer to call 'stop_thread_receive_meas_data' before calling again this function in order to close the actual thread before creating a new one.</p> <p>Parameters:</p> Name Type Description Default <code>msg_data</code> <code>dict</code> <p>dictionary containing the parameters required by <code>set_rx_rf</code> to set a Sivers EVK configuration.</p> required Source code in <code>a2gmeasurements.py</code> <pre><code>def start_thread_receive_meas_data(self, msg_data):\n    \"\"\"\n    Creates and starts the rfsoc thread.\n\n    A thread -instead of a subprocess- is good enough since the computational expense of the task is not donde in the host computer but in the RFSoC. The host just reads the data through Ethernet.\n\n    A new thread is started each time this function is called. It is required for the developer to call 'stop_thread_receive_meas_data' before calling again this function in order to close the actual thread before creating a new one.\n\n    Args:\n        msg_data (dict): dictionary containing the parameters required by ``set_rx_rf`` to set a Sivers EVK configuration. \n    \"\"\"\n\n    self.event_stop_thread_rx_irf = threading.Event()                \n    self.thread_rx_irf = threading.Thread(target=self.receive_signal_async, args=(self.event_stop_thread_rx_irf,))\n    self.set_rx_rf(carrier_freq=msg_data['carrier_freq'],\n                   rx_gain_ctrl_bb1=msg_data['rx_gain_ctrl_bb1'],\n                   rx_gain_ctrl_bb2=msg_data['rx_gain_ctrl_bb2'],\n                   rx_gain_ctrl_bb3=msg_data['rx_gain_ctrl_bb3'],\n                   rx_gain_ctrl_bfrf=msg_data['rx_gain_ctrl_bfrf'])\n    time.sleep(0.1)\n    self.time_begin_receive_thread = time.time()\n    self.thread_rx_irf.start()\n    self.start_time_pap_callback = time.time()\n\n    print(\"[DEBUG]: receive_signal_async thread STARTED\")\n</code></pre>"},{"location":"RFSoCHandler/#a2gmeasurements.RFSoCRemoteControlFromHost.stop_thread_receive_meas_data","title":"<code>stop_thread_receive_meas_data()</code>","text":"<p>Stops the rfsoc thread and saves remaining CIRs.</p> Source code in <code>a2gmeasurements.py</code> <pre><code>def stop_thread_receive_meas_data(self):\n    \"\"\"\n    Stops the rfsoc thread and saves remaining CIRs.\n    \"\"\"\n\n    self.event_stop_thread_rx_irf.set()\n    self.time_finish_receive_thread = time.time()\n    print(\"[DEBUG]: receive_signal_async thread STOPPED\")\n    print(\"[DEBUG]: Received calls: \", self.n_receive_calls)\n    print(\"[DEBUG]: Avg. time of execution of 'receive_signal' callback is \", ((self.time_finish_receive_thread - self.time_begin_receive_thread)/self.n_receive_calls))\n\n    self.save_hest_buffer(self, register_time=False)\n\n    self.n_receive_calls = 0\n</code></pre>"},{"location":"RFSoCHandler/#a2gmeasurements.RFSoCRemoteControlFromHost.transmit_signal","title":"<code>transmit_signal(tx_bb_gain=3, tx_bb_phase=0, tx_bb_iq_gain=119, tx_bfrf_gain=64, carrier_freq=57510000000.0)</code>","text":"<p>Sets Tx gains and frequency of operation. Wrapper function of <code>send_cmd</code>.</p> <p>More about TX gains is found in the Sivers EVK manual/reference guides.</p> <p>Parameters:</p> Name Type Description Default <code>tx_bb_gain</code> <code>hexadecimal</code> <p>sets baseband gain according to: 0x00  = 0 dB, 0x01  = 3.5 dB, 0x02  = 3.5 dB, 0x03  = 6 dB (when sivers register tx_ctrl bit 3 (BB Ibias set) = 1). Defaults to 0x3.</p> <code>3</code> <code>tx_bb_phase</code> <code>int</code> <p>description. Defaults to 0.</p> <code>0</code> <code>tx_bb_iq_gain</code> <code>hexadecimal</code> <p>sets baseband I, Q gain according to: [0:3, I gain]: 0-6 dB, 16 steps; [4:7, Q gain]: 0-6 dB, 16 steps. Defaults to 0x77.</p> <code>119</code> <code>tx_bfrf_gain</code> <code>hexadecimal</code> <p>sets gain after RF mixer according to: [0:3, RF gain]: 0-15 dB, 16 steps; [4:7, BF gain]: 0-15 dB, 16 steps. Defaults to 0x40.</p> <code>64</code> <code>carrier_freq</code> <code>_type_</code> <p>carrier frequency from the available frequency range for the Sivers EVK 06002/3 (in this case: 57-71 GHz). Defaults to 57.51e9.</p> <code>57510000000.0</code> Source code in <code>a2gmeasurements.py</code> <pre><code>def transmit_signal(self, tx_bb_gain=0x3, tx_bb_phase=0, tx_bb_iq_gain=0x77, tx_bfrf_gain=0x40, carrier_freq=57.51e9):\n    \"\"\"\n    Sets Tx gains and frequency of operation. Wrapper function of ``send_cmd``.\n\n    More about TX gains is found in the Sivers EVK manual/reference guides.\n\n    Args:\n        tx_bb_gain (hexadecimal, optional): sets baseband gain according to: 0x00  = 0 dB, 0x01  = 3.5 dB, 0x02  = 3.5 dB, 0x03  = 6 dB (when sivers register tx_ctrl bit 3 (BB Ibias set) = 1). Defaults to 0x3.\n        tx_bb_phase (int, optional): _description_. Defaults to 0.\n        tx_bb_iq_gain (hexadecimal, optional): sets baseband I, Q gain according to: [0:3, I gain]: 0-6 dB, 16 steps; [4:7, Q gain]: 0-6 dB, 16 steps. Defaults to 0x77.\n        tx_bfrf_gain (hexadecimal, optional): sets gain after RF mixer according to: [0:3, RF gain]: 0-15 dB, 16 steps; [4:7, BF gain]: 0-15 dB, 16 steps. Defaults to 0x40.\n        carrier_freq (_type_, optional): carrier frequency from the available frequency range for the Sivers EVK 06002/3 (in this case: 57-71 GHz). Defaults to 57.51e9.\n    \"\"\"\n\n    dict_tx_gains = {'tx_bb_gain': tx_bb_gain, 'tx_bb_phase': tx_bb_phase, 'tx_bb_iq_gain': tx_bb_iq_gain, 'tx_bfrf_gain': tx_bfrf_gain}\n\n    self.send_cmd('transmitSamples')\n    self.send_cmd('setModeSivers', cmd_arg='RXen0_TXen1')\n    self.send_cmd('setCarrierFrequencySivers', cmd_arg=carrier_freq)\n    self.send_cmd('setGainTxSivers', cmd_arg=dict_tx_gains)\n</code></pre>"},{"location":"SBUSEncoder/","title":"SBUSEncoder","text":"<p>Python class that encodes the sbus protocol serial signal. The sbus protocol is an UART protocol that specifies the way to send a receive multiple channel information by using a conventional UART channel.</p> <p>Each channel carries information about a control value. It is mainly used by RC receivers to control the angular movement of an object along its different axis.</p> <p>Among the control values in an sbus protocol message are the known throttle, aileron, rudder and elevation.</p> <p>Each manufacturer can have a slightly different implementation of the sbus protocol.</p> <p>The sbus implementation for the Gremsy H16 requires that the idle, stop and parity bits are inverted w.r.t to their voltage value in a conventional UART communication. That is why a hardware inverter (i.e. 74HCN04) is used on the signal.</p> <p>The following is the standard convention for the channels in Gremsy H16 (although it can be changed):</p> <ol> <li> <p>Channel 2 is assumed to be elevation (pitch)</p> </li> <li> <p>Channel 4 is assumed to be pan (yaw)</p> </li> <li> <p>Channel 5 is assumed to be mode (lock, follow, off)</p> </li> </ol> Source code in <code>a2gmeasurements.py</code> <pre><code>class SBUSEncoder:\n    \"\"\"\n    Python class that encodes the sbus protocol serial signal. The sbus protocol is an UART protocol that specifies the way to send a receive multiple channel information by using a conventional UART channel.\n\n    Each channel carries information about a control value. It is mainly used by RC receivers to control the angular movement of an object along its different axis.\n\n    Among the control values in an sbus protocol message are the known throttle, aileron, rudder and elevation.\n\n    Each manufacturer can have a slightly different implementation of the sbus protocol.\n\n    The sbus implementation for the Gremsy H16 requires that the idle, stop and parity bits are inverted w.r.t to their voltage value in a conventional UART communication. That is why a hardware inverter (i.e. 74HCN04) is used on the signal.\n\n    The following is the standard convention for the channels in Gremsy H16 (although it can be changed):\n\n    1. Channel 2 is assumed to be elevation (pitch)\n\n    2. Channel 4 is assumed to be pan (yaw)\n\n    3. Channel 5 is assumed to be mode (lock, follow, off)    \n    \"\"\"\n    def __init__(self):\n        \"\"\"\n        Initializes the channels.\n\n        Establishes a linear mapping between the RC control value interval (-100, 100) and the actual values seen at the osciloscoppe of a given channel (i.e rudder).\n\n        Define some attributes of the class. The atributes related with drifting are defined in the section Gremsy H16 Gimbal of the \"Manual A2GMeasurements\".\n        \"\"\"\n\n        #self.channels = [1024] * 16\n        self.channels = np.ones(16, dtype=np.uint16)*1024\n\n        # This is from the oscilloscope\n        #m, b = np.linalg.solve([[-99, 1], [100, 1]], [1870, 239])\n        m, b = np.linalg.solve([[-99, 1], [0, 1]], [1870, 1055])\n\n        # What intuitively should be is\n        # m, b = np.linalg.solve([[-100, 1], [100, 1]], [0, 2047]) \n\n        # or according to some repositories, for FrSky receivers:\n        #m, b = np.linalg.solve([[-100, 1], [100, 1]], [127, 1811])\n        #m, b = np.linalg.solve([[-100, 1], [100, 1]], [237, 1864])\n        #m, b = np.linalg.solve([[-100, 1], [100, 1]], [0, 2047])\n\n        # Lowest speed experimentally found to counter drifting towards the right azimuth axis. \n        self.LOW_SPEED_COUNTER_rud = 8.74601226993865933\n\n        # Drift towards the LEFT in azimuth, due to the use of LOW_SPEED_COUNTER_rud as the base speed (instead of 0)\n        self.left_drifting_due_to_anti_drifiting = 10/75 # cm/s\n\n        self.m = m\n        self.b = b\n        self.time_last_move_cmd = 0\n        self.cnt = 1\n        self.ENABLE_UPDATE_REST = True\n        self.MODE = 'LOCK'\n\n    def set_channel(self, channel, data):\n        \"\"\"\n        Sets a value on a channel. This a \"setter function\".\n\n        Args:\n            channel (int): channel to be set.\n            data (int): value to be set at the channel.\n        \"\"\"\n\n        self.channels[channel] = data &amp; 0x07ff    \n\n    def encode_data(self):\n        \"\"\"\n        Encodes the values on the channels according to the sbus protocol.\n\n        Returns:\n            packet (list of int): a 24-fields packet/msg that encodes the channel values according to sbus protocol.\n        \"\"\"\n\n        #packet = np.zeros(25, dtype=np.uint8)\n        packet = [0]*25\n        packet[0] = 0x0F\n        packet[1] = self.channels[0] &amp; 0x7F\n        packet[2] = ((self.channels[0] &amp; 0x07FF)&gt;&gt;8 | (self.channels[1] &amp; 0x07FF)&lt;&lt;3) &amp; 0xFF\n        packet[3] = ((self.channels[1] &amp; 0x07FF)&gt;&gt;5 | (self.channels[2] &amp; 0x07FF)&lt;&lt;6) &amp; 0xFF\n        packet[4] = ((self.channels[2] &amp; 0x07FF)&gt;&gt;2) &amp; 0xff\n        packet[5] = ((self.channels[2] &amp; 0x07FF)&gt;&gt;10 | (self.channels[3] &amp; 0x07FF)&lt;&lt;1) &amp; 0xff\n        packet[6] = ((self.channels[3] &amp; 0x07FF)&gt;&gt;7 | (self.channels[4] &amp; 0x07FF)&lt;&lt;4) &amp; 0xff\n        packet[7] = ((self.channels[4] &amp; 0x07FF)&gt;&gt;4 | (self.channels[5] &amp; 0x07FF)&lt;&lt;7) &amp; 0xff\n        packet[8] = ((self.channels[5] &amp; 0x07FF)&gt;&gt;1) &amp; 0xff\n        packet[9] =  ((self.channels[5] &amp; 0x07FF)&gt;&gt;9 | (self.channels[6] &amp; 0x07FF)&lt;&lt;2) &amp; 0xff\n        packet[10] = ((self.channels[6] &amp; 0x07FF)&gt;&gt;6 | (self.channels[7] &amp; 0x07FF)&lt;&lt;5) &amp; 0xff\n        packet[11] = ((self.channels[7] &amp; 0x07FF)&gt;&gt;3) &amp; 0xff\n        packet[12] = (self.channels[8] &amp; 0x07FF) &amp; 0xff\n        packet[13] = ((self.channels[8] &amp; 0x07FF)&gt;&gt;8 | (self.channels[9] &amp; 0x07FF)&lt;&lt;3) &amp; 0xff\n        packet[14] = ((self.channels[9] &amp; 0x07FF)&gt;&gt;5 | (self.channels[10] &amp; 0x07FF)&lt;&lt;6) &amp; 0xff\n        packet[15] = ((self.channels[10] &amp; 0x07FF)&gt;&gt;2) &amp; 0xff\n        packet[16] = ((self.channels[10] &amp; 0x07FF)&gt;&gt;10 | (self.channels[11] &amp; 0x07FF)&lt;&lt;1) &amp; 0xff\n        packet[17] = ((self.channels[11] &amp; 0x07FF)&gt;&gt;7 | (self.channels[12] &amp; 0x07FF)&lt;&lt;4) &amp; 0xff\n        packet[18] = ((self.channels[12] &amp; 0x07FF)&gt;&gt;4 | (self.channels[13] &amp; 0x07FF)&lt;&lt;7) &amp; 0xff\n        packet[19] = ((self.channels[13] &amp; 0x07FF)&gt;&gt;1) &amp; 0xff\n        packet[20] = ((self.channels[13] &amp; 0x07FF)&gt;&gt;9 | (self.channels[14] &amp; 0x07FF)&lt;&lt;2) &amp; 0xff\n        packet[21] = ((self.channels[14] &amp; 0x07FF)&gt;&gt;6 | (self.channels[15] &amp; 0x07FF)&lt;&lt;5) &amp; 0xff\n        packet[22] = ((self.channels[15] &amp; 0x07FF)&gt;&gt;3) &amp; 0xff\n        packet[23] = 0x00\n        packet[24] = 0x00\n\n        # This is done to cope for the hardware inversion done on sbus signal before connecting it to the gimbal.\n        for i in range(1, 23):\n            packet[i] = ~packet[i] &amp; 0xff\n\n        return packet\n\n    def start_sbus(self, serial_interface='/dev/ttyUSB', period_packet=0.009): #period_packet=0.009\n        \"\"\"\n        Creates the serial connection between the host computer and the gimbal.\n\n        Starts the repeating thread (RepeatTimer class instance) to send data each ``period_packet`` seconds. This mimics the behaviour between the RC transmitter and receiver.\n\n        Args:\n            serial_interface (str, optional): serial port. Defaults to ``/dev/ttyUSB``.\n            period_packet (float, optional): time between calls of ``self.send_sbus_msg``. It was found that the communication is decoded when this value is lower than 20 ms. The actual value observed in the oscilloscope of the interval between sbus signal is 10-13ms (More in \"Manual A2GMeasurements\", section Gremsy H16 Gimbal). Defaults to 0.009.\n        \"\"\"\n\n        #self.encoder = SBUSEncoder()\n        self.serial_port = serial.Serial(serial_interface, baudrate=100000,\n                                  parity=serial.PARITY_EVEN,\n                                  stopbits=serial.STOPBITS_TWO)\n\n        print('\\n[DEBUG_0]: serial port connected')\n\n        # Timer thread to leep sending data to the channels. This mimics the RC for the FrsKy X8R\n        self.timer_fcn = RepeatTimer(period_packet, self.send_sbus_msg)  \n        self.timer_fcn.start() \n\n        print('\\n[DEBUG]: SBUS threading started')\n\n    def stop_updating(self):\n        \"\"\"\n        Stops the thread to repeatedly call ``self.send_sbus_msg``. Closes the opened serial port for this communication.\n        \"\"\"\n        self.timer_fcn.cancel()\n        self.serial_port.close()\n\n    def send_sbus_msg(self):\n        \"\"\"\n        Calls the channels encoder to write the message on the serial port.\n\n        Since there is a known drifting in the yaw axis, this method sets a different 0 value (no movement) to counter the drifting behaviour. This is explained in \"Manual A2GMeasurements\" (Gremsy H16 Gimbal section), but a kind of equivalent way to understand this, is that we try to counter drift by changing the effective duty cycle of the yaw channel value.\n        \"\"\"\n        if self.ENABLE_UPDATE_REST:\n            self.update_rest_state_channel()\n        data = self.encode_data()\n        #self.serial_port.write(data.tobytes())\n        self.serial_port.write(bytes(data))\n\n    def update_channel(self, channel, value):\n        \"\"\"\n        Update a channel given by \"channel\" with the value provided in \"value\".\n\n        Args:\n            channel (int): number of the channel: 1-16\n            value (int): a number between  -100 and 100 representing the value of the channel\n        \"\"\"\n\n        self.channels[channel-1] = int(self.m*value + self.b)\n        #self.set_channel(channel, int(scale * 2047))\n\n    def update_rest_state_channel(self):\n        \"\"\"\n        Sets the no movement value (0) of the yaw channel (i.e. channel 4) to the experimentally found value that counters the drift. \n\n        Change ``parameter`` to change the \"effective duty cycle\" of the yaw channel value. More explanation is found in \"Manual A2GMeasurements\" (Gremsy H16 Gimbal section)\n        \"\"\"\n        parameter = 2\n        if self.cnt % parameter == 0:\n            self.update_channel(channel=4, value=0)\n        else:\n            self.update_channel(channel=4, value=self.LOW_SPEED_COUNTER_rud)\n\n        self.cnt = self.cnt + 1\n\n    def not_move_command(self):\n        \"\"\"\n        Updates the channel so that it does not continue moving.\n        \"\"\"\n\n        self.update_channel(channel=1, value=0)\n        self.update_channel(channel=2, value=0)\n        self.update_channel(channel=3, value=0)\n        #self.update_channel(channel=4, value=0)\n        self.update_channel(channel=4, value=self.LOW_SPEED_COUNTER_rud)\n\n        if self.MODE == 'LOCK':\n            self.update_channel(channel=5, value=0)\n        elif self.MODE == 'FOLLOW':\n            self.update_channel(channel=5, value=-100)\n        #time.sleep(0.1)\n\n    def move_gimbal(self, ele, rud, mov_time):\n        \"\"\"\n        Moves the gimbal a certain angle. The angle to be moved is determined by the RC control value for yaw, the RC control value for pitch, and the time those values are hold before realeasing them.\n\n        The RC control values for yaw (``rud``) and pitch (``ele``) are values in the range (-100, 100) that behave as speed values: speed the gimbal will move in that particular axis (i.e. speed it will move in the yaw axis).\n\n        Angle = Angular Speed x time\n\n        Angular Speed = function of the RC control value\n\n        Args:\n            ele (int): RC control value for pitch. Can be thought as the pitch axis velocity. Between -100, 100. \n            rud (int): RC control value for yaw. Can be thought as the yaw axis velocity. Between -100, 100. \n            mov_time (int): time (seconds) to hold the velocity in a particular axis. Must be a positive value.\n        \"\"\"\n\n        self.ENABLE_UPDATE_REST = False\n        self.update_channel(channel=1, value=0)\n        self.update_channel(channel=2, value=ele)\n        self.update_channel(channel=3, value=0)\n        self.update_channel(channel=4, value=rud)\n\n        if self.MODE == 'LOCK':\n            self.update_channel(channel=5, value=0)\n        elif self.MODE == 'FOLLOW':\n            self.update_channel(channel=5, value=-100)\n\n        time.sleep(mov_time)\n        self.not_move_command()\n        self.ENABLE_UPDATE_REST = True\n        self.time_last_move_cmd = datetime.datetime.now().timestamp()\n\n    def turn_off_motors(self):\n        \"\"\"\n        Turns off all gimbal motors.\n        \"\"\"\n        self.update_channel(channel=1, value=0)\n        self.update_channel(channel=2, value=0)\n        self.update_channel(channel=3, value=0)\n        self.update_channel(channel=4, value=0)\n        self.update_channel(channel=5, value=100)\n\n    def turn_on_motors(self):\n        \"\"\"\n        Turns on all gimbal motors.\n        \"\"\"\n\n        # Turn on motors and set the gimbal to lock mode\n        self.update_channel(channel=5, value=0)\n\n        # Turn on motors and set the gimbal to follow mode\n        #self.update_channel(channel=5, value=-100)\n\n    def change_mode(self, mode='LOCK'):\n        \"\"\"\n        Changes the mode of all gimbal motors. According to manufacturers H16 manual the choices are: ``FOLLOW`` and ``LOCK``.\n\n        Args:\n            mode (str, optional): either \"FOLLOW\" or \"LOCK\". A description of each mode is on the manufacturer H16 manual. Defaults to ``LOCK``.\n        \"\"\"\n\n        if mode == 'FOLLOW':\n            self.update_channel(channel=5, value=-100)\n        elif mode == 'LOCK':\n            self.update_channel(channel=5, value=0)\n</code></pre>"},{"location":"SBUSEncoder/#a2gmeasurements.SBUSEncoder.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the channels.</p> <p>Establishes a linear mapping between the RC control value interval (-100, 100) and the actual values seen at the osciloscoppe of a given channel (i.e rudder).</p> <p>Define some attributes of the class. The atributes related with drifting are defined in the section Gremsy H16 Gimbal of the \"Manual A2GMeasurements\".</p> Source code in <code>a2gmeasurements.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes the channels.\n\n    Establishes a linear mapping between the RC control value interval (-100, 100) and the actual values seen at the osciloscoppe of a given channel (i.e rudder).\n\n    Define some attributes of the class. The atributes related with drifting are defined in the section Gremsy H16 Gimbal of the \"Manual A2GMeasurements\".\n    \"\"\"\n\n    #self.channels = [1024] * 16\n    self.channels = np.ones(16, dtype=np.uint16)*1024\n\n    # This is from the oscilloscope\n    #m, b = np.linalg.solve([[-99, 1], [100, 1]], [1870, 239])\n    m, b = np.linalg.solve([[-99, 1], [0, 1]], [1870, 1055])\n\n    # What intuitively should be is\n    # m, b = np.linalg.solve([[-100, 1], [100, 1]], [0, 2047]) \n\n    # or according to some repositories, for FrSky receivers:\n    #m, b = np.linalg.solve([[-100, 1], [100, 1]], [127, 1811])\n    #m, b = np.linalg.solve([[-100, 1], [100, 1]], [237, 1864])\n    #m, b = np.linalg.solve([[-100, 1], [100, 1]], [0, 2047])\n\n    # Lowest speed experimentally found to counter drifting towards the right azimuth axis. \n    self.LOW_SPEED_COUNTER_rud = 8.74601226993865933\n\n    # Drift towards the LEFT in azimuth, due to the use of LOW_SPEED_COUNTER_rud as the base speed (instead of 0)\n    self.left_drifting_due_to_anti_drifiting = 10/75 # cm/s\n\n    self.m = m\n    self.b = b\n    self.time_last_move_cmd = 0\n    self.cnt = 1\n    self.ENABLE_UPDATE_REST = True\n    self.MODE = 'LOCK'\n</code></pre>"},{"location":"SBUSEncoder/#a2gmeasurements.SBUSEncoder.change_mode","title":"<code>change_mode(mode='LOCK')</code>","text":"<p>Changes the mode of all gimbal motors. According to manufacturers H16 manual the choices are: <code>FOLLOW</code> and <code>LOCK</code>.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>str</code> <p>either \"FOLLOW\" or \"LOCK\". A description of each mode is on the manufacturer H16 manual. Defaults to <code>LOCK</code>.</p> <code>'LOCK'</code> Source code in <code>a2gmeasurements.py</code> <pre><code>def change_mode(self, mode='LOCK'):\n    \"\"\"\n    Changes the mode of all gimbal motors. According to manufacturers H16 manual the choices are: ``FOLLOW`` and ``LOCK``.\n\n    Args:\n        mode (str, optional): either \"FOLLOW\" or \"LOCK\". A description of each mode is on the manufacturer H16 manual. Defaults to ``LOCK``.\n    \"\"\"\n\n    if mode == 'FOLLOW':\n        self.update_channel(channel=5, value=-100)\n    elif mode == 'LOCK':\n        self.update_channel(channel=5, value=0)\n</code></pre>"},{"location":"SBUSEncoder/#a2gmeasurements.SBUSEncoder.encode_data","title":"<code>encode_data()</code>","text":"<p>Encodes the values on the channels according to the sbus protocol.</p> <p>Returns:</p> Name Type Description <code>packet</code> <code>list of int</code> <p>a 24-fields packet/msg that encodes the channel values according to sbus protocol.</p> Source code in <code>a2gmeasurements.py</code> <pre><code>def encode_data(self):\n    \"\"\"\n    Encodes the values on the channels according to the sbus protocol.\n\n    Returns:\n        packet (list of int): a 24-fields packet/msg that encodes the channel values according to sbus protocol.\n    \"\"\"\n\n    #packet = np.zeros(25, dtype=np.uint8)\n    packet = [0]*25\n    packet[0] = 0x0F\n    packet[1] = self.channels[0] &amp; 0x7F\n    packet[2] = ((self.channels[0] &amp; 0x07FF)&gt;&gt;8 | (self.channels[1] &amp; 0x07FF)&lt;&lt;3) &amp; 0xFF\n    packet[3] = ((self.channels[1] &amp; 0x07FF)&gt;&gt;5 | (self.channels[2] &amp; 0x07FF)&lt;&lt;6) &amp; 0xFF\n    packet[4] = ((self.channels[2] &amp; 0x07FF)&gt;&gt;2) &amp; 0xff\n    packet[5] = ((self.channels[2] &amp; 0x07FF)&gt;&gt;10 | (self.channels[3] &amp; 0x07FF)&lt;&lt;1) &amp; 0xff\n    packet[6] = ((self.channels[3] &amp; 0x07FF)&gt;&gt;7 | (self.channels[4] &amp; 0x07FF)&lt;&lt;4) &amp; 0xff\n    packet[7] = ((self.channels[4] &amp; 0x07FF)&gt;&gt;4 | (self.channels[5] &amp; 0x07FF)&lt;&lt;7) &amp; 0xff\n    packet[8] = ((self.channels[5] &amp; 0x07FF)&gt;&gt;1) &amp; 0xff\n    packet[9] =  ((self.channels[5] &amp; 0x07FF)&gt;&gt;9 | (self.channels[6] &amp; 0x07FF)&lt;&lt;2) &amp; 0xff\n    packet[10] = ((self.channels[6] &amp; 0x07FF)&gt;&gt;6 | (self.channels[7] &amp; 0x07FF)&lt;&lt;5) &amp; 0xff\n    packet[11] = ((self.channels[7] &amp; 0x07FF)&gt;&gt;3) &amp; 0xff\n    packet[12] = (self.channels[8] &amp; 0x07FF) &amp; 0xff\n    packet[13] = ((self.channels[8] &amp; 0x07FF)&gt;&gt;8 | (self.channels[9] &amp; 0x07FF)&lt;&lt;3) &amp; 0xff\n    packet[14] = ((self.channels[9] &amp; 0x07FF)&gt;&gt;5 | (self.channels[10] &amp; 0x07FF)&lt;&lt;6) &amp; 0xff\n    packet[15] = ((self.channels[10] &amp; 0x07FF)&gt;&gt;2) &amp; 0xff\n    packet[16] = ((self.channels[10] &amp; 0x07FF)&gt;&gt;10 | (self.channels[11] &amp; 0x07FF)&lt;&lt;1) &amp; 0xff\n    packet[17] = ((self.channels[11] &amp; 0x07FF)&gt;&gt;7 | (self.channels[12] &amp; 0x07FF)&lt;&lt;4) &amp; 0xff\n    packet[18] = ((self.channels[12] &amp; 0x07FF)&gt;&gt;4 | (self.channels[13] &amp; 0x07FF)&lt;&lt;7) &amp; 0xff\n    packet[19] = ((self.channels[13] &amp; 0x07FF)&gt;&gt;1) &amp; 0xff\n    packet[20] = ((self.channels[13] &amp; 0x07FF)&gt;&gt;9 | (self.channels[14] &amp; 0x07FF)&lt;&lt;2) &amp; 0xff\n    packet[21] = ((self.channels[14] &amp; 0x07FF)&gt;&gt;6 | (self.channels[15] &amp; 0x07FF)&lt;&lt;5) &amp; 0xff\n    packet[22] = ((self.channels[15] &amp; 0x07FF)&gt;&gt;3) &amp; 0xff\n    packet[23] = 0x00\n    packet[24] = 0x00\n\n    # This is done to cope for the hardware inversion done on sbus signal before connecting it to the gimbal.\n    for i in range(1, 23):\n        packet[i] = ~packet[i] &amp; 0xff\n\n    return packet\n</code></pre>"},{"location":"SBUSEncoder/#a2gmeasurements.SBUSEncoder.move_gimbal","title":"<code>move_gimbal(ele, rud, mov_time)</code>","text":"<p>Moves the gimbal a certain angle. The angle to be moved is determined by the RC control value for yaw, the RC control value for pitch, and the time those values are hold before realeasing them.</p> <p>The RC control values for yaw (<code>rud</code>) and pitch (<code>ele</code>) are values in the range (-100, 100) that behave as speed values: speed the gimbal will move in that particular axis (i.e. speed it will move in the yaw axis).</p> <p>Angle = Angular Speed x time</p> <p>Angular Speed = function of the RC control value</p> <p>Parameters:</p> Name Type Description Default <code>ele</code> <code>int</code> <p>RC control value for pitch. Can be thought as the pitch axis velocity. Between -100, 100. </p> required <code>rud</code> <code>int</code> <p>RC control value for yaw. Can be thought as the yaw axis velocity. Between -100, 100. </p> required <code>mov_time</code> <code>int</code> <p>time (seconds) to hold the velocity in a particular axis. Must be a positive value.</p> required Source code in <code>a2gmeasurements.py</code> <pre><code>def move_gimbal(self, ele, rud, mov_time):\n    \"\"\"\n    Moves the gimbal a certain angle. The angle to be moved is determined by the RC control value for yaw, the RC control value for pitch, and the time those values are hold before realeasing them.\n\n    The RC control values for yaw (``rud``) and pitch (``ele``) are values in the range (-100, 100) that behave as speed values: speed the gimbal will move in that particular axis (i.e. speed it will move in the yaw axis).\n\n    Angle = Angular Speed x time\n\n    Angular Speed = function of the RC control value\n\n    Args:\n        ele (int): RC control value for pitch. Can be thought as the pitch axis velocity. Between -100, 100. \n        rud (int): RC control value for yaw. Can be thought as the yaw axis velocity. Between -100, 100. \n        mov_time (int): time (seconds) to hold the velocity in a particular axis. Must be a positive value.\n    \"\"\"\n\n    self.ENABLE_UPDATE_REST = False\n    self.update_channel(channel=1, value=0)\n    self.update_channel(channel=2, value=ele)\n    self.update_channel(channel=3, value=0)\n    self.update_channel(channel=4, value=rud)\n\n    if self.MODE == 'LOCK':\n        self.update_channel(channel=5, value=0)\n    elif self.MODE == 'FOLLOW':\n        self.update_channel(channel=5, value=-100)\n\n    time.sleep(mov_time)\n    self.not_move_command()\n    self.ENABLE_UPDATE_REST = True\n    self.time_last_move_cmd = datetime.datetime.now().timestamp()\n</code></pre>"},{"location":"SBUSEncoder/#a2gmeasurements.SBUSEncoder.not_move_command","title":"<code>not_move_command()</code>","text":"<p>Updates the channel so that it does not continue moving.</p> Source code in <code>a2gmeasurements.py</code> <pre><code>def not_move_command(self):\n    \"\"\"\n    Updates the channel so that it does not continue moving.\n    \"\"\"\n\n    self.update_channel(channel=1, value=0)\n    self.update_channel(channel=2, value=0)\n    self.update_channel(channel=3, value=0)\n    #self.update_channel(channel=4, value=0)\n    self.update_channel(channel=4, value=self.LOW_SPEED_COUNTER_rud)\n\n    if self.MODE == 'LOCK':\n        self.update_channel(channel=5, value=0)\n    elif self.MODE == 'FOLLOW':\n        self.update_channel(channel=5, value=-100)\n</code></pre>"},{"location":"SBUSEncoder/#a2gmeasurements.SBUSEncoder.send_sbus_msg","title":"<code>send_sbus_msg()</code>","text":"<p>Calls the channels encoder to write the message on the serial port.</p> <p>Since there is a known drifting in the yaw axis, this method sets a different 0 value (no movement) to counter the drifting behaviour. This is explained in \"Manual A2GMeasurements\" (Gremsy H16 Gimbal section), but a kind of equivalent way to understand this, is that we try to counter drift by changing the effective duty cycle of the yaw channel value.</p> Source code in <code>a2gmeasurements.py</code> <pre><code>def send_sbus_msg(self):\n    \"\"\"\n    Calls the channels encoder to write the message on the serial port.\n\n    Since there is a known drifting in the yaw axis, this method sets a different 0 value (no movement) to counter the drifting behaviour. This is explained in \"Manual A2GMeasurements\" (Gremsy H16 Gimbal section), but a kind of equivalent way to understand this, is that we try to counter drift by changing the effective duty cycle of the yaw channel value.\n    \"\"\"\n    if self.ENABLE_UPDATE_REST:\n        self.update_rest_state_channel()\n    data = self.encode_data()\n    #self.serial_port.write(data.tobytes())\n    self.serial_port.write(bytes(data))\n</code></pre>"},{"location":"SBUSEncoder/#a2gmeasurements.SBUSEncoder.set_channel","title":"<code>set_channel(channel, data)</code>","text":"<p>Sets a value on a channel. This a \"setter function\".</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>channel to be set.</p> required <code>data</code> <code>int</code> <p>value to be set at the channel.</p> required Source code in <code>a2gmeasurements.py</code> <pre><code>def set_channel(self, channel, data):\n    \"\"\"\n    Sets a value on a channel. This a \"setter function\".\n\n    Args:\n        channel (int): channel to be set.\n        data (int): value to be set at the channel.\n    \"\"\"\n\n    self.channels[channel] = data &amp; 0x07ff    \n</code></pre>"},{"location":"SBUSEncoder/#a2gmeasurements.SBUSEncoder.start_sbus","title":"<code>start_sbus(serial_interface='/dev/ttyUSB', period_packet=0.009)</code>","text":"<p>Creates the serial connection between the host computer and the gimbal.</p> <p>Starts the repeating thread (RepeatTimer class instance) to send data each <code>period_packet</code> seconds. This mimics the behaviour between the RC transmitter and receiver.</p> <p>Parameters:</p> Name Type Description Default <code>serial_interface</code> <code>str</code> <p>serial port. Defaults to <code>/dev/ttyUSB</code>.</p> <code>'/dev/ttyUSB'</code> <code>period_packet</code> <code>float</code> <p>time between calls of <code>self.send_sbus_msg</code>. It was found that the communication is decoded when this value is lower than 20 ms. The actual value observed in the oscilloscope of the interval between sbus signal is 10-13ms (More in \"Manual A2GMeasurements\", section Gremsy H16 Gimbal). Defaults to 0.009.</p> <code>0.009</code> Source code in <code>a2gmeasurements.py</code> <pre><code>def start_sbus(self, serial_interface='/dev/ttyUSB', period_packet=0.009): #period_packet=0.009\n    \"\"\"\n    Creates the serial connection between the host computer and the gimbal.\n\n    Starts the repeating thread (RepeatTimer class instance) to send data each ``period_packet`` seconds. This mimics the behaviour between the RC transmitter and receiver.\n\n    Args:\n        serial_interface (str, optional): serial port. Defaults to ``/dev/ttyUSB``.\n        period_packet (float, optional): time between calls of ``self.send_sbus_msg``. It was found that the communication is decoded when this value is lower than 20 ms. The actual value observed in the oscilloscope of the interval between sbus signal is 10-13ms (More in \"Manual A2GMeasurements\", section Gremsy H16 Gimbal). Defaults to 0.009.\n    \"\"\"\n\n    #self.encoder = SBUSEncoder()\n    self.serial_port = serial.Serial(serial_interface, baudrate=100000,\n                              parity=serial.PARITY_EVEN,\n                              stopbits=serial.STOPBITS_TWO)\n\n    print('\\n[DEBUG_0]: serial port connected')\n\n    # Timer thread to leep sending data to the channels. This mimics the RC for the FrsKy X8R\n    self.timer_fcn = RepeatTimer(period_packet, self.send_sbus_msg)  \n    self.timer_fcn.start() \n\n    print('\\n[DEBUG]: SBUS threading started')\n</code></pre>"},{"location":"SBUSEncoder/#a2gmeasurements.SBUSEncoder.stop_updating","title":"<code>stop_updating()</code>","text":"<p>Stops the thread to repeatedly call <code>self.send_sbus_msg</code>. Closes the opened serial port for this communication.</p> Source code in <code>a2gmeasurements.py</code> <pre><code>def stop_updating(self):\n    \"\"\"\n    Stops the thread to repeatedly call ``self.send_sbus_msg``. Closes the opened serial port for this communication.\n    \"\"\"\n    self.timer_fcn.cancel()\n    self.serial_port.close()\n</code></pre>"},{"location":"SBUSEncoder/#a2gmeasurements.SBUSEncoder.turn_off_motors","title":"<code>turn_off_motors()</code>","text":"<p>Turns off all gimbal motors.</p> Source code in <code>a2gmeasurements.py</code> <pre><code>def turn_off_motors(self):\n    \"\"\"\n    Turns off all gimbal motors.\n    \"\"\"\n    self.update_channel(channel=1, value=0)\n    self.update_channel(channel=2, value=0)\n    self.update_channel(channel=3, value=0)\n    self.update_channel(channel=4, value=0)\n    self.update_channel(channel=5, value=100)\n</code></pre>"},{"location":"SBUSEncoder/#a2gmeasurements.SBUSEncoder.turn_on_motors","title":"<code>turn_on_motors()</code>","text":"<p>Turns on all gimbal motors.</p> Source code in <code>a2gmeasurements.py</code> <pre><code>def turn_on_motors(self):\n    \"\"\"\n    Turns on all gimbal motors.\n    \"\"\"\n\n    # Turn on motors and set the gimbal to lock mode\n    self.update_channel(channel=5, value=0)\n</code></pre>"},{"location":"SBUSEncoder/#a2gmeasurements.SBUSEncoder.update_channel","title":"<code>update_channel(channel, value)</code>","text":"<p>Update a channel given by \"channel\" with the value provided in \"value\".</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>number of the channel: 1-16</p> required <code>value</code> <code>int</code> <p>a number between  -100 and 100 representing the value of the channel</p> required Source code in <code>a2gmeasurements.py</code> <pre><code>def update_channel(self, channel, value):\n    \"\"\"\n    Update a channel given by \"channel\" with the value provided in \"value\".\n\n    Args:\n        channel (int): number of the channel: 1-16\n        value (int): a number between  -100 and 100 representing the value of the channel\n    \"\"\"\n\n    self.channels[channel-1] = int(self.m*value + self.b)\n</code></pre>"},{"location":"SBUSEncoder/#a2gmeasurements.SBUSEncoder.update_rest_state_channel","title":"<code>update_rest_state_channel()</code>","text":"<p>Sets the no movement value (0) of the yaw channel (i.e. channel 4) to the experimentally found value that counters the drift. </p> <p>Change <code>parameter</code> to change the \"effective duty cycle\" of the yaw channel value. More explanation is found in \"Manual A2GMeasurements\" (Gremsy H16 Gimbal section)</p> Source code in <code>a2gmeasurements.py</code> <pre><code>def update_rest_state_channel(self):\n    \"\"\"\n    Sets the no movement value (0) of the yaw channel (i.e. channel 4) to the experimentally found value that counters the drift. \n\n    Change ``parameter`` to change the \"effective duty cycle\" of the yaw channel value. More explanation is found in \"Manual A2GMeasurements\" (Gremsy H16 Gimbal section)\n    \"\"\"\n    parameter = 2\n    if self.cnt % parameter == 0:\n        self.update_channel(channel=4, value=0)\n    else:\n        self.update_channel(channel=4, value=self.LOW_SPEED_COUNTER_rud)\n\n    self.cnt = self.cnt + 1\n</code></pre>"},{"location":"Troubleshooting/","title":"Troubleshooting","text":"<p>Error: Can ssh but can not ping</p> <p>Possible cause: ICMP problem on Manifold (Windows Firewall).</p> <p>Solution to try: </p> <p>Go to <code>Start</code> &gt; <code>Run</code> &gt; <code>firewall.cpl</code> &gt; <code>Advanced Settings</code>. </p> <p>You get Windows Defender Firewall with Advanced Security. Now create Inbound and Outbound rules to allow ICMP requests. Check Inbound Rules and Outbound Rules. In the right pane, find the file and printer sharing rules (Echo Request - ICMPv4-In). Right-click each rule and select Enable Rule. </p> <p>Error: Network is unreachable or General failure when pinging to 10.1.1.30 or 10.1.1.40 (RFSoC) </p> <p>Possible cause: Bad ethernet cable connected.</p> <p>Solution to try: </p> <p>Power off RFSoC disconnect and disconnect Ethernet cable both sides. Connect again and make sure is well connected.</p> <p>Error: .</p> <p>Possible cause: server not started in the RFSoC.</p> <p>Solution to try: </p> <ol> <li>Connect to the RFSoC (\\ref{ssec:conn_rfsoc}).</li> <li>On the RFSoC terminal type:</li> </ol> <p>Check if RFSoC server is running</p> <pre><code>ps aux | grep mmwsdr\n</code></pre> <ol> <li> <p>Within the listed process there should be two running. Namely: <code>run.sh</code> and <code>server.py</code></p> </li> <li> <p>If that is not the case, then, type in the terminal the following commands:</p> </li> </ol> <p>Start RFSoC server</p> <pre><code>cd jupyter\\notebooks/mmwsdr\n\\textttsudo ./run.sh\n// If password is asked, type\nxilinx\n</code></pre>"},{"location":"Utils/","title":"Utility functions","text":""},{"location":"Utils/#a2gUtils.AngleAnnotation","title":"<code>AngleAnnotation</code>","text":"<p>             Bases: <code>Arc</code></p> <p>Draws an arc between two vectors which appears circular in display space. Implementation of class Arc</p> Source code in <code>a2gUtils.py</code> <pre><code>class AngleAnnotation(Arc):\n    \"\"\"\n    Draws an arc between two vectors which appears circular in display space. Implementation\n    of class Arc\n    \"\"\"\n    def __init__(self, xy, p1, p2, size=75, unit=\"points\", ax=None,\n                 text=\"\", textposition=\"inside\", text_kw=None, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        xy, p1, p2 : tuple or array of two floats\n            Center position and two points. Angle annotation is drawn between\n            the two vectors connecting *p1* and *p2* with *xy*, respectively.\n            Units are data coordinates.\n\n        size : float\n            Diameter of the angle annotation in units specified by *unit*.\n\n        unit : str\n            One of the following strings to specify the unit of *size*:\n\n            * \"pixels\": pixels\n            * \"points\": points, use points instead of pixels to not have a\n              dependence on the DPI\n            * \"axes width\", \"axes height\": relative units of Axes width, height\n            * \"axes min\", \"axes max\": minimum or maximum of relative Axes\n              width, height\n\n        ax : `matplotlib.axes.Axes`\n            The Axes to add the angle annotation to.\n\n        text : str\n            The text to mark the angle with.\n\n        textposition : {\"inside\", \"outside\", \"edge\"}\n            Whether to show the text in- or outside the arc. \"edge\" can be used\n            for custom positions anchored at the arc's edge.\n\n        text_kw : dict\n            Dictionary of arguments passed to the Annotation.\n\n        **kwargs\n            Further parameters are passed to `matplotlib.patches.Arc`. Use this\n            to specify, color, linewidth etc. of the arc.\n\n        \"\"\"\n        self.ax = ax or plt.gca()\n        self._xydata = xy  # in data coordinates\n        self.vec1 = p1\n        self.vec2 = p2\n        self.size = size\n        self.unit = unit\n        self.textposition = textposition\n\n        super().__init__(self._xydata, size, size, angle=0.0,\n                         theta1=self.theta1, theta2=self.theta2, **kwargs)\n\n        self.set_transform(IdentityTransform())\n\n        if self.ax.patches:\n            #for i in self.ax.patches:\n            #    i.remove()\n            if len(self.ax.patches) &gt; 1:\n                self.ax.patches[0].remove()\n\n        if self.ax.texts:\n            #for i in range(len(self.ax.texts)-1):\n            #    if isinstance(i, matplotlib.text.Annotation):\n            #        i.remove()            \n            if len(self.ax.texts) &gt; 4:\n                for i in self.ax.texts[3:-1]:\n                    i.remove()\n\n        self.ax.add_patch(self)\n\n        self.kw = dict(ha=\"center\", va=\"center\",\n                       xycoords=IdentityTransform(),\n                       xytext=(0, 0), textcoords=\"offset points\",\n                       annotation_clip=True)\n        self.kw.update(text_kw or {})\n        self.text = ax.annotate(text, xy=self._center, **self.kw)\n\n    def get_size(self):\n        factor = 1.\n        if self.unit == \"points\":\n            factor = self.ax.figure.dpi / 72.\n        elif self.unit[:4] == \"axes\":\n            b = TransformedBbox(Bbox.unit(), self.ax.transAxes)\n            dic = {\"max\": max(b.width, b.height),\n                   \"min\": min(b.width, b.height),\n                   \"width\": b.width, \"height\": b.height}\n            factor = dic[self.unit[5:]]\n        return self.size * factor\n\n    def set_size(self, size):\n        self.size = size\n\n    def get_center_in_pixels(self):\n        \"\"\"return center in pixels\"\"\"\n        return self.ax.transData.transform(self._xydata)\n\n    def set_center(self, xy):\n        \"\"\"set center in data coordinates\"\"\"\n        self._xydata = xy\n\n    def get_theta(self, vec):\n        vec_in_pixels = self.ax.transData.transform(vec) - self._center\n        return np.rad2deg(np.arctan2(vec_in_pixels[1], vec_in_pixels[0]))\n\n    def get_theta1(self):\n        return self.get_theta(self.vec1)\n\n    def get_theta2(self):\n        return self.get_theta(self.vec2)\n\n    def set_theta(self, angle):\n        pass\n\n    # Redefine attributes of the Arc to always give values in pixel space\n    _center = property(get_center_in_pixels, set_center)\n    theta1 = property(get_theta1, set_theta)\n    theta2 = property(get_theta2, set_theta)\n    width = property(get_size, set_size)\n    height = property(get_size, set_size)\n\n    # The following two methods are needed to update the text position.\n    def draw(self, renderer):\n        self.update_text()\n        super().draw(renderer)\n\n    def update_text(self):\n        c = self._center\n        s = self.get_size()\n        angle_span = (self.theta2 - self.theta1) % 360\n        angle = np.deg2rad(self.theta1 + angle_span / 2)\n        r = s / 2\n        if self.textposition == \"inside\":\n            r = s / np.interp(angle_span, [60, 90, 135, 180],\n                                          [3.3, 3.5, 3.8, 4])\n        self.text.xy = c + r * np.array([np.cos(angle), np.sin(angle)])\n        if self.textposition == \"outside\":\n            def R90(a, r, w, h):\n                if a &lt; np.arctan(h/2/(r+w/2)):\n                    return np.sqrt((r+w/2)**2 + (np.tan(a)*(r+w/2))**2)\n                else:\n                    c = np.sqrt((w/2)**2+(h/2)**2)\n                    T = np.arcsin(c * np.cos(np.pi/2 - a + np.arcsin(h/2/c))/r)\n                    xy = r * np.array([np.cos(a + T), np.sin(a + T)])\n                    xy += np.array([w/2, h/2])\n                    return np.sqrt(np.sum(xy**2))\n\n            def R(a, r, w, h):\n                aa = (a % (np.pi/4))*((a % (np.pi/2)) &lt;= np.pi/4) + \\\n                     (np.pi/4 - (a % (np.pi/4)))*((a % (np.pi/2)) &gt;= np.pi/4)\n                return R90(aa, r, *[w, h][::int(np.sign(np.cos(2*a)))])\n\n            bbox = self.text.get_window_extent()\n            X = R(angle, r, bbox.width, bbox.height)\n            trans = self.ax.figure.dpi_scale_trans.inverted()\n            offs = trans.transform(((X-s/2), 0))[0] * 72\n            self.text.set_position([offs*np.cos(angle), offs*np.sin(angle)])\n</code></pre>"},{"location":"Utils/#a2gUtils.AngleAnnotation.__init__","title":"<code>__init__(xy, p1, p2, size=75, unit='points', ax=None, text='', textposition='inside', text_kw=None, **kwargs)</code>","text":""},{"location":"Utils/#a2gUtils.AngleAnnotation.__init__--parameters","title":"Parameters","text":"<p>xy, p1, p2 : tuple or array of two floats     Center position and two points. Angle annotation is drawn between     the two vectors connecting p1 and p2 with xy, respectively.     Units are data coordinates.</p> float <p>Diameter of the angle annotation in units specified by unit.</p> str <p>One of the following strings to specify the unit of size:</p> <ul> <li>\"pixels\": pixels</li> <li>\"points\": points, use points instead of pixels to not have a   dependence on the DPI</li> <li>\"axes width\", \"axes height\": relative units of Axes width, height</li> <li>\"axes min\", \"axes max\": minimum or maximum of relative Axes   width, height</li> </ul> <code>matplotlib.axes.Axes</code> <p>The Axes to add the angle annotation to.</p> str <p>The text to mark the angle with.</p> {\"inside\", \"outside\", \"edge\"} <p>Whether to show the text in- or outside the arc. \"edge\" can be used for custom positions anchored at the arc's edge.</p> dict <p>Dictionary of arguments passed to the Annotation.</p> <p>**kwargs     Further parameters are passed to <code>matplotlib.patches.Arc</code>. Use this     to specify, color, linewidth etc. of the arc.</p> Source code in <code>a2gUtils.py</code> <pre><code>def __init__(self, xy, p1, p2, size=75, unit=\"points\", ax=None,\n             text=\"\", textposition=\"inside\", text_kw=None, **kwargs):\n    \"\"\"\n    Parameters\n    ----------\n    xy, p1, p2 : tuple or array of two floats\n        Center position and two points. Angle annotation is drawn between\n        the two vectors connecting *p1* and *p2* with *xy*, respectively.\n        Units are data coordinates.\n\n    size : float\n        Diameter of the angle annotation in units specified by *unit*.\n\n    unit : str\n        One of the following strings to specify the unit of *size*:\n\n        * \"pixels\": pixels\n        * \"points\": points, use points instead of pixels to not have a\n          dependence on the DPI\n        * \"axes width\", \"axes height\": relative units of Axes width, height\n        * \"axes min\", \"axes max\": minimum or maximum of relative Axes\n          width, height\n\n    ax : `matplotlib.axes.Axes`\n        The Axes to add the angle annotation to.\n\n    text : str\n        The text to mark the angle with.\n\n    textposition : {\"inside\", \"outside\", \"edge\"}\n        Whether to show the text in- or outside the arc. \"edge\" can be used\n        for custom positions anchored at the arc's edge.\n\n    text_kw : dict\n        Dictionary of arguments passed to the Annotation.\n\n    **kwargs\n        Further parameters are passed to `matplotlib.patches.Arc`. Use this\n        to specify, color, linewidth etc. of the arc.\n\n    \"\"\"\n    self.ax = ax or plt.gca()\n    self._xydata = xy  # in data coordinates\n    self.vec1 = p1\n    self.vec2 = p2\n    self.size = size\n    self.unit = unit\n    self.textposition = textposition\n\n    super().__init__(self._xydata, size, size, angle=0.0,\n                     theta1=self.theta1, theta2=self.theta2, **kwargs)\n\n    self.set_transform(IdentityTransform())\n\n    if self.ax.patches:\n        #for i in self.ax.patches:\n        #    i.remove()\n        if len(self.ax.patches) &gt; 1:\n            self.ax.patches[0].remove()\n\n    if self.ax.texts:\n        #for i in range(len(self.ax.texts)-1):\n        #    if isinstance(i, matplotlib.text.Annotation):\n        #        i.remove()            \n        if len(self.ax.texts) &gt; 4:\n            for i in self.ax.texts[3:-1]:\n                i.remove()\n\n    self.ax.add_patch(self)\n\n    self.kw = dict(ha=\"center\", va=\"center\",\n                   xycoords=IdentityTransform(),\n                   xytext=(0, 0), textcoords=\"offset points\",\n                   annotation_clip=True)\n    self.kw.update(text_kw or {})\n    self.text = ax.annotate(text, xy=self._center, **self.kw)\n</code></pre>"},{"location":"Utils/#a2gUtils.AngleAnnotation.get_center_in_pixels","title":"<code>get_center_in_pixels()</code>","text":"<p>return center in pixels</p> Source code in <code>a2gUtils.py</code> <pre><code>def get_center_in_pixels(self):\n    \"\"\"return center in pixels\"\"\"\n    return self.ax.transData.transform(self._xydata)\n</code></pre>"},{"location":"Utils/#a2gUtils.AngleAnnotation.set_center","title":"<code>set_center(xy)</code>","text":"<p>set center in data coordinates</p> Source code in <code>a2gUtils.py</code> <pre><code>def set_center(self, xy):\n    \"\"\"set center in data coordinates\"\"\"\n    self._xydata = xy\n</code></pre>"},{"location":"Utils/#a2gUtils.GpsOnMap","title":"<code>GpsOnMap</code>","text":"<p>             Bases: <code>object</code></p> Source code in <code>a2gUtils.py</code> <pre><code>class GpsOnMap(object):\n\n    def __init__(self, path_to_osmpbf, canvas=None,fig=None, ax=None, air_coord=None, gnd_coord=None):\n        \"\"\"\n        This is a handler for the canvas element where gps coords are plot\n\n        It requires an .osm.pbf picture of the map get from https://extract.bbbike.org/\n\n        Args:\n            path_to_osmpbf (str): path to .osm.pbf file\n            canvas (widget, optional): canvas widget from app. Defaults to None.\n            fig (fig, optional): _description_. Defaults to None.\n            ax (ax, optional): _description_. Defaults to None.\n            air_coord (dictionary, optional): the keys of the dictionary should be \"LAT\" and \"LON\". Defaults to None.\n            gnd_coord (dictionary, optional): the keys of the dictionary should be \"LAT\" and \"LON\". Defaults to None.\n        \"\"\"\n\n        #plt.rcParams['animation.html'] = 'jshtml'\n        if ax is None and fig is None:\n            fig, ax = plt.subplots()\n        elif ax is not None and fig is None:\n            print('\\n[DEBUG]: figure handle not provided')\n        elif fig is not None and ax is None:\n            print('\\n[DEBUG]: axes handle not provided')\n\n        self.ax = ax\n        self.fig = fig\n        self.canvas = canvas\n\n        # Initialize the OSM parser object\n        osm = OSM(path_to_osmpbf)\n\n        # Plot cycling, driving and walking layers, and also buildings\n        cycling_net = osm.get_network(network_type=\"cycling\")\n        drive_net = osm.get_network(network_type=\"driving\")\n        walking_net = osm.get_network(network_type=\"walking\")\n        buildings = osm.get_buildings()\n\n        cycling_net.plot(ax=self.ax)\n        buildings.plot(ax=self.ax)\n        walking_net.plot(ax=self.ax)\n\n        self.air_coord = air_coord\n\n        if air_coord is not None:\n            self.air_pos, =self.ax.plot(air_coord['LON'], air_coord['LAT'], 'b+', markersize=15)\n\n        self.test_cnt = 1\n        self.fut_hub = {'LAT': 60.18650, 'LON': 24.81350}\n        self.air_pos.set_data(self.air_coord['LON'], self.air_coord['LAT'])\n\n        if canvas is None:\n            plt.show()\n        else:\n            self.canvas.draw()\n\n    def show_air_moving(self, lat, lon):\n        \"\"\"\n        Updates the plot with the new positions\n        \"\"\"\n\n        self.air_pos.set_data(lon, lat)\n\n        if self.canvas is None:\n            plt.show()\n        else:\n            self.canvas.draw()\n</code></pre>"},{"location":"Utils/#a2gUtils.GpsOnMap.__init__","title":"<code>__init__(path_to_osmpbf, canvas=None, fig=None, ax=None, air_coord=None, gnd_coord=None)</code>","text":"<p>This is a handler for the canvas element where gps coords are plot</p> <p>It requires an .osm.pbf picture of the map get from https://extract.bbbike.org/</p> <p>Parameters:</p> Name Type Description Default <code>path_to_osmpbf</code> <code>str</code> <p>path to .osm.pbf file</p> required <code>canvas</code> <code>widget</code> <p>canvas widget from app. Defaults to None.</p> <code>None</code> <code>fig</code> <code>fig</code> <p>description. Defaults to None.</p> <code>None</code> <code>ax</code> <code>ax</code> <p>description. Defaults to None.</p> <code>None</code> <code>air_coord</code> <code>dictionary</code> <p>the keys of the dictionary should be \"LAT\" and \"LON\". Defaults to None.</p> <code>None</code> <code>gnd_coord</code> <code>dictionary</code> <p>the keys of the dictionary should be \"LAT\" and \"LON\". Defaults to None.</p> <code>None</code> Source code in <code>a2gUtils.py</code> <pre><code>def __init__(self, path_to_osmpbf, canvas=None,fig=None, ax=None, air_coord=None, gnd_coord=None):\n    \"\"\"\n    This is a handler for the canvas element where gps coords are plot\n\n    It requires an .osm.pbf picture of the map get from https://extract.bbbike.org/\n\n    Args:\n        path_to_osmpbf (str): path to .osm.pbf file\n        canvas (widget, optional): canvas widget from app. Defaults to None.\n        fig (fig, optional): _description_. Defaults to None.\n        ax (ax, optional): _description_. Defaults to None.\n        air_coord (dictionary, optional): the keys of the dictionary should be \"LAT\" and \"LON\". Defaults to None.\n        gnd_coord (dictionary, optional): the keys of the dictionary should be \"LAT\" and \"LON\". Defaults to None.\n    \"\"\"\n\n    #plt.rcParams['animation.html'] = 'jshtml'\n    if ax is None and fig is None:\n        fig, ax = plt.subplots()\n    elif ax is not None and fig is None:\n        print('\\n[DEBUG]: figure handle not provided')\n    elif fig is not None and ax is None:\n        print('\\n[DEBUG]: axes handle not provided')\n\n    self.ax = ax\n    self.fig = fig\n    self.canvas = canvas\n\n    # Initialize the OSM parser object\n    osm = OSM(path_to_osmpbf)\n\n    # Plot cycling, driving and walking layers, and also buildings\n    cycling_net = osm.get_network(network_type=\"cycling\")\n    drive_net = osm.get_network(network_type=\"driving\")\n    walking_net = osm.get_network(network_type=\"walking\")\n    buildings = osm.get_buildings()\n\n    cycling_net.plot(ax=self.ax)\n    buildings.plot(ax=self.ax)\n    walking_net.plot(ax=self.ax)\n\n    self.air_coord = air_coord\n\n    if air_coord is not None:\n        self.air_pos, =self.ax.plot(air_coord['LON'], air_coord['LAT'], 'b+', markersize=15)\n\n    self.test_cnt = 1\n    self.fut_hub = {'LAT': 60.18650, 'LON': 24.81350}\n    self.air_pos.set_data(self.air_coord['LON'], self.air_coord['LAT'])\n\n    if canvas is None:\n        plt.show()\n    else:\n        self.canvas.draw()\n</code></pre>"},{"location":"Utils/#a2gUtils.GpsOnMap.show_air_moving","title":"<code>show_air_moving(lat, lon)</code>","text":"<p>Updates the plot with the new positions</p> Source code in <code>a2gUtils.py</code> <pre><code>def show_air_moving(self, lat, lon):\n    \"\"\"\n    Updates the plot with the new positions\n    \"\"\"\n\n    self.air_pos.set_data(lon, lat)\n\n    if self.canvas is None:\n        plt.show()\n    else:\n        self.canvas.draw()\n</code></pre>"},{"location":"Utils/#a2gUtils.azimuth_difference_between_coordinates","title":"<code>azimuth_difference_between_coordinates(heading, lat_origin, lon_origin, lat_dest, lon_dest)</code>","text":"<p>This is the angle difference between the heading direction (angle w.r.t the North) of the node behaving as the origin and the destination node direction (w.r.t the origin node).</p> <p>The following picture provides an illustration of the angle to be computed (named here theta).</p> Illustration of the angle difference theta <p>Parameters:</p> Name Type Description Default <code>heading</code> <code>float</code> <p>angle between [0, 2*pi] (rads) corresponding to the heading direction of the line between the two antennas connected to Septentrio's receiver in the origin node. Defaults to None.</p> required <code>lat_origin</code> <code>float</code> <p>latitude of the origin node. </p> required <code>lon_origin</code> <code>float</code> <p>longitude of the origin node.</p> required <code>lat_dest</code> <code>float</code> <p>latitude of the destination node.</p> required <code>lon_dest</code> <code>float</code> <p>longitude of the destination node. </p> required <p>Returns:     yaw_to_set (int): azimuth angle difference.</p> Source code in <code>a2gUtils.py</code> <pre><code>def azimuth_difference_between_coordinates(heading, lat_origin, lon_origin, lat_dest, lon_dest):\n    \"\"\"\n    This is the angle difference between the **heading** direction (angle w.r.t the North) of the node behaving as the origin and the destination node direction (w.r.t the origin node).\n\n    The following picture provides an illustration of the angle to be computed (named here theta).\n\n    &lt;figure markdown=\"span\"&gt;\n    ![Image title](assets/azimuth_difference_btw_coods.PNG){ width=\"400\" }\n    &lt;figcaption&gt;Illustration of the angle difference theta&lt;/figcaption&gt;\n    &lt;/figure&gt;\n\n    Args:\n        heading (float): angle between [0, 2*pi] (rads) corresponding to the heading direction of the line between the two antennas connected to Septentrio's receiver in the origin node. Defaults to None.\n        lat_origin (float): latitude of the origin node. \n        lon_origin (float): longitude of the origin node.\n        lat_dest (float): latitude of the destination node.\n        lon_dest (float): longitude of the destination node. \n    Returns:\n        yaw_to_set (int): azimuth angle difference.\n    \"\"\"\n\n    wgs84_geod = Geod(ellps='WGS84')\n\n    ITFA, _, _ = wgs84_geod.inv(lon_origin, lat_origin, lon_dest, lat_dest)\n\n    # Restrict heading to [-pi, pi] interval. No need for &lt; -2*pi check, cause it won't happen\n    if heading &gt; 180:\n        heading = heading - 360\n\n    yaw_to_set = ITFA - heading\n\n    if yaw_to_set &gt; 180:\n        yaw_to_set = yaw_to_set - 360\n    elif yaw_to_set &lt; -180:\n        yaw_to_set = yaw_to_set + 360\n\n    yaw_to_set = int(yaw_to_set*10)\n\n    return yaw_to_set\n</code></pre>"},{"location":"Utils/#a2gUtils.compute_block_mean_2d_array","title":"<code>compute_block_mean_2d_array(array, block_length)</code>","text":"<p>Compute the block mean of a matrix by assuming the matrix consists of blocks of size block_length-by-array.shape[1].</p> <p>'array' should be a matrix, and 'block_length' should be less than array.shape[1].</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>description</p> required <code>block_length</code> <code>int</code> <p>description</p> required Source code in <code>a2gUtils.py</code> <pre><code>def compute_block_mean_2d_array(array, block_length):\n    \"\"\"\n    Compute the block mean of a matrix by assuming the matrix consists of blocks of size\n    block_length-by-array.shape[1].\n\n    'array' should be a matrix, and 'block_length' should be less than array.shape[1].\n\n    Args:\n        array (ndarray): _description_\n        block_length (int): _description_\n    \"\"\"\n\n    tmp = array.reshape((-1, block_length, array.shape[1]//array.shape[1], array.shape[1]))\n    tmp = tmp.transpose((0,2,1,3))\n    tmp = np.mean(tmp, axis=(2,))\n    tmp = np.squeeze(tmp)\n    return tmp      \n</code></pre>"},{"location":"Utils/#a2gUtils.elevation_difference_between_coordinates","title":"<code>elevation_difference_between_coordinates(lat_origin, lon_origin, h_origin, lat_dest, lon_dest, h_dest)</code>","text":"<p>Elevation angle difference between the origin node and the destination node.</p> <p>The following picture provides an illustration of the angle to be computed (named here theta).</p> Illustration of the angle difference phi <p>Parameters:</p> Name Type Description Default <code>lat_origin</code> <code>float</code> <p>latitude of the origin node. </p> required <code>lon_origin</code> <code>float</code> <p>longitude of the origin node.</p> required <code>h_origin</code> <code>float</code> <p>height of the origin node.</p> required <code>lat_dest</code> <code>float</code> <p>latitude of the destination node.</p> required <code>lon_dest</code> <code>float</code> <p>longitude of the destination node. </p> required <code>h_dest</code> <code>float</code> <p>height of the destination node.</p> required <p>Returns:     pitch_to_set (int): elevation angle difference.</p> Source code in <code>a2gUtils.py</code> <pre><code>def elevation_difference_between_coordinates(lat_origin, lon_origin, h_origin, lat_dest, lon_dest, h_dest):\n    \"\"\"\n    Elevation angle difference between the origin node and the destination node.\n\n    The following picture provides an illustration of the angle to be computed (named here theta).\n\n    &lt;figure markdown=\"span\"&gt;\n    ![Image title](assets/elevation_difference_btw_coods.PNG){ width=\"400\" }\n    &lt;figcaption&gt;Illustration of the angle difference phi&lt;/figcaption&gt;\n    &lt;/figure&gt;\n\n    Args:\n        lat_origin (float): latitude of the origin node. \n        lon_origin (float): longitude of the origin node.\n        h_origin (float): height of the origin node.\n        lat_dest (float): latitude of the destination node.\n        lon_dest (float): longitude of the destination node. \n        h_dest (float): height of the destination node.\n    Returns:\n        pitch_to_set (int): elevation angle difference.\n    \"\"\"\n\n    wgs84_geod = Geod(ellps='WGS84')\n\n    # dist_proj_2D is the distance between the origin node and the projection of the destination node to the plane at the height of the origin node.\n    _, _, dist_proj_2D = wgs84_geod.inv(lon_origin, lat_origin, lon_dest, lat_dest)\n\n    pitch_to_set = np.arctan2(h_dest - h_origin, dist_proj_2D) \n    pitch_to_set = int(np.rad2deg(pitch_to_set)*10)\n\n    return pitch_to_set\n</code></pre>"},{"location":"Utils/#a2gUtils.geocentric2geodetic","title":"<code>geocentric2geodetic(X, Y, Z, EPSG_GEODETIC=4979, EPSG_GEOCENTRIC=4978)</code>","text":"<p>Given Geocentric coordinates referred to a datum (given by EPSG_GEOCENTRIC), convert them to Geodetic (lat, lon, height) in the datum given by EPSG_GEODETIC.    </p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>float</code> <p>geocentric X coordinate. </p> required <code>Y</code> <code>float</code> <p>geocentric Y coordinate.</p> required <code>Z</code> <code>float</code> <p>geocentric Z coordinate.</p> required <code>EPSG_GEODETIC</code> <code>int</code> <p>description. Defaults to 4979, that corresponds to WSG84 (geodetic)</p> <code>4979</code> <code>EPSG_GEOCENTRIC</code> <code>int</code> <p>description. Defaults to 4978, that corresponds to WSG84 (geocentric).</p> <code>4978</code> Source code in <code>a2gUtils.py</code> <pre><code>def geocentric2geodetic(X, Y, Z, EPSG_GEODETIC=4979, EPSG_GEOCENTRIC=4978):\n    \"\"\"\n    Given Geocentric coordinates referred to a datum (given by EPSG_GEOCENTRIC), convert them\n    to Geodetic (lat, lon, height) in the datum given by EPSG_GEODETIC.    \n\n    Args:\n        X (float): geocentric X coordinate. \n        Y (float): geocentric Y coordinate.\n        Z (float): geocentric Z coordinate.\n        EPSG_GEODETIC (int, optional): _description_. Defaults to 4979, that corresponds to WSG84 (geodetic)\n        EPSG_GEOCENTRIC (int, optional): _description_. Defaults to 4978, that corresponds to WSG84 (geocentric).\n    \"\"\"\n\n    geodet_crs = CRS.from_epsg(4979) # Geodetic (lat,lon,h) system\n    geocent_crs = CRS.from_epsg(4978) # Geocentric (X,Y,Z) system\n\n    geocent_to_geodet = Transformer.from_crs(geocent_crs, geodet_crs)\n\n    lat, lon, height = geocent_to_geodet.transform(X, Y, Z)\n\n    return lat, lon, height\n</code></pre>"},{"location":"Utils/#a2gUtils.geodetic2geocentric","title":"<code>geodetic2geocentric(lat, lon, height, EPSG_GEODETIC=4979, EPSG_GEOCENTRIC=4978)</code>","text":"<p>Given Geodetic coordinates (lat, lon, h), convert them  to Geocentric  in the datum given by EPSG_GEOCENTRIC.    </p> <p>Parameters:</p> Name Type Description Default <code>lat</code> <code>float</code> <p>latitude (N)</p> required <code>lon</code> <code>float</code> <p>longitude (E).</p> required <code>height</code> <code>float</code> <p>height in meters.</p> required <code>EPSG_GEODETIC</code> <code>int</code> <p>description. Defaults to 4979, that corresponds to WSG84 (geodetic)</p> <code>4979</code> <code>EPSG_GEOCENTRIC</code> <code>int</code> <p>description. Defaults to 4978, that corresponds to WSG84 (geocentric).</p> <code>4978</code> Source code in <code>a2gUtils.py</code> <pre><code>def geodetic2geocentric(lat, lon, height, EPSG_GEODETIC=4979, EPSG_GEOCENTRIC=4978):\n    \"\"\"\n    Given Geodetic coordinates (lat, lon, h), convert them \n    to Geocentric  in the datum given by EPSG_GEOCENTRIC.    \n\n    Args:\n        lat (float): latitude (N)\n        lon (float): longitude (E).\n        height (float): height in meters.\n        EPSG_GEODETIC (int, optional): _description_. Defaults to 4979, that corresponds to WSG84 (geodetic)\n        EPSG_GEOCENTRIC (int, optional): _description_. Defaults to 4978, that corresponds to WSG84 (geocentric).\n    \"\"\"\n\n    geodet_crs = CRS.from_epsg(4979) # Geodetic (lat,lon,h) system\n    geocent_crs = CRS.from_epsg(4978) # Geocentric (X,Y,Z) system\n\n    geodet_to_geocent = Transformer.from_crs(geodet_crs, geocent_crs)\n\n    X, Y, Z = geodet_to_geocent.transform(lat, lon, height)\n\n    return X, Y, Z\n</code></pre>"},{"location":"Utils/#a2gUtils.make_flight_graph_coordinates","title":"<code>make_flight_graph_coordinates(flight_graph, number_stops_per_edge)</code>","text":"<p>Calculates the intermediate coordinates for the flight graph provided with the given number of stops per edge.</p> <p>Parameters:</p> Name Type Description Default <code>flight_graph</code> <code>numpy 2d-array</code> <p>the provided array rows MUST be ordered according to the                             order of the planned stops of the drone. For example:                            1st row corresponds to the first stop of the drone,                            2nd row corresponds to the second stop of the drone, and so on.</p> required <code>number_stops_per_edge</code> <code>int</code> <p>number of stops per edge. It includes both vertexes of the edge.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>description</p> <p>Returns:</p> Name Type Description <code>intermediate_coords</code> <code>dict</code> <p>a dictionary whose structure is as follows:                         {'EDGE_1': {'LAT': [], 'LON':[]}, 'EDGE_2': {'LAT': [], 'LON':[]}, ...}</p> Source code in <code>a2gUtils.py</code> <pre><code>def make_flight_graph_coordinates(flight_graph, number_stops_per_edge):\n        \"\"\"\n        Calculates the intermediate coordinates for the flight graph provided with the given number of stops per edge.\n\n\n        Args:\n            flight_graph (numpy 2d-array): the provided array rows MUST be ordered according to the \n                                           order of the planned stops of the drone. For example:\n                                           1st row corresponds to the first stop of the drone,\n                                           2nd row corresponds to the second stop of the drone, and so on.\n            number_stops_per_edge (int): number of stops per edge. It includes both vertexes of the edge.\n\n        Raises:\n            Exception: _description_\n\n        Returns:\n            intermediate_coords (dict): a dictionary whose structure is as follows:\n                                        {'EDGE_1': {'LAT': [], 'LON':[]}, 'EDGE_2': {'LAT': [], 'LON':[]}, ...}\n        \"\"\"\n\n        flight_graph_2nd_end = flight_graph[1:, :]\n        flight_graph_1st_before_end = flight_graph[:-1, :]\n\n        wgs84_geod = Geod(ellps='WGS84')\n\n        az12, _, dist = wgs84_geod.inv(flight_graph_1st_before_end[:, 1], \n                                          flight_graph_1st_before_end[:, 0], \n                                          flight_graph_2nd_end[:, 1], \n                                          flight_graph_2nd_end[:, 0])\n\n        intermediate_coords = {}\n        for i in range(flight_graph_2nd_end.shape[0]):\n            intermediate_coords['EDGE_'+str(i+1)] = {'LAT': [], 'LON': []}\n            lon_2, lat_2, _ = wgs84_geod.fwd(flight_graph_1st_before_end[i, 1], flight_graph_1st_before_end[i, 0], az12[i], dist[i]/(number_stops_per_edge-1))\n            intermediate_coords['EDGE_'+str(i+1)]['LAT'].append(lat_2)\n            intermediate_coords['EDGE_'+str(i+1)]['LON'].append(lon_2)\n\n            for j in range(number_stops_per_edge-3):\n                lon_2, lat_2, _ = wgs84_geod.fwd(lon_2, lat_2, az12[i], dist[i]/(number_stops_per_edge-1))\n                intermediate_coords['EDGE_'+str(i+1)]['LAT'].append(lat_2)\n                intermediate_coords['EDGE_'+str(i+1)]['LON'].append(lon_2)\n\n        return intermediate_coords\n</code></pre>"}]}